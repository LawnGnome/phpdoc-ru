<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1.10 Maintainer: alexws Status: ready -->
<!-- $Revision: 1.4 $ -->
 <chapter id="tutorial">
  <title>Краткое руководство</title>

  <para>
   В данном кратком руководстве на примерах объясняются основы PHP.
   Это руководство включает в себя только создание динамических
   Web-страниц с помощью PHP, однако реальная область применения PHP 
   гораздо шире. В разделе "<link linkend="intro-whatcando">Что может
   PHP</link>" приведена дополнительная информация.
  </para>
  <para>
   Созданные с использованием PHP Web-страницы обрабатываются, как обычные
   HTML-страницы. Их можно создавать и изменять точно таким же образом,
   как и обычные страницы на HTML.
  </para>

  <sect1 id="tutorial.requirements">
   <title>Что потребуется?</title>
   <para>
    В данном руководстве мы предполагаем, что ваш сервер имеет
    поддержку PHP и что все файлы, заканчивающиеся на <filename>.php</filename>,
    обрабатываются PHP. В большинстве серверов это расширение используется для
    PHP по умолчанию, но все-таки не лишним будет уточнить это у вашего
    администратора сервера. Если ваш сервер поддерживает PHP, то у вас есть
    все, что требуется. Просто создавайте ваши файлы <filename>.php</filename>
    и размещайте их в вашем каталоге Web-сервера - они будут обрабатываться
    автоматически. Не нужно ничего компилировать, не нужно никаких
    дополнительных программ. Считайте файлы PHP обычными файлами HTML с
    набором новых "волшебных" тегов, которые позволяют вам делать все, что
    угодно.
   </para>
  </sect1>

  <sect1 id="tutorial.firstpage">
   <title>Первая страница на PHP</title>
   <para>
    Создайте файл с именем <filename>hello.php</filename> в корневом
    каталоге ваших документов Web-сервера и запишите в него следующее:
   </para>
   <para>
    <example>
     <title>Первый скрипт на PHP: <filename>hello.php</filename></title>
     <programlisting role="php">
<![CDATA[
<html>
 <head>
  <title>Тестируем PHP</title>
 </head>
 <body>
 <?php echo "Привет!<p>"; ?>
 </body>
</html>
]]>
     </programlisting>
     <para>
      Эта программа выведет следующее:
      <screen role="html">
<![CDATA[
<html>
 <head>
  <title>Тестируем PHP</title>
 </head>
 <body>
 Привет!<p>
 </body>
</html>
]]>
      </screen>
     </para>
    </example>
   </para>
   <para>
    Заметим, что сходства со скриптами на CGI нет. Файл не обязан быть
    выполнимым или отмеченным любым другим образом. Это просто обычный
    файл HTML, в котором есть набор специальных тегов, делающих много
    интересного.
   </para>
   <para>
    Эта программа чрезвычайно проста, и для создания настолько простой
    странички даже необязательно использовать PHP. Все что она делает -
    это выводит "<literal>Привет!</literal> с использованием функции
    PHP <function>echo</function>.
   </para>
   <para>
    Если у вас этот пример не отображает ничего или выводит окно загрузки,
    или если вы видите весь этот файл в текстовом виде, то весьма вероятно,
    что ваш Web-сервер не имеет поддержки PHP. Попросите вашего администратора
    сервера включить такую поддержку. Предложите ему инструкцию по установке -
    раздел "<link linkend="installation">Установка</link>" данной
    документации.  Если же вы хотите разрабатывать скрипты на PHP дома,
    то вам в раздел <ulink url="&url.php.downloads;">необходимые файлы</ulink>.
    Дома можно разрабатывать скрипты с использованием любой операционной 
    системы, но вам понадобится установить соответствующий Web-сервер.
   </para>
   <para>
    Цель примера - показать формат специальных тегов PHP. В этом примере
    мы использовали <literal>&lt;?php</literal> в качестве открывающего
    тега, затем шли команды PHP, завершающиеся закрывающим тегом
    <literal>?&gt;</literal>. Таким образом можно сколько угодно раз
    переходить к коду PHP в файле HTML.
   </para>
   <note>
    <title>Пара слов о текстовых редакторах</title>
    <para>
     Существует множество текстовых редакторов и интегрированных сред
     разработки (IDE), в которых вы можете создавать и редактировать файлы
     PHP. Список некоторых редакторов содержится в разделе
     "<ulink url="&url.phpeditorlist;">Список редакторов PHP</ulink>". 
     Если вы хотите порекомендовать какой-либо редактор, посетите данную
     страницу и попросите добавить данный редактор в список.
    </para>
   </note>
   
   <note>
    <title>Пара слов о текстовых процессорах</title>
    <para>
     Текстовые процессоры (StarOffice Writer, Microsoft Word, Abiword и
     др.) в большинстве случаев не подходят для редактирования файлов PHP.
    </para>

    <para>
     Если вы используете текстовый процессор для создания скриптов на PHP,
     вы должны быть уверены, что сохраняете файл, как ЧИСТО ТЕКСТОВЫЙ. В
     противном случае PHP не сможет обработать и выполнить вашу программу.
    </para>
   </note>
   
   <note>
    <title>Пара слов о "Блокноте" Windows</title>
    <para>    
     При написании скриптов PHP с использованием встроенного "Блокнота"
     Windows необходимо сохранять файлы с расширением .php. "Блокнот"
     автоматически добавляет расширение .txt. Для обхода этой проблемы
     существует несколько методов.
    </para>

    <para>    
     Можно поместить название файла в кавычки (пример: "hello.php").
    </para>

    <para>
     Кроме того, можно выбрать "Все файлы" вместо "Текстовые документы" из
     ниспадающего списка с типами файлов в окне сохранения. После этого
     можно вводить имя файла без кавычек.
    </para>
  </note>
   
  </sect1>

  <sect1 id="tutorial.useful">
   <title>Делаем что-нибудь полезное</title>
   <para>
    Давайте сделаем что-нибудь полезное. К примеру, определим, какой
    браузер использует тот, кто смотрит в данный момент нашу страницу.
    Для этого мы проверим строку с именем браузера, посылаемую нам в
    HTTP-запросе. Эта информация хранится в <link
    linkend="language.variables">переменной</link>. Переменные в PHP всегда
    предваряются знаком доллара. Интересующая нас в данный момент переменная
    называется <varname>$_SERVER["HTTP_USER_AGENT"]</varname>.
   </para>
   <note>
    <title>Пару слов об автоматической глобализации переменных в PHP</title>
    <para>
     <link linkend="reserved.variables.server">$_SERVER</link> - специальная
     зарезервированная переменная PHP, которая содержит всю информацию,
     полученную от Web-сервера. Она является автоглобализованной (или
     суперглобальной). Для более подробной информации смотрите раздел
     "<link linkend="language.variables.superglobals">Суперглобальные 
     переменные</link>". Эти специальные переменные появились в PHP, начиная 
     с версии <ulink url="&url.php.release4.1.0;">4.1.0</ulink>.  До этого
     использовались массивы <varname>$HTTP_*_VARS</varname>, такие, как
     <varname>$HTTP_SERVER_VARS</varname>. Эти массивы, несмотря на то,
     что они уже устарели, до сих пор существуют (см. замечания по
     <link linkend="tutorial.oldcode">старым программам</link>).
    </para>
   </note>
   <para>
    Для вывода данной переменной мы сделаем так:
   </para>
   <para>
    <example>
    <title>Вывод значения переменной (элемента массива)</title>
    <programlisting role="php">
<![CDATA[
<?php echo $_SERVER["HTTP_USER_AGENT"]; ?>
]]>
    </programlisting>
    <para>
     Пример вывода данной программы:
     <screen role="html">
Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)
     </screen>
    </para>
   </example>
   </para>
   <para>
    В PHP есть огромное количество <link linkend="language.types">типов</link>
    переменных. В предыдущем примере мы печатали элемент
    <link linkend="language.types.array">массива</link>. Массивы
    в PHP являются очень мощным средством.
   </para>
   <para>
    <varname>$_SERVER</varname> - просто переменная, которая предоставлена
    вам языком PHP. Список таких переменных можно посмотреть в разделе
    "<link linkend="reserved.variables">Зарезервированные переменные</link>".
    А можно получить их полный список с помощью такой программы:
   </para>
   <para>
    <example>
     <title>Показываем все стандартные переменные с помощью
     функции <function>phpinfo</function></title>
     <programlisting role="php">
<![CDATA[
<?php phpinfo(); ?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Если открыть данный файл в браузере, вы увидите страничку с
    информацией о PHP, а также список всех доступных вам переменных.
   </para>
   <para>
    Внутрь тегов PHP можно помещать множество команд и создавать
    кусочки кода, делающие гораздо большее, чем просто вывод на экран.
    К примеру, если мы хотим сделать проверку на Internet Explorer, мы
    можем поступить так:
   </para>
   <para>
    <example>
     <title>Пример использования <link linkend="control-structures">управляющих
     структур</link> и <link linkend="functions">функций</link></title>
     <programlisting role="php">
<![CDATA[
<?php
if (strstr($_SERVER["HTTP_USER_AGENT"], "MSIE")) {
	echo "Вы используете Internet Explorer<br />";
}
?>
]]>
     </programlisting>
     <para>
      Пример вывода данной программы:
      <screen role="html">
<![CDATA[
You are using Internet Explorer<br />
]]>
      </screen>
     </para>
    </example>
   </para>
   <para>
    Здесь мы показали несколько новых элементов. Во-первых, здесь есть
    команда <link linkend="control-structures.if">if</link>.
    Если вам знаком основной синтаксис языка C, то вы уже заметили что-то
    схожее. Если же вы не знаете C или подобного по синтаксису языка, то
    лучший вариант - взять какую-либо книжку по PHP и прочитать ее. Другой
    вариант - почитать раздел "<link linkend="langref">Описание языка</link>"
    данного руководства. Список книг по PHP можно найти здесь:
    <ulink url="&url.php.books;">&url.php.books;</ulink>.
   </para>
   <para>
    Во-вторых, здесь есть вызов функции <function>strstr</function>.
    <function>strstr</function> - встроенная в PHP функция, которая ищет
    одну строку в другой. В данном случае мы ищем строку
    <literal>"MSIE"</literal> в <varname>$_SERVER["HTTP_USER_AGENT"]</varname>.
    Если строка не найдена, эта функция возвращает &false;, если найдена -
    &true;. Если она вернет &true;, то условие в
    <link linkend="control-structures.if">if</link> окажется истинным, и
    код в командных скобках ({ }) выполнится. В противном случае данный код
    не выполняется. Попробуйте создать аналогичные примеры с использованием
    команд <link linkend="control-structures.if">if</link>, 
    <link linkend="control-structures.else">else</link>, и других функций,
    таких, как <function>strtoupper</function> и <function>strlen</function>.
    Также примеры содержатся во многих описаниях функций в данном руководстве.
   </para>
   <para>
    Продемонстрируем, как можно входить в режим кода PHP и выходить из
    него прямо внутри кода:
   </para>
   <para>
    <example>
     <title>Смешение режимов HTML и PHP</title>
     <programlisting role="php">
<![CDATA[
<?php
if (strstr($_SERVER["HTTP_USER_AGENT"], "MSIE")) {
?>
<h3>strstr вернул true</h3>
<center><b>Вы используете Internet Explorer</b></center>
<?php
} else {
?>
<h3>strstr вернул false</h3>
<center><b>Вы не используете Internet Explorer</b></center>
<?php
}
?>
]]>
     </programlisting>
     <para>
      Пример вывода данной программы:
      <screen role="html">
<![CDATA[
<h3>strstr вернул true</h3>
<center><b>Вы используете Internet Explorer</b></center>
]]>
      </screen>
     </para>
    </example>
   </para>
   <para>
    Вместо использования команды PHP echo для вывода, мы вышли из режима
    кода и послали содержимое HTML. Важный момент здесь - то, что логическая
    структура кода PHP при этом не теряется. Только одна HTML-часть будет
    послана клиенту в зависимости от результата функции
    <function>strstr</function> (другими словами, в зависимости от того,
    найдена строка "MSIE" или нет).
   </para>
  </sect1>
   
  <sect1 id="tutorial.forms">
   <title>Работа с формами</title>
   <para>
    Одно из главнейших достоинств PHP - то, как он работает с формами HTML.
    Здесь основным является то, что каждый элемент формы автоматически
    станет доступен вашим программам на PHP. Для подробной информации об
    использовании форм в PHP читайте раздел "
    <link linkend="language.variables.external">Переменные из внешних
    источников</link>". Вот пример формы HTML:
   </para>
   <para>
    <example>
     <title>Простейшая форма HTML</title>
     <programlisting role="html">
<![CDATA[
<form action="action.php" method="POST">
 Ваше имя: <input type="text" name="name" />
 Ваш возраст: <input type="text" name="age" />
 <input type="submit">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    В этой форме нет ничего особенного. Это обычная форма HTML без каких-либо
    специальных тегов. Когда пользователь заполнит форму и нажмет кнопку
    отправки, будет вызвана страница <filename>action.php</filename>. В
    этом файле может быть что-то вроде:
   </para>
   <para>
    <example>
     <title>Выводим данные нашей формы</title>
     <programlisting role="php">
<![CDATA[
Здравствуйте, <?php echo $_POST["name"]; ?>.
Вам <?php echo $_POST["age"]; ?> лет.
]]>
     </programlisting>
     <para>
      Пример вывода данной программы:
      <screen role="html">
<![CDATA[
Здравствуйте, Сергей.
Вам 30 лет.
]]>
      </screen>
     </para>
    </example>
   </para>
   <para>
    Принцип работы данного кода прост и понятен. Переменные
    The <varname>$_POST["name"]</varname> и <varname>$_POST["age"]</varname>
    автоматически установлены для вас средствами PHP. Ранее мы использовали
    переменную <varname>$_SERVER</varname>, здесь же мы точно также используем
    суперглобальную переменную
    <link linkend="reserved.variables.post">$_POST</link>, которая содержит
    все POST-данные. Заметим, что <emphasis>метод отправки</emphasis> нашей
    формы - POST.  Если бы мы использовали метод <emphasis>GET</emphasis>,
    то информация нашей формы была бы в суперглобальной переменной
    <link linkend="reserved.variables.get">$_GET</link>.
    Также можно использовать переменную
    <link linkend="reserved.variables.request">$_REQUEST</link>, если
    источник данных не имеет значения. Эта переменная содержит смесь
    данных GET, POST, COOKIE и FILE. Также советуем взглянуть на описание
    функции <function>import_request_variables</function>.
   </para>
  </sect1>
  
  <sect1 id="tutorial.oldcode">
   <title>Использование старых программ с новыми версиями PHP</title>
   <para>
    Сейчас PHP является популярным языком сценариев (скриптов). Становится
    все больше и больше распространяемых кусочков кода, которые вы можете
    использовать в своих скриптах. В большинстве случаев разработчики
    PHP старались сохранить совместимость с предыдущими версиями так, что
    код, написанный для более старой версии будет идеально работать и
    с новыми версиями языка без каких-либо изменений. Однако случается
    так, что изменения все-таки необходимы.
   </para>
   <para>
    Есть два важных изменения, которые влияют на старые программы:
    <itemizedlist>
     <listitem>
      <simpara>
       Объявление массивов <varname>$HTTP_*_VARS</varname> устаревшими. Эти
       массивы требовали глобализации в функциях и процедурах. Новые
       <link linkend="language.variables.superglobals">суперглобальные
       массивы</link> были введены, начиная с PHP
       <ulink url="&url.php.release4.1.0;">4.1.0</ulink>.
       Это: <varname>$_GET</varname>, <varname>$_POST</varname>, 
       <varname>$_COOKIE</varname>, <varname>$_SERVER</varname>, 
       <varname>$_ENV</varname>, <varname>$_REQUEST</varname>, и
       <varname>$_SESSION</varname>. Более старые массивы
       <varname>$HTTP_*_VARS</varname>, такие, как $HTTP_POST_VARS,
       существуют со времен PHP 3 и, вероятно, будут еще долго
       существовать для сохранения совместимости.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Внешние переменные больше не глобализуются по умолчанию. Другими
       словами, директива <link
       linkend="ini.register-globals">register_globals</link> в &php.ini;
       по умолчанию отключена ("off"), начиная с PHP
       <ulink url="&url.php.release4.2.0;">4.2.0</ulink>.
       Рекомендуемый метод доступа к таким переменным - суперглобальные
       массивы, описанные выше. Более старые программы, книги и руководства
       могут считать, что данная директива включена ("on"). К примеру,
       переменная <varname>$id</varname> может поступать из строки URL 
       <literal>http://www.example.com/foo.php?id=42</literal>. Когда указанная
       директива выключена, <varname>$id</varname> доступна лишь как
       <varname>$_GET['id']</varname>.
      </simpara>
     </listitem>
    </itemizedlist>
    Для дополнительной информации касательно изменений, связанных с
    переменными, смотрите раздел "<link 
    linkend="language.variables.predefined">Предопределенные переменные</link>"
    и ссылки этого раздела.
   </para>
  </sect1>
  
  <sect1 id="tutorial.whatsnext">
   <title>Что дальше?</title>
   <para>
    То, что вы узнали, поможет вам понять большую часть руководства и
    разобраться в большинстве приведенных примеров программ. Другие
    примеры находятся на различных сайтах, ссылки на которые можно найти
    на php.net: <ulink url="&url.php.links;">&url.php.links;</ulink>.
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

