<?xml version="1.0" encoding="windows-1251"?>
<!-- EN-Revision: 1.50 Maintainer: alexws Status: ready -->
<!-- $Revision: 1.5 $ -->
 <chapter id="security">
  <title>Безопасность</title>

  <simpara>
   PHP - это мощный язык программирования и интерпретатор. Будучи
   интегрированным в виде модуля в Web-сервер, или выполняясь как
   отдельное <acronym>CGI</acronym>-приложение, он может обращаться
   к файлам, исполнять команды и открывать сетевые соединения на
   сервере. Эти особенности делают все, что выполняется на Web-сервере,
   небезопасным. PHP специально разрабатывался для того, чтобы быть
   более безопасным языком для написания CGI-совместимых программ,
   нежели Perl или С, и, если правильно выставлены настройки компиляции
   и выполнения, а также при наличии достаточного опыта программирования,
   PHP даст вам необходимое соотношение гибкости и безопасности.
  </simpara>
  <simpara>
   Поскольку существует множество различных вариантов использования PHP,
   существует очень много настроек, контролирующих его поведение.
   Большой выбор опций означает, что вы сможете использовать PHP для
   многих целей, однако также значит, что есть такие комбинации этих
   опций и настроек сервера, которые приведут к проблемам безопасности.
  </simpara>
  <simpara>
   Гибкость настройки PHP конкурирует с гибкостью программирования.
   PHP может быть использован для создания серверных приложений со всеми
   возможностями пользователя shell, или для простого включения файлов на
   стороне сервера, которое не представляет опасности в хорошо контролируемой
   системе. То, как построена система, и насколько она безопасна, практически
   полностью зависит от разработчика, использующего PHP.
  </simpara>
  <simpara>
   В начале главы даются основные советы по реализации безопасности,
   объясняются различные комбинации опций настройки и ситуации, в которых
   они могут быть безопасно использованы. Также приводятся различные
   соображения по части программирования для разных уровней безопасности.
  </simpara>

  <sect1 id="security.general">
   <title>Основные положения</title>
   <simpara>
    Полностью безопасная система практически не может существовать, поэтому
    основной используемый здесь подход - подход разумного риска. К примеру,
    если каждая переменная, переданная пользователем, будет требовать двух
    биометрических подтверждений (вроде сканирования сетчатки и отпечатка
    пальца), у вас будет очень высокий уровень контроля. С другой стороны,
    заполнение длинных и сложных форм может занимать достаточно длительное
    время, что обычно заставляет пользователей искать пути обхода системы
    безопасности.
   </simpara>
   <simpara>
    Наилучший вариант обычно соответствует требованиям безопасности,
    но не мешает работе пользователей, а также не перегружает программный
    код излишней сложностью. Что касается сложности, то некоторые атаки
    как раз и являются следствием чрезмерного "наворачивания" защиты.
    Как известно, чем сложнее защита, тем больше в ней не совсем очевидных
    "дыр".
   </simpara>
   <simpara>
    Всегда необходимо помнить: система безопасности настолько хороша,
    насколько безопасно ее самое слабое место. Если, к примеру, ведутся 
    отчеты по всем операциям, времени, месту и т.д., но проверка пользователей
    осуществляется с использованием одного cookie, то соответствие имен
    пользователей в отчетах с реальными пользователями весьма и весьма
    сомнительно.
   </simpara>
   <simpara>
    При отладке помните, что невозможно предугадать все варианты развития
    событий даже для одной единственной странички. Ожидаемые входные данные
    могут отличаться от введенных недобросовестным работником, хакером с
    многолетним стажем или просто кошкой, прошедшейся по клавиатуре.
    Поэтому всегда удобнее подходить к программе с точки зрения логики,
    чтобы проследить места возможного появления неожиданных данных, а
    также их использования. 
   </simpara>
   <simpara>
    Интернет полон людей, которые хотят сделать себе имя путем взлома
    вашего кода, останова вашего сайта, размещения неподходящих данных,
    в общем, всего, что не дает вам жить спокойно. Неважно, какого масштаба
    ваш сайт, вы находитесь под прицелом просто потому, что вы в сети, 
    потому, что у вас есть сервер, к которому можно подключиться.
    Множество программ для взлома не различают размеров, они просто
    прокачивают огромное количество IP-траффика в поисках жертвы.
    Постарайтесь не стать таковой.
   </simpara>
  </sect1>

  <sect1 id="security.cgi-bin">
   <title>При инсталляции в виде приложения CGI</title>

   <sect2 id="security.cgi-bin.attacks">
    <title>Возможные атаки</title>
    <simpara>
     Использование PHP в виде приложения <acronym>CGI</acronym> - вариант
     для тех, кто по тем или иным причинам не хочет встраивать PHP в
     приложение сервера (к примеру, Apache), в виде модуля, или для тех,
     то хочет использовать PHP совместно с CGI-оболочками, помогающими
     создать безопасную среду для выполнения программ. Такая настройка
     обычно включает в себя инсталляцию приложения PHP в директорию
     cgi-bin на сервере. Рекомендация CERT<ulink url="&url.cert;">CA-96.11</ulink>
     выступает против помещения интерпретаторов в cgi-bin. Даже при том, что
     PHP  может быть использован, как независимый интерпретатор, он
     разрабатавылся для предотвращения атак, связанных с данным вариантом
     настройки:
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       Получение доступа к системным файлам: <filename
       role="url">http://my.host/cgi-bin/php?/etc/passwd</filename>
      </simpara>
      <simpara>
       Информация запроса в URL после знака вопроса (?) передается
       с помощью CGI интерпретатору в виде командной строки. Обычно
       интерпретаторы открывают и выполняют файл, заданный первым
       аргументом в данной строке.
      </simpara>
      <simpara>
       При вызове в роли приложения CGI, PHP не интерпретирует аргументы
       командной строки.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Получение доступа к любому документу на сервере: <filename
       role="url">http://my.host/cgi-bin/php/secret/doc.html</filename>
      </simpara>
      <simpara>
       Информационнася часть URL после названия приложения PHP
       <filename role="uri">/secret/doc.html</filename> обычно
       используется для задания файла, который будет открыт и
       интерпретирован приложением <acronym>CGI</acronym>.
       В общем случае для перенаправления запросов вида
       <filename role="url">http://my.host/secret/script.php</filename>
       интерпретатору PHP используются директивы конфигурации Web-сервера
       (к примеру, Action в Apache). При такой настройке, сервер сначала
       проверяет разрешения на доступ к данной директории
       <filename role="uri">/secret</filename>, и только после создает
       перенаправленный запрос <filename
       role="url">http://my.host/cgi-bin/php/secret/script.php</filename>.
       К сожалению, если запрос уже дан в вышеприведенной форме, сервер
       не выполняет никаких проверок на право доступа к файлу <filename
       role="uri">/secret/script.php</filename>, выполняя данную проверку
       только для файла <filename role="uri">/cgi-bin/php</filename>.
       Таким образом, любой пользователь c доступом к <filename 
       role="uri">/cgi-bin/php</filename> может получить доступ к любому
       защищенному документу на сервере.
      </simpara>
      <simpara>
       В PHP, опция конфигурации компилятора<link
       linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
       и опции конфигурации времени выполнения<link
       linkend="ini.doc-root">doc_root</link> и <link
       linkend="ini.user-dir">user_dir</link> могут быть использованы для
       предотвращения подобных атак, если дерево документов сервера имеет
       каталоги с ограничением доступа. Далее приводятся подробные
       пояснения к различным комбинациям опций.
      </simpara>
     </listitem>
    </itemizedlist>
   </sect2>

   <sect2 id="security.cgi-bin.default">
    <title>Вариант 1: предоставление только общего содержимого</title>

    <simpara>
     Если ваш сервер не содержит ничего защищенного паролем или списком
     IP-адресов, то в вышеперечисленных опциях нет необходимости.
     Если ваш Web-сервер не допускает перенаправлений, или если сервер
     не имеет возможности безопасно перенаправить запрос приложению
     PHP, вы можете установить опцию <link
     linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
     конфигурирующей программе. Однако, вам все равно придется следить
     за тем, чтобы ваши программы не зависели от метода их вызова, как
     прямого <filename role="php">http://my.host/cgi-bin/php/dir/script.php</filename>
     так и с использованием перенаправления <filename
     role="php">http://my.host/dir/script.php</filename>.
    </simpara>
    <simpara>
     Перенаправление может быть настроено в сервере Apache с использованием
     директив AddHandler и Action directives (см. ниже).
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.force-redirect">
    <title>Вариант 2: использование --enable-force-cgi-redirect</title>
    <simpara>
     Эта опция компиляции не дает никому использовать PHP напрямую,
     с применением URL вроде <filename
     role="php">http://my.host/cgi-bin/php/secretdir/script.php</filename>.
     PHP будет транслировать данные только в том случае, если они уже прошли
     через перенаправление Web-сервера.
    </simpara>
    <simpara>
     Обычно перенаправление в сервере Apache конфигурируется с использованием
     следующих команд:
    </simpara>
    <programlisting role="apache-conf">
<![CDATA[
Action php-script /cgi-bin/php
AddHandler php-script .php
]]>
    </programlisting>
    <simpara>
     Эта опция была проверена только для Web-сервера Apache и основывается
     на установке им не-CGI-стандартной переменной окружения
     <envar>REDIRECT_STATUS</envar> для перенаправленных запросов.
     Если ваш Web-сервер не поддерживает никаких путей указания того,
     осуществлялось ли перенаправление запроса, вы не можете использовать
     эту опцию и должны использовать другие варианты использования
     приложения CGI, описанные ниже.
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.doc-root">
    <title>Вариант 3: установка doc_root или user_dir</title>
    <simpara>
     Помещение активного содержимого (вроде программ и исполняемых файлов)
     в директории документов Web-сервера считается небезопасным. Если
     в случае какой-либо ошибки в конфигурировании программы не выполнятся,
     а отобразятся как обычные HTML-документы, это приведет к утечке
     интеллектуальной собственности или скрытой информации вроде паролей.
     Поэтому многие системные администраторы предпочитают создавать
     отдельную структуру директорий для программ, доступных только через
     PHP CGI, а поэтому всегда интепретируемых и отображаемых верно.
    </simpara>
    <simpara>
     К тому же, если недоступен метод безопасного перенаправления запросов,
     описанный в предыдущей части, необходимо установить doc_root для
     программ, отличный от корневого каталога документов Web-сервера.
    </simpara>
    <simpara>
     Корневой каталог документов для программ PHP можно установить
     с помощью директивы <link linkend="ini.doc-root">doc_root</link>
     в <link linkend="configuration.file">файле конфигурации</link> или
     с помощью переменной окружения <envar>PHP_DOCUMENT_ROOT</envar>.
     Если такая установка сделана, то CGI-версия PHP всегда будет добавлять
     к информации пути в запросе значение параметра
     <parameter>doc_root</parameter>, так что в этом случае вы можете быть
     уверены, что ни одна программа не выполнится за пределами этой
     директории (исключение составляет лишь случай с использованием
     параметра <parameter>user_dir</parameter>, описанный ниже).
    </simpara>
    <simpara>
     Еще одной полезной опцией является <link linkend="ini.user-dir">user_dir</link>.
     Если user_dir не задана, то единственным фактором, влияющим на имя
     открываемого файла является <parameter>doc_root</parameter>. Открытие
     URL вроде <filename role="url">http://my.host/~user/doc.php</filename>
     не приведет в этом случае к открытию файла внутри домашнего каталога
     пользователя. В этом случае будет открыт файл
     <filename role="uri">~user/doc.php</filename> в каталоге, заданном в
     doc_root.
    </simpara>
    <simpara>
     Если user_dir установлена, к примеру, в <filename
     role="dir">public_php</filename>, то запрос <filename
     role="url">http://my.host/~user/doc.php</filename> откроет файл
     <filename>doc.php</filename> в каталоге <filename 
     role="dir">public_php</filename>, находящемся в домашнем каталоге
     пользователя. Если домашний каталог пользователя - <filename
     role="dir">/home/user</filename>, то в этом случае будет открыт
     файл <filename>/home/user/public_php/doc.php</filename>.
    </simpara>
    <simpara>
     <parameter>user_dir</parameter> используется независимо от
     <parameter>doc_root</parameter>, что дает возможность задавать
     корневую директорию документов и пользовательские директории
     независимо друг от друга.
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.shell">
    <title>Вариант 4: интерпретатор PHP вне дерева документов Web</title>
    <para>
     Весьма безопасным является помещение программы-транслятора PHP
     за пределами дерева документов Web-сервера. К примеру, в <filename
     role="dir">/usr/local/bin</filename>.  У этого варианта есть лишь
     один недостаток - то, что в начало каждого файла с тегами PHP придется
     помещать следующую строку:
     <informalexample>
      <programlisting>
<![CDATA[
#!/usr/local/bin/php
]]>
      </programlisting>
     </informalexample>
     . Также потребуется сделать данные файлы исполняемыми, т.е. придется
     обращаться с ними так же, как и с любыми другими CGI-программами на
     Perl, sh или на других известных языках, использующих конструкцию
     <literal>#!</literal> для запуска.
    </para>
    <para>
     Для того, чтобы PHP начал в данном случае корректно обрабатывать
     <envar>PATH_INFO</envar> и <envar>PATH_TRANSLATED</envar>, транслятор
     PHP должен быть скомпилирован с опцией конфигурации <link
     linkend="install.configure.enable-discard-path">--enable-discard-path</link>.
    </para>
   </sect2>

  </sect1>

  <sect1 id="security.apache">
   <title>При инсталляции в виде модуля Apache</title>
   <simpara>
    При использовании PHP, как модуля Apache, данный модуль получает
    все права и разрешения Apache (обычно, права пользователя "nobody",
    т.е. "отсутствующего" пользователя). Это вносит некоторые сложности
    в систему безопасности и авторизации. К примеру, если PHP используется
    для обращения к базе данных, то в случае отсутствия встроенного контроля
    доступа в базе данных ее придется сделать доступной для пользователя
    "nobody". В этом случае скрипт злоумышленника может получить доступ
    на чтение и изменение базы данных даже без указания имени пользователя
    и пароля. Также возможно, что сетевой червь проникнет на страницу
    администратора и уничтожит все ваши базы данных. Можно защититься от
    этого путем введения авторизации в Apache, или разработав собственную
    модель доступа с использованием LDAP, файлов .htaccess (и др.) и
    использовать этот код, как часть ваших программ на PHP.
   </simpara>
   <simpara>
    Часто случается так, что когда безопасность достигает уровня, где
    PHP (а в данном случае, Apache) практически не представляет
    проблемы безопасности, оказывается, что PHP не может записать ни
    одного файла в пользовательские каталоги. Или, допустим, не имеет
    доступа к базам данных. PHP оказывается одинакого защищенным от
    записи дозволенных и недозволенных файлов, или от произведения
    дозволенных или недозволенных операций с базами данных.
   </simpara>
   <simpara>
    Очень частая ошибка на этом этапе - дать PHP права "root", или
    администратора или каким-либо образом увеличить разрешения для
    Apache.
   </simpara>
   <simpara>
    Установка для Apache разрешений администратора (root) очень опасна
    для системы в целом. Те, кто не является специалистами по безопасности,
    в данном случае должны избегать любых операций вроде "sudo" или "chroot".
   </simpara>
   <simpara>
    Есть более простые решения. Используя
    <link linkend="ini.open-basedir">open_basedir</link>, можно
    контролировать и ограничивать использование PHP директорий. Также
    можно создать области "только для Apache", ограничив весь доступ
    не-пользовательскими или не-системными файлами.
   </simpara>
  </sect1>

  <sect1 id="security.filesystem">
   <title>Безопасность файловой системы</title>
   <simpara>
    PHP подчиняется установкам безопасности на уровне файлов и каталогов,
    которые встроены в большинство серверных систем. Это позволяет
    контролировать, какие файлы могут быть прочитаны. С особой аккуратностью
    нужно относиться к файлам с правом чтения "для всех" - нужно помнить
    о том, они могут быть считаны любым пользователем, имеющим доступ к
    данной файловой системе.
   </simpara>
   <simpara>
    Поскольку PHP разрабатывался для предоставления пользовательских
    прав доступа к системе, возможно создать программу на PHP, которая
    позволит вам читать системные файлы, такие, как /etc/passwd, изменять
    параметры ваших сетевых соединений, создавать большие задания для печати
    и т.п. Это создает ряд проблем - нужно быть уверенным в том, что именно 
    необходимые файлы разрешены для чтения и записи.
   </simpara>
   <simpara>
    Приведем следующую программу, где пользователь хочет стереть
    файл в своем домашнем каталоге. Это типичная ситуация, когда
    Web-интерфейс PHP используется для управления файлами, т.е.
    пользователи Apache имеют возможность удалять файлы в своих
    домашних каталогах.
   </simpara>
   <para>
    <example>
     <title>Недостаточная проверка переменных - последствия...</title>
     <programlisting role="php">
<![CDATA[
<?php
// удаляем файл из пользовательского домашнего каталога
$username = $_POST['user_submitted_name'];
$homedir = "/home/$username";
$file_to_delete = "$userfile";
unlink ($homedir/$userfile);
echo "$file_to_delete удален!";
?>
]]>
     </programlisting>
    </example>
   Поскольку имя пользователя предоставляется пользовательской формой
   ввода, можно подставить любые имена пользователя и файла, даже если
   этот файл принадлежит кому-то другому. В этом случае необходимо
   использовать схему аутентификации пользователей. Кроме того,
   представьте, что случится, если переданные переменные будут
   соответственно "../etc/" и "passwd". Тогда программа будет выглядеть
   так:
    <example>
     <title>... Атака на файловую систему</title>
     <programlisting role="php">
<![CDATA[
<?php
// удаляет любой файл в зоне действия прав пользователя
// Если PHP имеет права администратора:
$username = "../etc/";
$homedir = "/home/../etc/";
$file_to_delete = "passwd";
unlink ("/home/../etc/passwd");
echo "/home/../etc/passwd удален!";
?>
]]>
     </programlisting>
    </example>
    В борьбе с подобными случаями есть два ключевых момента.
    <itemizedlist>
     <listitem>
      <simpara>
       Назначение интерпретатору PHP ограниченных прав.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Проверка всех переданных переменных.
      </simpara>
     </listitem>
    </itemizedlist>
    Вот улучшенная программа:
    <example>
     <title>Более безопасная проверка имени файла</title>
     <programlisting role="php">
<![CDATA[
<?php
// удаляет любой файл в зоне действия прав пользователя
// Если PHP имеет права администратора:
$username = $_SERVER['REMOTE_USER']; // используем механизм аутентификации

$homedir = "/home/$username";

$file_to_delete = basename("$userfile"); // отрезать пути
unlink ("$homedir/$file_to_delete");

$fp = fopen("/home/logging/filedelete.log","+a"); // отчитаться об удалении
$logstring = "$username $homedir $file_to_delete";
fputs ($fp, $logstring);
fclose($fp);

echo "$file_to_delete удален!";
?>
]]>
     </programlisting>
    </example>
    Однако и в этом случае имеются "дырки". Если ваша система аутентификации
    позволяет пользователям выбирать собственные имена, и пользователь
    задаст имя "../etc/", система опять попадает под атаку. В этом случае
    можно сделать более специфическую проверку:
    <example>
     <title>Еще более безопасная проверка имени файла</title>
     <programlisting role="php">
<![CDATA[
<?php
$username = $_SERVER['REMOTE_USER']; // используем механизм аутентификации
$homedir = "/home/$username";

if (!ereg('^[^./][^/]*$', $userfile))
     die('плохое имя файла'); // выход без обработки

if (!ereg('^[^./][^/]*$', $username))
     die('плохое имя пользователя'); // выход без обработки
//и т.д.
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    В зависимости от вашей операционной системы, существуют файлы, о
    безопасности которых надо позаботиться - драйверы устройств (/dev/
    или COM1), файлы конфигурации (файлы /etc/ или файлы .ini),
    известные области хранения данных (/home/, Mои документы), и т.д.
    В связи с этим, обычно проще создать политику в которой запрещено все,
    кроме того, что разрешено, как говорится, "вручную".
   </para>
  </sect1>

  <sect1 id="security.database">
   <title>Безопасность баз данных</title>

   <simpara>
    Сегодня базы данных - основная составляющая практически любых приложений,
    основанных на Web, которая дает возможность предоставления разнообразного
    динамического содержимого. Поскольку в таких базах данных может храниться
    весьма важная и секретная информация, нужно позаботиться и об их защите.
   </simpara>
   <simpara>
    Для получения или сохранения информации в базе данных, к ней нужно
    подключиться, послать запрос, обработать ответ и закрыть подключение.
    Сегодня для всего этого обычно используется структурированный язык
    запросов (Structured Query Language, SQL). Давайте посмотрим, <link 
    linkend="security.database.sql-injection">как злоумышленник может 
    поступить с SQL-запросом</link>.
   </simpara>
   <simpara>
    Как известно, PHP не может сам защитить базу данных. Следующие разделы
    являются введением в основы доступа и использования баз данных в
    скриптах на PHP.
   </simpara>
   <simpara>
    Помните простое правило: защита строится "вглубь". Чем больше мест
    вы защитите и чем больше действий предпримете для защиты базы данных,
    тем меньше вероятность успеха у злоумышленника на извлечение и 
    использование хранимой в ней секретной информации. Все опасные места
    устраняются правильной разработкой структуры базы данных и использующего
    ее приложения.
   </simpara>

   <sect2 id="security.database.design">
    <title>Планирование баз данных</title>
     <simpara>
      Первый шаг всегда - собственно создание базы данных, за исключением
      случаев использования чужих баз. Когда создается база данных, ей
      назначается владелец, который и вызвал команду создания. Обычно
      только один владелец ("суперпользователь") может делать что угодно
      с объектами внутри этой базы данных и для того, чтобы позволить
      другим пользователям использовать ее, им должны быть назначены права
      доступа.
     </simpara>
     <simpara>
      Приложения никогда не должны подключаться к базе данных в роли
      ее владельца или "суперпользователя", поскольку в этом случае
      пользователи могут произвести любые действия вроде модификации
      схемы (к примеру, удаления таблиц) или удаления всего ее содержимого.
     </simpara>
     <simpara>
      Можно создать различных пользователей баз данных для каждого необходимого
      действия приложений, очень сильно ограничивая доступ последних к объектам 
      базы данных. Требуемые права должны назначаться однократно, их
      использования в других местах приложения нужно избегать. Это значит,
      что если злоумышленник получит доступ с использованием той или иной
      учетной записи, он сможет получить лишь тот доступ, которым обладала
      использованная часть программы.
     </simpara>
     <simpara>
      В приложения лучше не вводить всю логику работы с базами данных. Это
      можно сделать и в самой базе данных с использованием флагов,
      представлений, правил и встроенных процедур. В случае развития и 
      расширения системы встроенные процедуры могут быть изменены для
      автоматической обработки новых полей, а флаги предоставят дополнительные
      возможности для отладки транзакций.
     </simpara>
   </sect2>

   <sect2 id="security.database.connection">
    <title>Подключение к базе данных</title>
    <simpara>
     Можно устанавливать подключения с помощью SSL для шифрования соединений
     клиент-сервер, что дает повышенную безопасность. А можно использовать
     ssh для шифрования сетевых соединений между клиентами и сервером
     баз данных. Любой из этих способов сильно усложняет отслеживание
     и получение информации из сетевого траффика.
    </simpara>
    <!--simpara>
     Если ваш сервер баз данных имеет встроенную поддержку SSL, лучше
     использовать <link linkend="ref.openssl">функции OpenSSL</link> для
     связи между PHP и базой данных с помощью SSL.
    </simpara-->
   </sect2>

   <sect2 id="security.database.storage">
    <title>Хранение зашифрованных данных</title>
    <simpara>
     SSL/SSH защищает данные только по пути от клиента к серверу, но не
     данные, хранимые в базе данных. SSL - лишь сетевой протокол.
    </simpara>
    <simpara>
     Когда злоумышленник получает доступ к вашей базе данных в обход 
     Web-сервера, хранимые важные данные могут быть получены и использованы,
     за исключением случая, когда информация защищена в самой базе данных.
     Шифрование - весьма хороший прием в этом случае, но такой способ
     поддерживают ныне лишь очень немногие системы управления базами данных.
    </simpara>
    <simpara>
     Самый легкий путь в этом случае - создать свою собственную систему
     шифрования, а затем использовать ее в скриптах на PHP. PHP способствует
     такому подходу благодаря наличию специфичных раширений, таких, как <link
     linkend="ref.mcrypt">Mcrypt</link> и <link linkend="ref.mhash">Mhash</link>,
     охватывающих большой ряд алгоритмов шифрования. Программа шифрует
     сохраняемые данные и расшифровывает получаемые. Для детального описания
     схем шифрования смотрите ссылки.
    </simpara>
    <simpara>
     В случае скрытых данных, где не требуется их исходный вид (к примеру,
     для отображения), можно использовать хеширование. Известным примером
     хеширования является сохранение в базе данных хеша MD5 от пароля
     вместо самого пароля. Для подробного описания смотрите
     <function>crypt</function> и <function>md5</function>.
    </simpara>
    <example>
     <title>Использование хешированных паролей</title>
     <programlisting role="php">
<![CDATA[
// сохраняем хеш от пароля
$query  = sprintf("INSERT INTO users(name,pwd) VALUES('%s','%s');",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

// проверяем корректность введенного пользователем пароля
$query = sprintf("SELECT 1 FROM users WHERE name='%s' AND pwd='%s';",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

if (pg_numrows($result) > 0) {
    echo "Добро пожаловать, $username!";
}
else {
    echo "Введен неверный пароль для $username.";
}
]]>
     </programlisting>
    </example>
   </sect2>

   <sect2 id="security.database.sql-injection">
    <title>Внедрение в SQL</title>
    <simpara>
     Многие разработчики Web-приложений считают запросы SQL не стоящими
     внимания, не зная о том, что их может использовать злоумышленник. Это
     означает, что запросы SQL могут быть использованы для обхода систем
     защиты, аутентификации и авторизации, а также иногда могут быть
     использованы для получения доступа к командам уровня операционной
     системы.
    </simpara>
    <simpara>
     Внедрение в команды SQL - техника, при которой злоумышленник создает
     или изменяет команды SQL для получения доступа к скрытым данным, для
     изменения существующих и даже для выполнения команд уровня операционной
     системы. Это достигается в том случае, если программа использует
     введенные данные в комбинации со статическими параметрами для создания
     запроса SQL. Следующие примеры, к сожалению, основаны на реально
     произошедших случаях:
    </simpara>
    <para>
     При недостаточной проверке вводимых данных и соединении с базой данных
     на правах суперпользователя злоумышленник может создать нового
     суперпользователя в базе данных.
     <example>
      <title>
       Разделение результата запроса по страницам и... создание суперпользователей
       (PostgreSQL и MySQL)
      </title>
      <programlisting role="php">
<![CDATA[
$offset = argv[0]; // внимание! нет проверки данных!
$query  = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";
// в PostgreSQL 
$result = pg_exec($conn, $query);
// в MySQL
$result = mysql_query($query);
]]>
      </programlisting>
     </example>
      Обычно пользователи используют кнопочки "следующая" и "предыдущая",
      где <varname>$offset</varname> внедрен в URL. Программа считает, что
      <varname>$offset</varname> - число. Однако, кто-нибудь может
      попытаться внедриться путем добавления <function>urlencode</function>-кодированных
      данных в URL 
      <informalexample>
       <programlisting>
<![CDATA[
// в случае PostgreSQL
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--

// в случае MySQL
0;
UPDATE user SET Password=PASSWORD('crack') WHERE user='root';
FLUSH PRIVILEGES;
]]>
       </programlisting>
      </informalexample>
      Если это случится, программа предоставит ему доступ суперпользователя.
      Заметим, что <literal>0;</literal> служит для того, чтобы задать
      корректное смещение для исходного запроса и завершить его.
    </para>
    <note>
     <para>
      Обычная практика - заставить транслятор SQL проигнорировать остаток
      запроса разработчика с помощью обозначения начала коментария SQL 
      <literal>--</literal>.
     </para>
    </note>
    <para>
     Существует путь получения паролей через ваши страницы поиска. Все, что
     нужно злоумышленнику - это одна не обработанная должным образом
     переменная, используемая в SQL-запросе. Использоваться могут команды
     <literal>WHERE, ORDER BY, LIMIT</literal> и <literal>OFFSET</literal>
     запроса <literal>SELECT</literal>.
     Если ваша база данных поддерживает конструкцию <literal>UNION</literal>,
     злоумышленник может добавить к исходному запросу еще один - для получения
     паролей. В этом случае поможет хранение зашифрованных паролей.
     <example>
      <title>
       Вывод статей... и паролей (любой сервер баз данных)
      </title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT id, name, inserted, size FROM products
                  WHERE size = '$size'
                  ORDER BY $order LIMIT $limit, $offset;";
$result = odbc_exec($conn, $query);
]]>
      </programlisting>
     </example>
     Статическая часть запроса может быть совмещена с другим запросом
     <literal>SELECT</literal>, который выведет все пароли:
     <informalexample>
      <programlisting>
<![CDATA[
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
]]>
      </programlisting>
     </informalexample>
     Если подобный запрос (использующий <literal>'</literal> и
     <literal>--</literal>) будет задан в одной из переменных, используемых
     <varname>$query</varname>, то атака будет успешной.
    </para>
    <para>
     Запросы SQL "UPDATE" также могут быть использованы для атаки на базу
     данных. Эти запросы также подвержены опасности "обрезки" и добавления
     новых запросов. Но здесь злоумышленник работает с командой
     <literal>SET</literal>. В этом случае необходимо знание некоторой
     информации о структуре базы данных для удачной модификации запроса.
     Такая информация может быть получена путем изучения названий переменных
     форм или просто подбором. В конце концов, не так уж и много имен придумано
     для полей пользователей и паролей.
     <example>
     <title>
      От сброса пароля до получения привилегий... (любой сервер баз данных)
     </title>
      <programlisting role="php">
<![CDATA[
$query = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
]]>
      </programlisting>
     </example>
     Злоумышленник посылает значение <literal>' or uid like'%admin%'; --</literal>,
     в переменную <varname>$uid</varname> для изменения пароля администратора
     или просто устанавливает <varname>$pwd</varname> в
     <literal>"hehehe', admin='yes', trusted=100 "</literal> (с завершающим
     пробелом) для получения прав. Запрос будет искажен так:
     <informalexample>
      <programlisting role="php">
<![CDATA[
// $uid == ' or uid like'%admin%'; --
$query = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%'; --";

// $pwd == "hehehe', admin='yes', trusted=100 "
$query = "UPDATE usertable SET pwd='hehehe', admin='yes', trusted=100 WHERE ...;"
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     А вот пугающий пример того, как на некоторых серверах баз данных
     могут быть выполнены команды уровня операционной системы:
     <example>
     <title>Атака на операционную систему сервера баз данных (сервер MSSQL)</title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products WHERE id LIKE '%$prod%'";
$result = mssql_query($query);
]]>
      </programlisting>
     </example>
     Если злоумышленник пошлет значение
     <literal>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</literal>
     в <varname>$prod</varname>, то <varname>$query</varname> будет выглядеть
     так:
     <informalexample>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products
                    WHERE id LIKE '%a%'
                    exec master..xp_cmdshell 'net user test testpass /ADD'--";
$result = mssql_query($query);
]]>
      </programlisting>
     </informalexample>
     Сервер MSSQL выполняет все команды SQL, включая команду добавления
     нового пользователя в локальную базу данных пользователей. Если
     это приложение было запущено, как <literal>sa</literal> и служба
     MSSQLSERVER имеет достаточно прав, злоумышленник будет иметь учетную
     запись для доступа к этой машине.
    </para>
    <note>
     <para>
      Некоторые из вышеперечисленных примеров привязаны к конкретному
      серверу баз данных. Но это вовсе не означает, что подобная атака
      невозможна на другое программное обеспечение. Ваш сервер баз данных тоже 
      так или иначе будет уязвим для непредвиденных атак.
     </para>
    </note>

    <sect3 id="security.database.avoiding">
     <title>Техника защиты</title>
     <simpara>
      В большинстве примеров видно, что для атаки злоумышленник должен 
      обладать некоторой информацией. Все верно, но никогда заранее не
      известно, какими путями уйдет данная информация. Если это все-таки
      случится, база данных становится незащищенной. Если вы используете
      свободно распространяемый пакет управления базами данных, который
      принадлежит какой-нибудь системе управления содержимым или форуму,
      злоумышленник легко получит копию данной части вашей программы.
      Это также может представлять "дыру" в безопасности.
     </simpara>
     <simpara>
      Большинство атак построены на использовании кода, который писался без
      учета соображений безопасности. Никогда не доверяйте введенным данным,
      особенно если они идут с клиентской стороны, пусть даже и из поля
      отметки, скрытого поля или записи cookie. Первый пример показывает,
      к чему может привести подмена этих данных.
     </simpara>

     <itemizedlist>
      <listitem>
       <simpara>
        Никогда не соединяйтесь с базой данных в роли суперпользователя или
        владельца. Всегда используйте специальных пользователей с минимумом
        прав.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Проверяйте ввод на совпадение типа данных с требуемым. PHP включает
        в себя большое количество проверочных функций, от самых простейших
        из разделов "<link linkend="ref.variables">Функции для работы с 
        переменными</link>" и "<link linkend="ref.ctype">Функции обработки
        символьного типа</link>", (к примеру <function>is_numeric</function> и 
        <function>ctype_digit</function> соответственно) до регулярных 
        выражений Perl ("<link linkend="ref.pcre">Регулярные выражения, 
        совместимые с Perl</link>").
       </simpara>
      </listitem>
      <listitem>
       <para>
        Если программа ожидает число, проверяйте данные с помощью
        <function>is_numeric</function>, или просто изменяйте тип с помощью
        <function>settype</function>, или даже используйте численное
        представление, выданное <function>sprintf</function>.
        <example>
         <title>Более безопасная разбивка на страницы</title>
         <programlisting role="php">
<![CDATA[
settype($offset, 'integer');
$query = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";

// отметим %d в строке форматирования, использование %s бесполезно
$query = sprintf("SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET %d;",
                 $offset);
]]>
         </programlisting>
        </example>
       </para>
      </listitem>
      <listitem>
       <simpara>
        Предваряйте любой нечисловой ввод, передаваемый в базу данных,
        функциями <function>addslashes</function> или 
        <function>addcslashes</function>. В 
        <link linkend="security.database.storage">первом примере</link>
        показано, что кавычек в статической части запроса недостаточно.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Не выводите никакой информации о структуре базы данных ни коим
        образом. Для описания подробностей смотрите раздел "<link
        linkend="security.errors">Отчеты об ошибках</link>" и "<link
        linkend="ref.errorfunc">Функции обработки и учета ошибок</link>".
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Можно использовать хранимые процедуры и заданные расположения для того,
        чтобы отвязать обращение к данным от программы так, чтобы пользователи
        не имели прямого доступа к таблицам и представлениям, но этот вариант
        имеет собственные проблемы.
       </simpara>
      </listitem>
     </itemizedlist>

     <simpara>
      Кроме того, ведите журнал операций в программе или собственно в базе
      данных, если это поддерживается. Ведение журнала не предотвратит
      внедрения, но оно поможет определить, какая часть программы была
      поставлена под удар. Сам журнал бесполезен - полезна хранимая в нем
      информация. Чем ее больше - тем лучше.
     </simpara>
    </sect3>
   </sect2>
  </sect1>

  <sect1 id="security.errors">
   <title>Отчеты об ошибках</title>
   <para>
    В случае настройки безопасности PHP у отчета об ошибках есть две
    стороны. Одна - плюс в сторону безопасности, другая - наоборот.
   </para>
   <para>
    Стандартная техника атаки включает в себя тестирование системы
    путем указания заведомо неверных данных и получения деталей
    всех возвращенных ошибок. Это позволяет взломщику получить информацию
    о сервере, о возможных слабостях системы защиты. К примеру, если
    злоумышленнику доступна информация о странице, использующей предварительный
    ввод данных в форму, то он может попытаться изменить передаваемые 
    переменные:
    <example>
     <title>Атака на переменные с помощью собственной страницы HTML</title>
     <programlisting role="php">
<![CDATA[
<form method="post" action="attacktarget?username=badfoo&password=badfoo">
<input type="hidden" name="username" value="badfoo">
<input type="hidden" name="password" value="badfoo">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Ошибки, которые обычно возвращаются PHP, очень помогают в отладке программ,
    указывая на файл или функцию, а также номер строки где произошла ошибка.
    Однако, вся эта информация может быть использована. Очень часто 
    разработчики используют функции <function>show_source</function>,
    <function>highlight_string</function>
    или <function>highlight_file</function>, как отладочные, но в реальном
    случае они могут показать скрытые переменные, неотлаженные участки кода
    и другую опасную информацию. Особенно опасен запуск кода с встроенными
    отладочными частями или с использованием технологий отладки. Если
    злоумышленник определит вашу схему отладки, он может просто послать
    вашему коду отладочные команды для произведения своих действий.
    <example>
     <title>Использование отладочных переменных</title>
     <programlisting role="php">
<![CDATA[
<form method="post" action="attacktarget?errors=Y&amp;showerrors=1"&debug=1">
<input type="hidden" name="errors" value="Y">
<input type="hidden" name="showerrors" value="1">
<input type="hidden" name="debug" value="1">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Независимо от способа обработки ошибок, возможность тестирования
    системы приводит к получению взломщиком дополнительной информации.
   </para>
   <para>
    К примеру, сам стиль отображения ошибок PHP обозначает, что в системе
    запущен PHP. Если злоумышленник, видящий .html страницу захочет проверить
    сервер на слабые места в безопасности путем ввода неверных данных, он,
    таким образом, узнает, что система построена с использованием PHP.
   </para>
   <para>
    Ошибки функций могут указать на запущенный в системе сервер баз
    данных или дать информацию о том, как написана эта Web-страница.
    Это позволяет вести дальнейшее исследование открытых мест в базе
    данных или искать ошибки и слабые места в Web-странице.
    Путем посылки различных некорректных данных злоумышленник может,
    например, узнать последовательность аутентификации (из номеров строк),
    а также может попытаться обнаружить "дыры" в различных местах
    программы.
   </para>
   <para>
    Ошибки файловой системы или общие ошибки PHP могут открыть
    заданные Web-серверу разрешения, а также структуру файлов сервера.
    Коды ошибок разработчика ухудшают ситуацию, приводя к весьма
    примитивному использованию "официально скрытой" информации.
   </para>
   <para>
    Есть три основных пути решения проблемы. Первый - отладить все
    функции и попытаться компенсировать наличие ошибок. Второй -
    полностью отключить отчет об ошибках. Третий - использовать
    собственный обработчик ошибок PHP. Выбор зависит от вашего желания и
    структуры вашей системы безопасности.
   </para>
   <para>
    Еще один способ решения проблемы "досрочно" - использование встроенной
    опции PHP <function>error_reporting</function>, для того, чтобы
    обезопасить программу и найти уязвимые переменные. Тестируя программу до
    развертывания с E_ALL можно быстро найти места, где переменные
    могут быть открыты для модификации. Как только программа готова к
    развертыванию, E_NONE предотвращает исследование.
    <example>
     <title>Нахождение небезопасных переменных с помощью E_ALL</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($username) {  // не инициализирована и не проверяется перед использованием
    $good_login = 1;
}
if ($good_login == 1) { // если предыдущий тест не прошел, значит $username не инициализирована
    fpassthru ("/highly/sensitive/data/index.html");
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="security.registerglobals">
   <title>Использование опции register-globals</title>
   <para>
    Еще одно средство PHP для повышения безопасности - конфигурация с
    использованием
    <link linkend="ini.register-globals">register_globals</link> = off.
    Это отключает внедрение пользовательских переменных в среду переменных
    программы на PHP, сводя попытки внедрения злоумышленником нужных ему
    значений на нет. Опция полностью изолирует внутренние переменные от
    предоставляемых пользователем данных.
   </para>
   <para>
    Конечно, это немного увеличивает количество усилий, необходимых для
    обработки пользовательского ввода. Но все-таки игра стоит свеч, и
    плюсы такого подхода гораздо более существенны, нежели минусы.
    <example>
     <title>Программа с register_globals=on</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($username) {  // может быть подменена пользователем в get/post/cookies
    $good_login = 1;
}

if ($good_login == 1) { // также может быть подменена пользователем в get/post/cookies
    fpassthru ("/highly/sensitive/data/index.html");
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Программа с register_globals = off</title>
     <programlisting role="php">
<![CDATA[
<?php
if($_COOKIE['username']){
    // может прийти только из записи cookie, нормальной или поддельной
    $good_login = 1;
    fpassthru ("/highly/sensitive/data/index.html");
}
?>
]]>
     </programlisting>
    </example>
    Разумно используя данный метод, можно даже принять меры предотвращения
    подмены данных, предупреждая, когда таковая предпринимается. Если
    известно, где должна быть необходимая переменная, можно проверить, не
    идет ли она от недопустимого источника. Это не гарантирует отсутствие
    подмены данных, но злоумышленнику придется искать правильный путь подмены.
    <example>
     <title>Простейшая проверка на подмену данных</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($_COOKIE['username'] &&
    !$_POST['username'] &&
    !$_GET['username'] ) {
    // произвести проверку имени пользователя
    $good_login = 1;
    fpassthru ("/highly/sensitive/data/index.html");
} else {
   mail("admin@example.com", "Возможна подмена данных ", $_SERVER['REMOTE_ADDR']);
   echo "Ошибка безопасности. Произведено оповещение администратора.";
   exit;
}
?>
]]>
     </programlisting>
    </example>
    Конечно, выключение register_globals не означает, что программа
    безопасна. Все входные данные все равно требуют дополнительной проверки.
   </para>
  </sect1>


  <sect1 id="security.variables">
   <title>Данные, отправленные пользователем</title>
   <para>
    Самые слабые места в большинстве программ на PHP не являются следствием
    проблем самого языка, напротив, они являются следствием написания этих
    программ без учета соображений безопасности. Поэтому вы всегда должны
    тратить некоторое время на продумывание ограничений тех или иных
    участков кода для снижения риска от некорректно заданных переменных.
    <example>
     <title>Небезопасное использование переменной</title>
     <programlisting role="php">
<![CDATA[
<?php
// удаление файла из пользовательского домашнего каталога... или из чьего-то еще?
unlink ($evil_var);

// запись журнала доступа... или запись в /etc/passwd?
fputs ($fp, $evil_var);

// исполнение чего-нибудь простенького.. или rm -rf *?
system ($evil_var);
exec ($evil_var);

?>
]]>
     </programlisting>
    </example>
    Всегда нужно аккуратно исследовать программу, чтобы убедиться, что
    все переменные, передаваемые пользователем, проверяются. Можно даже
    задавать себе следующие вопросы:
    <itemizedlist>
     <listitem>
      <simpara>
       Будет ли эта программа использовать именно необходимые файлы?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Могут ли быть обработаны необычные или нежелательные данные?
      </simpara>
     </listitem>
     <listitem>
     <simpara>
       Может ли эта программа использоваться нежелательным образом?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Может ли она использоваться в совокупности с другими программами для
       реализации злого умысла?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Будут ли должным образом записаны в журнал операции?
      </simpara>
     </listitem>
    </itemizedlist>
    Задавая себе эти вопросы во время написания программы, можно
    предотвратить переписывание ее "с нуля" в связи с проблемами
    безопасности. Переняв подобный образ мышления, вы не гарантируете
    безопасности системы, но увеличите эту безопасность.
   </para>
   <para>
    Также следует подумать об отключении register_globals,
    magic_quotes, и других опций, которые ставят под сомнение корректность,
    источник и значения отдельно взятых переменных. Работа в режиме отображения
    всех ошибок (error_reporting=E_ALL) также предупредит об использовании
    переменных без предварительной проверки и инициализации.
   </para>
  </sect1>

  <sect1 id="security.hiding">
   <title>Скрытие PHP</title>
   <para>
    В общем случае, скрытие - самая слабая форма системы безопасности. Но в
    некоторых случаях необходима любая малость.
   </para>
   <para>
    Есть несколько приемов, позволяющих скрыть PHP, что замедлит действия
    злоумышленника, пытающегося обнаружить слабости в вашей системе.
    Установка в файле &php.ini; опции expose_php = off уменьшит количество
    доступной информации.
   </para>
   <para>
    Другая тактика - настройка сервера Web (вроде Apache) для обработки
    различных типов файлов с помощью PHP. Это делается через директивы
    .htaccess или через файл конфигурации Apache. Затем можно использовать
    "отвлекающие" расширения файлов:
    <example>
     <title>Скрытие PHP под видом другого языка</title>
     <programlisting role="apache-conf">
<![CDATA[
# Делаем код PHP похожим на код других языков
AddType application/x-httpd-php .asp .py .pl
]]>
     </programlisting>
    </example>
    Или вносим путаницу:
    <example>
     <title>Использование неизвестных расширений для PHP</title>
     <programlisting role="apache-conf">
<![CDATA[
# Делаем PHP ни на что не похожим
AddType application/x-httpd-php .bop .foo .133t
]]>
     </programlisting>
    </example>
    Или даже можно скрыть PHP под видом html, что приведет к небольшой
    потере производительности, поскольку все .html-файлы будут обрабатываться
    интерпретатором PHP.
    <example>
     <title>Использование расширений html для PHP</title>
     <programlisting role="apache-conf">
<![CDATA[
# Делаем PHP похожим на html
AddType application/x-httpd-php .htm .html
]]>
     </programlisting>
    </example>
    Чтобы все это работало, надо переименовать файлы PHP в файлы с
    вышеперечисленными расширениями. Хотя это и подвид безопасности через
    скрытие, это одна из мер предотвращения атак с минимумом известных минусов.
   </para>
  </sect1>

  <sect1 id="security.current">
   <title>В ногу со временем</title>
   <simpara>
    PHP, как и любая другая большая система, постоянно изменяется и
    дорабатывается. Каждая новая версия обычно включает как серьезные,
    так и небольшие изменения для устранения проблем безопасности,
    конфигурации, а также всего, что влияет на общую безопасность и
    стабильность системы.
   </simpara>
   <simpara>
    Как и в случае с другими программами, лучший вариант - это выполнять
    обновление как можно чаще, а также следить за последними версиями
    и сделанными в них изменениями.
   </simpara>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
