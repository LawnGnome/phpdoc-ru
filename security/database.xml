<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.8 $ -->
<!-- EN-Revision: 1.4 Maintainer: young Status: ready -->
<!-- splitted from ./index.xml, last change in rev 1.66 -->
  <chapter xml:id="security.database" xmlns="http://docbook.org/ns/docbook">
   <title>Безопасность баз данных</title>
   <simpara>
    На сегодняшний день базы данных являются ключевыми компонентами  большинства
    веб-приложений, позволяя предоставлять на сайтах динамический контент. Поскольку
    в таких БД может храниться очень точная или конфиденциальная информация,
    вы должны обеспечить хорошую защиту данных.
   </simpara>
   <simpara>
    Для извлечения или сохранения любых данных вам необходимо открыть 
    соединение с базой данных, отправить верный запрос, извлечь результат и 
    закрыть соединение. В настоящее время наиболее распространенный стандарт общения -
    структурированный язык запросов (SQL). Всегда следует помнить о возможности
    атаки  <link linkend="security.database.sql-injection">посредством SQL-запроса</link>.
   </simpara>
   <simpara>
    Очевидно, что сам по себе PHP не может защитить вашу базу данных. Этот раздел
    документации рассказывает об основах безопасного доступа и управления данными
    в PHP-скриптах.
   </simpara>
   <simpara>
    Запомните простое правило: максимальная защита. Чем 
    больше потенциально опасных участков системы вы проработаете, 
    тем сложнее будет потенциальному взломщику получить доступ к базе данных или
    повредить ее. Хороший дизайн базы данных и программных приложений
    поможет вам справиться с вашими страхами.
   </simpara>

   <sect1 xml:id="security.database.design">
    <title>Проектирование базы данных</title>
     <simpara>
      Первый шаг - это всегда создание БД, исключая тот случай, когда вы хотите
      использовать готовую базу, предоставляемую третьим лицом.
      После того, как база данных создана, она назначается пользователю, который
      выполнил создавший БД запрос.
      Как правило, только владелец (или суперпользователь) может выполнять различные
      действия с различными объектами, хранимыми в базе данных. Для того,
      чтобы и другие пользователи имели к ней доступ, их необходимо наделить
      соответствующими привелегиями.
     </simpara>
     <simpara>
      Приложения не должны соединяться с базой данных, используя учетную запись
      владельца или суперпользователя, иначе они смогут модифицировать структуру
      таблиц (например, удалить некоторые таблицы) или даже удалить
      все содержимое БД целиком.
     </simpara>
     <simpara>
      Вы можете создать различные учетные записи пользователей БД для 
      каждой индивидуальной потребности приложения с соответствующими 
      функциональными ограничениями. Рекомендуется назначать только самые 
      необходимые привилегии, также вы должны избегать ситуаций, когда один
      и тот же пользователь может взаимодействовать с базой данных в нескольких
      режимах. Вы должны понимать, что если злоумышленник сможет воспользоваться
      какой-либо учетной записью вашей БД, он сможет вносить в базу все те изменения, 
      что и программа, которая использует текущую учетную запись.
     </simpara>
     <simpara>
      Вам не обязательно реализовывать всю бизнес-логику в веб-приложении
      (т.е. в скриптах), для этого также можно использовать возможности,
      предоставляемые базой данных:  триггеры, представления, правила.
      В случае роста системы вам понадобятся новые соединения с БД, 
      и логику работы понадобиться дублировать для каждого нового интерфейса доступа.
      Исходя из вышесказанного, триггеры могут использоваться для прозрачной и автоматической обработки 
      записей, что часто необходимо при отладке приложений или при трассировке отката транзакций.
     </simpara>
   </sect1>

   <sect1 xml:id="security.database.connection">
    <title>Соединение с базой данных</title>
    <simpara>
     Вы можете использовать безопасные SSL или ssh соединения, для шифрования данных,
     которыми обмениваются клиент и сервер. Если вы реализуете что-нибудь из этого, то мониторинг 
     трафика и сбор данных о вашей базе данных для потенциального взломщика
     существенно усложнится.
    </simpara>
    <!--simpara>
     If your database server has native SSL support, consider using <link
     linkend="ref.openssl">OpenSSL functions</link> in communication between
     PHP and database via SSL.
    </simpara-->
   </sect1>

   <sect1 xml:id="security.database.storage">
    <title>Защита хранилища базы данных</title>
    <simpara>
     SSL/SSH защищает данные, которыми обмениваются клиент и сервер, но
     не защищают сами данные, хранимые в базе данных. 
     SSL - протокол шифрования на уровне сеанса передачи данных.
    </simpara>
    <simpara>
     В случае, если взломщик получил непосредственный доступ к БД (в обход веб-сервера),
     он может извлечь интересующие данные или нарушить их целостность, поскольку
     информация не защищена на уровне самой БД. Шифрование данных -
     хороший способ предотвратить такую ситуацию, но лишь незначительное количество БД
     предоставляют такую возможность.
    </simpara>
    <simpara>
     Наиболее простое решение этой проблемы - установить вначале обыкновенный
     программный пакет для шифрования данных, а затем использовать его в ваших
     скриптах. PHP, в таком случае, может помочь вам в работе с такими расширениями
     как  <link linkend="ref.mcrypt">Mcrypt</link> и <link
     linkend="ref.mhash">Mhash</link>, реализующими различные алгоритмы криптования.
     При таком подходе скрипт вначале шифрует сохраняемые данные, а затем дешифрует их при запросе.
     Ниже приведены примеры того, как работает шифрование данных в PHP-скриптах.
    </simpara>
    <simpara>
     В случае работы со скрытыми служебными данными их нешифрованное представление
     не требуется (т.е. не отображается), и, как следствие, можно использовать
     хеширование.  Хорошо известный пример хэширования - хранение 
     MD5-хеша от пароля в БД, вместо хранения оригинального значения.
     Более детальная информация доступна в описании функций
     <function>crypt</function> and <function>md5</function>.
    </simpara>
    <example>
     <title>Использование хешированных паролей</title>
     <programlisting role="php">
<![CDATA[
<?php
// сохранение хешированного пароля
$query  = sprintf("INSERT INTO users(name,pwd) VALUES('%s','%s');",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

// проверка введенного пользователем логина и пароля на корректность
$query = sprintf("SELECT 1 FROM users WHERE name='%s' AND pwd='%s';",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

if (pg_numrows($result) > 0) {
    echo "Welcome, $username!";
}
else {
    echo "Authentication failed for $username.";
}
?>
]]>
     </programlisting>
    </example>
   </sect1>

   <sect1 xml:id="security.database.sql-injection">
    <title>SQL-инъекции</title>
    <simpara>
     Многие веб-разработчики даже не догадываются, что SQL-запросы
     могут быть подделаны, и считают, что SQL-запросы всегда достоверны.
     На самом деле поддельные запросы могут обойти ограничения доступа,
     стандартную проверку авторизации, а некоторые виды запросов могут
     дать возможность выполнять команды операционной системы.
    </simpara>
    <simpara>
     Принудительное внедрение вредоносных инструкций в SQL-запросы - методика, в которой взломщик создает или
     изменяет текущие SQL-запросы для работы со скрытыми данными, их изменения
     или даже выполнения опасных команд операционной системы на сервере базы данных.
     Атака выполняется на базе приложения, строящего SQL-запросы из пользовательского
     ввода и статических переменных. Следующие примеры, к сожалению, построены на 
     реальных фактах.
    </simpara>
    <para>
     Благодаря отсутствию проверки пользовательского ввода и соединением с базой
     данных под учетной записью суперпользователя (или любого другого пользователя, 
     наделенного соответствующими привелегиями), взломщик может создать еще
     одного пользователя БД с правами суперпользователя.
     <example>
      <title>
       Постраничный вывод результата... и создание суперпользователя в PostgreSQL и MySQL
      </title>
      <programlisting role="php">
<![CDATA[
<?php
$offset = argv[0]; // проверка пользовательских данных отсутствует
$query  = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";
// используя PostgreSQL 
$result = pg_exec($conn, $query);
// используя MySQL
$result = mysql_query($query);
?>
]]>
      </programlisting>
     </example>
      Обычно пользователи кликают по ссылкам 'вперед' и 'назад', вследствии чего значение
      переменной <varname>$offset</varname> заносится в адресную строку.
      Скрипт ожидает, что <varname>$offset</varname> - десятиричное число.
      Однако, взломщик может попытаться взломать систему, присоединив к строке
      запроса дополнительную подстроку, обработанную функцией <function>urlencode</function>:
      <informalexample>
       <programlisting role="sql">
<![CDATA[
// используя PostgreSQL 
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--

// используя MySQL
0;
UPDATE user SET Password=PASSWORD('crack') WHERE user='root';
FLUSH PRIVILEGES;
]]>
       </programlisting>
      </informalexample>
      Если это произойдет, скрипт предоставит взломщику доступ к базе
      с правами суперпользователя. Заметим, что <literal>0;</literal> использован
      для того, чтобы задать правильное значение смещения для первого запроса и 
      корректно его завершить.
    </para>
    <note>
     <para>
      Уже привычна технология, когда разработчики указывают принудительное 
      игнорирование парсером SQL оставшейся части запроса при помощи нотации
	<literal>--</literal>, означающей комментарий.
     </para>
    </note>
    <para>
     Еще один вероятный способ получить пароли учетных записей в БД - атака страниц,
     предоставляющих поиск по базе. Взломщику нужно лишь проверить, используется
     ли в запросе передаваемая на сервер и необрабатываемая надлежащим образом переменная.
     Это может быть один из устанавливаемых на предыдущей странице фильтров,
     таких как <literal>WHERE, ORDER BY, LIMIT</literal> и <literal>OFFSET</literal>,
     используемых при построении запросов <literal>SELECT</literal>.
     
     В случае, если используемая вами база данных поддерживает
     конструкцию <literal>UNION</literal>, взломщик может присоединить
     к оригинальному запросу еще один дополнительный, для извлечения пользовательских
     паролей. Настоятельно рекомендуем использовать только зашифрованные 
     пароли.
     <example>
      <title>
      Листинг статей... и некоторых паролей (для любой базы данных)
      </title>
      <programlisting role="php">
<![CDATA[
<?php
$query  = "SELECT id, name, inserted, size FROM products
                  WHERE size = '$size'
                  ORDER BY $order LIMIT $limit, $offset;";
$result = odbc_exec($conn, $query);
?>
]]>
      </programlisting>
     </example>
     Статическая часть запроса может  комбинироваться с другим SQL-запросом,
     который откроет все пароли:
     <informalexample>
      <programlisting role="sql">
<![CDATA[
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
]]>
      </programlisting>
     </informalexample>
     Если этот запрос (использующий <literal>'</literal> и
     <literal>--</literal>) присоединить к значению одной из переменных,
     используемых для формирования <varname>$query</varname>,
     запрос заметно преобразится.
    </para>
    <para>
     Команды UPDATE также могут использоваться для атаки. Опять же, есть угроза разделения
     инструкции на несколько запросов, присоединения дополнительного запроса.
     Также взломщик может видоизменить выражение <literal>SET</literal>.
     В этом случае потенциальному взломщику необходимо обладать некоторой дополнительной
     информацией для успешного манипулирования запросами. Эту информацию можно
     получить, проанализировав используемые в форме имена переменных либо просто перебирая все
     наиболее распространенные варианты  названия соответствующих полей (а их не так уж и много).
     <example>
     <title>
      От восстановления пароля... до получения дополнительных привилегий (для любой базы данных)
     </title>
      <programlisting role="php">
<![CDATA[
<?php
$query = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
?>
]]>
      </programlisting>
     </example>
     Но злоумышленник может ввести значение
     <literal>' or uid like'%admin%'; --</literal> для переменной <varname>$uid</varname> для
     изменения пароля администратора или просто присвоить переменной <varname>$pwd</varname> значение
     <literal>"hehehe', admin='yes', trusted=100 "</literal> (с завершающими пробелами)
     для получения дополнительных привелегий. При выполнении запросы переплетаются:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// $uid == ' or uid like'%admin%'; --
$query = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%'; --";

// $pwd == "hehehe', admin='yes', trusted=100 "
$query = "UPDATE usertable SET pwd='hehehe', admin='yes', trusted=100 WHERE ...;";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Пугающий пример того, как на сервере баз данных могут выполняться команды 
     операционной системы.
     <example>
     <title>Выполнение команд операционной системы на сервере (для базы MSSQL)</title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products WHERE id LIKE '%$prod%'";
$result = mssql_query($query);
]]>
      </programlisting>
     </example>
     Если взломщик введет значениме
     <literal>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</literal>
     для переменной <varname>$prod</varname>, тогда запрос <varname>$query</varname> 
     будет выглядеть так:
     <informalexample>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products
                    WHERE id LIKE '%a%'
                    exec master..xp_cmdshell 'net user test testpass /ADD'--";
$result = mssql_query($query);
]]>
      </programlisting>
     </informalexample>
     MSSQL сервер выполняет SQL-команды в пакетном режиме, в том числе 
     и операции по заведению локальных учетных записей базы данных. В случае,
     если приложение работает с привилегиями администратора и сервис MSSQL
     запущен с необходимыми привилегиями, выполнив приведенные выше действия,
     взломщик получит аккаунт для доступа к серверу.
    </para>
    <note>
     <para>
      Некоторые приведенные в этой главе примеры касаются конкретной базы данных.
      Это не означает, что аналогичные атаки на другие программные продукты невозможны.
      Работоспособность вашей базы данных может быть нарушена каким-либо другим способом.
     </para>
    </note>

    <sect2 xml:id="security.database.avoiding">
     <title>Способы защиты</title>
     <simpara>
      Вы можете утешать себя тем, что в большинстве случаев, взломщик должен
      обладать некоторой информацией о структуре базы данных. Вы правы, 
      но вы не знаете, когда и как будет предпринята попытка взлома, в случае
      если это произойдет ваша БД окажется незащищенной. Если вы используете
      программный продукт с открытыми исходными кодами или просто общедоступный
      пакет для работы с базой данных (например контент менеджер или форум), взломщик
      легко сможет воспроизвести интересующие его участки кода. В случае
      если они плохо спроектированы, это может являться одной из угроз вашей безопасности.
     </simpara>
     <simpara>
      Большинство успешных атак основывается на коде, написанном без учета соответствующих
      требований безопасности. Не доверяйте никаким вводим данным, особенно если
      они поступают со стороны клиента, даже если это списки в форме, скрытые поля или куки.
      Приведенные примеры показывают, к каким последствиям могут привести подделанные запросы.
     </simpara>

     <itemizedlist>
      <listitem>
       <simpara>
        Старайтесь не открывать соединение с базой, используя учетную запись 
        владельца или администратора. Всегда старайтесь использовать специально созданных
        пользователей с максимально ограниченными правами.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Всегда проверяйте введенные данные на соответствие ожидаемому типу.
        В PHP есть множество функций для проверки данных: начиная от простейших
        <link linkend="ref.var">Функций для работы с переменными</link> и
        <link linkend="ref.ctype">Функции определения типа символов</link>
        (такие как <function>is_numeric</function>, <function>ctype_digit</function>)
        и заканчивая <link linkend="ref.pcre">Perl-совместимыми регулярными выражениями</link>.
       </simpara>
      </listitem>
      <listitem>
       <para>
        В случае, если приложение ожидает цифровой ввод, примените функцию
        <function>is_numeric</function> для проверки введенных данных, или
        принудительно укажите их тип при помощи <function>settype</function>, 
        или просто используйте числовое представление при помощи функции
        <function>sprintf</function>.
        <example>
         <title>Более безопасная реализация постраничной навигации</title>
         <programlisting role="php">
<![CDATA[
settype($offset, 'integer');
$query = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";

// обратите внимание на формат %d, использование %s было бы бессмысленно
$query = sprintf("SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET %d;",
                 $offset);
]]>
         </programlisting>
        </example>
       </para>
      </listitem>
      <listitem>
       <simpara>
        Экранируйте любой нецифровой ввод, используемый в запросах к БД при помощи
        функций 
        <function>addslashes</function> или <function>addcslashes</function>.
        Обратите внимание на <link linkend="security.database.storage">первый пример</link>.
        Следует помнить, что одного использования кавычек в запросе мало, это легко
        обойти.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Не выводите никакой информации о БД, особенно о ее структуре.
        Также ознакомьтесь с соответствующими разделами документации: <link
        linkend="security.errors">Сообщения об ошибках</link> и <link
        linkend="ref.errorfunc">Функции обработки и логирования ошибок</link>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Вы можете использовать хранимые процедуры и заранее определенные курсоры для
        абстрагированной работы с данными, не предоставляя пользователям 
        прямого доступа к данным и представлениям, но это решение имеет свои особенности.
       </simpara>
      </listitem>
     </itemizedlist>

     <simpara>
      Помимо всего вышесказанного, вы можете логировать запросы в вашем скрипте либо
      на уровне базы данных, если она это поддерживает. Очевидно, что логирование
      не может предотвратить нанесение ущерба, но может помочь при трассировке взломанного
      приложения. Лог-файл полезен не сам по себе, а информацией, которая в нем содержится.
      Причем, в большинстве случаев полезно логировать все возможные детали.
     </simpara>
    </sect2>
   </sect1>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
