<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1.14 Maintainer: freespace Status: ready -->
<!-- $Revision: 1.6 $ -->
<appendix xml:id="filters" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Список доступных фильтров</title>
 <para>
  Следующий список перечисляет несколько встроенных фильтров для использования
  с <function>stream_filter_append</function>.
  Ваша версия PHP может включать больше (или меньше) фильтров, чем перечислено
  здесь.
 </para>

 <para>
  Следует акцентировать внимание на определённой асимметричности функций
  <function>stream_filter_append</function> и 
  <function>stream_filter_prepend</function>.  
  Каждый поток в PHP имеет небольшой <emphasis>буфер чтения</emphasis>,
  в котором он хранит блоки данных, полученные из файловой системы или
  другого ресурса, для того чтобы обрабатывать данные наиболее эффективным
  образом. Как только данные переносятся из ресурса во внутренний буфер
  потока, они сразу же обрабатываются закреплёнными за потоком фильтрами,
  независимо от того, готово ли приложение PHP принимать данные или нет.
  Если данные находятся в буфере чтения в момент, когда в фильтр
  что-то <emphasis>дописывают в конец</emphasis>, данные будут немедленно
  обработаны этим фильтром, таким образом их нахождение в буфере
  будет прозрачным. В то же время, если данные находятся в буфере в
  момент, когда в фильтр что-то <emphasis>дописывают в начало</emphasis>,
  данные <emphasis>НЕ</emphasis> будут обработаны этим фильтром.
  Вместо этого, они будут ждать момента, когда следующий блок данных будет
  получен из ресурса.
 </para>

 <para>
  Для получения списка фильтров, установленных в вашу версию PHP,
  используйте функцию <function>stream_get_filters</function>.
 </para>

 <section xml:id="filters.string">
  <title>Строковые фильтры</title>

  <simpara>
   Все эти фильтры служат для того самого, что подразумевают их
   имена в соответсвии с поведением встроенных в PHP функций для
   работы со строками.
   Для получения дополнительной информации о конкретном фильтре,
   обратитесь к странице руководства соответствующей функции.
  </simpara>

  <simpara>
   <literal>string.rot13</literal>
   (с версии PHP 4.3.0)
   Использование этого фильтра эквивалентно обработке всех данных потока
   функцией <function>str_rot13</function>.
  </simpara>
  <example>
   <title>string.rot13</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.rot13');
fwrite($fp, "This is a test.\n");
/* Outputs:  Guvf vf n grfg.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.toupper</literal>
   (с версии PHP 5.0.0)
   Использование этого фильтра эквивалентно обработке всех данных потока
   функцией <function>strtoupper</function>.
  </simpara>
  <example>
   <title>string.toupper</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.toupper');
fwrite($fp, "This is a test.\n");
/* Outputs:  THIS IS A TEST.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.tolower</literal>
   (с версии PHP 5.0.0)
   Использование этого фильтра эквивалентно обработке всех данных потока
   функцией <function>strtolower</function>.
  </simpara>
  <example>
   <title>string.tolower</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.tolower');
fwrite($fp, "This is a test.\n");
/* Outputs:  this is a test.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.strip_tags</literal>
   (с версии PHP 5.0.0)
   Использование этого фильтра эквивалентно обработке всех данных потока
   функцией <function>strip_tags</function>.
   Он принимает аргументы в одной из двух форм:
   Либо в виде строки со списком тегов, как и второй аргумент функции
   <function>strip_tags</function>, либо массив названий тегов.
  </simpara>
  <example>
   <title>string.strip_tags</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, "<b><i><u>");
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, array('b','i','u'));
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */
?>
]]>
   </programlisting>
  </example>
   
 </section>

 <section xml:id="filters.convert">
  <title>Преобразовывающие фильтры</title>

  <simpara>
   Как и фильтры string.*, фильтры convert.* совершают действия,
   соответствующие их именам. Преобразовывающие фильтры были добавлены
   в PHP 5.0.0.
   Для получения дополнительной информации о конкретном фильтре,
   обратитесь к странице руководства соответствующей функции.
  </simpara>

  <simpara>
   <literal>convert.base64-encode</literal> и
   <literal>convert.base64-decode</literal>
   Использование этих фильтров эквивалентно обработке всех данных потока
   функциями <function>base64_encode</function> и
   <function>base64_decode</function> соответственно.
   <literal>convert.base64-encode</literal> поддерживает аргументы, переданные
   в виде ассоциативного массива. Если указан аргумент
   <parameter>line-length</parameter>, результат base64 будет разделён на
   куски длинной <parameter>line-length</parameter> символов каждый.
   Если указан аргумент <parameter>line-break-chars</parameter>,
   каждый кусок будет разделён указанными символами. Эти параметры дают
   такой же эффект, как и использование <function>base64_encode</function>
   в паре с <function>chunk_split</function>.
  </simpara>
  <example>
   <title>convert.base64-encode и convert.base64-decode</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode');
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBpcyBhIHRlc3QuCg==  */

$param = array('line-length' => 8, 'line-break-chars' => "\r\n");
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode', STREAM_FILTER_WRITE, $param);
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBp
          :  cyBhIHRl
          :  c3QuCg==  */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-decode');
fwrite($fp, "VGhpcyBpcyBhIHRlc3QuCg==");
fclose($fp);
/* Outputs:  This is a test.  */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>convert.quoted-printable-encode</literal> и
   <literal>convert.quoted-printable-decode</literal>
   Использование decode-версии этого фильтра эквивалентно обработке всех
   данных потока функцией <function>quoted_printable_decode</function>.
   У фильтра <literal>convert.quoted-printable-encode</literal> нету
   эквивалентной функции.
   <literal>convert.quoted-printable-encode</literal> поддерживает аргументы,
   переданные в виде ассоциативного массива. В дополнение к аргументам,
   поддерживаемыми <literal>convert.base64-encode</literal>,
   <literal>convert.quoted-printable-encode</literal> также поддерживает
   boolean-аргументы <parameter>binary</parameter> и
   <parameter>force-encode-first</parameter>.
   <literal>convert.base64-decode</literal> поддерживает лишь аргумент
   <parameter>line-break-chars</parameter> в качестве подсказки для
   чистки закодированных данных.
  </simpara>
  <example>
   <title>
    convert.quoted-printable-encode &amp;
    convert.quoted-printable-decode
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.quoted-printable-encode');
fwrite($fp, "This is a test.\n");
/* Outputs:  =This is a test.=0A  */
?>
]]>
   </programlisting>
  </example>
 </section>

 <section xml:id="filters.compression">
  <title>Компрессионные фильтры</title>

  <simpara>
   В то время, как <link linkend="wrappers.compression">Компрессионные
   обвёртки</link> обеспечивают способ создания gzip- и bz2-совместимых
   файлов в локальной файловой системе, они не предоставляют общих средств
   средств для компрессии в сетевых потоках, как не предоставляют и средств
   для создания потока без компрессии с последующим превращением в
   компрессируемый. Для этих целей к любым потоковым ресурсам в любое время
   могут применяться компрессионные фильтры.
  </simpara>

  <note>
   <simpara>
    Компрессионные фильтры <emphasis>не</emphasis> генерируют заголовков и
    окончаний, которые используют утилиты командной строки, такие как
    <literal>gzip</literal>. Они просто компрессируют (сжимают) и
    декомпрессируют (разжимают) порции данных в компрессируемом потоке
    данных.
   </simpara>
  </note>

  <simpara>
   <literal>zlib.deflate</literal> (компрессия) и
   <literal>zlib.inflate</literal> (декомпрессия) являются реализациями
   компрессионных методов, описаных в
   <link xlink:href="&url.rfc;1951">RFC 1951</link>.
   Фильтр <literal>deflate</literal> принимает три аргумента, переданных в
   виде ассоциативного массива.  

   <parameter>level</parameter> определяет, какой уровень компрессии
   использовать (1-9). Повышение этого значения приведёт к уменьшению
   объёмов данных за счёт увеличения времени обработки. Существуют так же два
   специальных уровня компрессии:
   0 (для отключения компрессии) и -1 (внутреннее значение по умолчанию
   библиотеки zlib -- на текущий момент равно 6).

   <parameter>window</parameter> - это логарифм размера окна диапазона сжатия,
   где база логарифма составляет 2.
   Высокие значения (вплоть до 15 -- 32768 байт) приводят к улучшению
   компрессии за счёт роста необходимой памяти, в то время как низкие значения
   (вплоть дл 9 -- 512 байт) приводят к ухудшению компрессии за счёт
   уменьшения необходимой памяти.
   Значением аргумента <parameter>window</parameter> по умолчанию на текущий
   момент является <constant>15</constant>.

   <parameter>memory</parameter> определяет масштаб резервируемой памяти.
   Допустимые значения находятся в диапазоне от 1 (минимальное резервирование)
   до 9 (максимальное резервирование). Такое резервирование памяти влияет
   только на скорость и не влияет на размер генерируемых данных..
  </simpara>

  <note>
   <simpara>
    Так как уровень компрессии является наиболее часто используемым
    аргументом, вы можете передать только его в качестве обычного целого
    числа (integer), вместо того чтобы передавать массив из одного элемента.
   </simpara>
  </note>

  <simpara>
   Компрессионные фильтры zlib.* доступны с версии PHP
   <literal>5.1.0</literal>, если включена поддержка
   <link linkend="ref.zlib">zlib</link>. Они так же доступны в качестве
   обратного порта для версий <literal>5.0.x</literal> путём установки
   пакета <link xlink:href="&url.pecl.package;zlib_filter">zlib_filter</link>
   из <link xlink:href="&url.pecl;">PECL</link>.
   Эти фильтры <emphasis>не</emphasis> доступны в PHP 4.
  </simpara>

  <example>
   <title>
    <literal>zlib.deflate</literal> и
    <literal>zlib.inflate</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$params = array('level' => 6, 'window' => 15, 'memory' => 9);

$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, $params);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";
echo "The original text was:\n";
/* Use readfile and zlib.inflate to decompress on the fly */
readfile('php://filter/zlib.inflate/resource=test.deflated');

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.
The original text was:
This is a test.
This is only a test.
This is not an important string.

 */
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>
    Упрощённое использование <literal>zlib.deflate</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
/* Here "6" indicates compression level 6 */
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, 6);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.

 */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>bzip2.compress</literal> и
   <literal>bzip2.decompress</literal>
   работают точно так же, как и фильтры zlib, онисанные выше.

   Фильтр <literal>bzip2.compress</literal> принимает два аргумента в виде
   элементов ассоциативного массива: 

   <parameter>blocks</parameter> является целочисленным (integer) значением
   в диапазоне от 1 до 9 и указывает на количество 100-килобайтовых блоков
   памяти для резервирования в качестве рабочего пространства.

   <parameter>work</parameter> - это так же целочисленное (integer) значение
   в диапазоне от 0 до 250, определяющее сколько усилий нужно потратить на
   обычный метод компрессии перед переключением на медленный, но более
   надёжный метод. Изменение этого параметра влияет только на скорость
   компрессии. Ни размер сжатого результата, ни используемый объём памяти не
   изменяются при помощи этой настройки. Значение 0 указывает библиотеке bzip
   использовать собственное внутреннее значение по умолчанию.

   Фильтр <literal>bzip2.decompress</literal> принимает всего один аргумент,
   который может быть передан либо как обычное boolean-значение, либо как
   элемент <parameter>small</parameter> ассоциативного массива.

   Когда <parameter>small</parameter> установлен в &true;, библиотека bzip
   совершит декомпрессию с минимальным расходом памяти за счёт понижения
   скорости.
  </simpara>

  <simpara>
   Компрессионные фильтры bzip2.* доступны с версии PHP
   <literal>5.1.0</literal>, если включена поддержка
   <link linkend="ref.bzip2">bz2</link>. Они так же доступны в качестве
   обратного порта для версий <literal>5.0.x</literal> путём установки
   пакета <link xlink:href="&url.pecl.package;bz2_filter">bz2_filter</link>
   из <link xlink:href="&url.pecl;">PECL</link>.
   Эти фильтры <emphasis>не</emphasis> доступны в PHP 4.
  </simpara>

  <example>
   <title>
    <literal>bzip2.compress</literal> и
    <literal>bzip2.decompress</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$param = array('blocks' => 9, 'work' => 0);

echo "The original file is " . filesize('LICENSE') . " bytes long.\n";

$fp = fopen('LICENSE.compressed', 'w');
stream_filter_append($fp, 'bzip2.compress', STREAM_FILTER_WRITE, $param);
fwrite($fp, file_get_contents('LICENSE'));
fclose($fp);

echo "The compressed file is " . filesize('LICENSE.compressed') . " bytes long.\n";

/* Generates output:

The original text is 3288 characters long.
The compressed file is 1488 bytes long.

 */
?>
]]>
   </programlisting>
  </example>
 </section>

 <section xml:id="filters.encryption">
  <title>Шифрующие фильтры</title>

  <simpara>
   <literal>mcrypt.*</literal> и <literal>mdecrypt.*</literal>
   обеспечивают симметрическое шифрование и дешифрование при помощи
   libmcrypt. Оба набора фильтров поддерживают те же алгоритмы, что и
   <link linkend="ref.mcrypt">расширение mcrypt</link> в виде
   <literal>mcrypt.ciphername</literal>, где
   <parameter>ciphername</parameter> - это название шифра, как если
   бы оно передавалось функции <function>mcrypt_module_open</function>.
   Также доступны следующие пять параметров:
  </simpara>

  <para>
   <table>
    <title>Параметры фильтра mcrypt</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>Параметр</entry>
       <entry>Обязателен?</entry>
       <entry>По умолчанию</entry>
       <entry>Пример значения</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>mode</entry>
       <entry>Нет</entry>
       <entry>cbc</entry>
       <entry>cbc, cfb, ecb, nofb, ofb, stream</entry>
      </row>
      <row>
       <entry>algorithms_dir</entry>
       <entry>Нет</entry>
       <entry>ini_get('mcrypt.algorithms_dir')</entry>
       <entry>Путь к модулям алгоритмов</entry>
      </row>
      <row>
       <entry>modes_dir</entry>
       <entry>Нет</entry>
       <entry>ini_get('mcrypt.modes_dir')</entry>
       <entry>Путь к модулям режимов</entry>
      </row>
      <row>
       <entry>iv</entry>
       <entry>Да</entry>
       <entry>N/A</entry>
       <entry>Обычно 8, 16 или 32 байта бинарных данных. Зависит от шифра</entry>
      </row>
      <row>
       <entry>key</entry>
       <entry>Да</entry>
       <entry>N/A</entry>
       <entry>Обычно 8, 16 или 32 байта бинарных данных. Зависит от шифра</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <example>
   <title>Шифрование вывода в файл используя 3DES</title>
   <programlisting role="php">
<![CDATA[
<?php
$passphrase = 'My secret';

/* Turn a human readable passphrase
 * into a reproducable iv/key pair
 */
$iv = substr(md5('iv'.$passphrase, true), 0, 8);
$key = substr(md5('pass1'.$passphrase, true) . 
               md5('pass2'.$passphrase, true), 0, 24);
$opts = array('iv'=>$iv, 'key'=>$key);

$fp = fopen('secert-file.enc', 'wb');
stream_filter_append($fp, 'mcrypt.tripledes', STREAM_FILTER_WRITE, $opts);
fwrite($fp, 'Secret secret secret data');
fclose($fp);
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Чтение зашифрованного файла</title>
   <programlisting role="php">
<![CDATA[
<?php
$passphrase = 'My secret';

/* Turn a human readable passphrase
 * into a reproducable iv/key pair
 */
$iv = substr(md5('iv'.$passphrase, true), 0, 8);
$key = substr(md5('pass1'.$passphrase, true) . 
               md5('pass2'.$passphrase, true), 0, 24);
$opts = array('iv'=>$iv, 'key'=>$key);

$fp = fopen('secert-file.enc', 'rb');
stream_filter_append($fp, 'mdecrypt.tripledes', STREAM_FILTER_WRITE, $opts);
$data = rtrim(stream_get_contents($fp));
fclose($fp);

echo $data;
?>
]]>
   </programlisting>
  </example>

 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
