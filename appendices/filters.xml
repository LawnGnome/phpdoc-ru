<?xml version="1.0" encoding="windows-1251"?>
<!-- EN-Revision: 1.13 Maintainer: freespace Status: ready -->
<!-- $Revision: 1.2 $ -->
<appendix id="filters">
 <title>Список доступных фильтров</title>
 <para>
  Следующий список перечисляет несколько встроенных фильтров для использования
  с <function>stream_filter_append</function>.
  Ваша версия PHP может включать больше (или меньше) фильтров, чем перечислено
  здесь.
 </para>

 <para>
  Следует акцентировать внимание на определённой асимметричности функций
  <function>stream_filter_append</function> и 
  <function>stream_filter_prepend</function>.  
  Каждый поток в PHP имеет небольшой <emphasis>буфер чтения</emphasis>,
  в котором он хранит блоки данных, полученные из файловой системы или
  другого ресурса, для того чтобы обрабатывать данные наиболее эффективным
  образом. Как только данные переносятся из ресурса во внутренний буфер
  потока, они сразу же обрабатываются закреплёнными за потоком фильтрами,
  независимо от того, готово ли приложение PHP принимать данные или нет.
  Если данные находятся в буфере чтения в момент, когда в фильтр
  что-то <emphasis>дописывают в конец</emphasis>, данные будут немедленно
  обработаны этим фильтром, таким образом их нахождение в буфере
  будет прозрачным. В то же время, если данные находятся в буфере в
  момент, когда в фильтр что-то <emphasis>дописывают в начало</emphasis>,
  данные <emphasis>НЕ</emphasis> будут обработаны этим фильтром.
  Вместо этого, они будут ждать момента, когда следующий блок данных будет
  получен из ресурса.
 </para>

 <para>
  Для получения списка фильтров, установленных в вашу версию PHP,
  используйте функцию <function>stream_get_filters</function>.
 </para>

 <section id="filters.string">
  <title>Строковые фильтры</title>

  <simpara>
   Все эти фильтры служат для того самого, что подразумевают их
   имена в соответсвии с поведением встроенных в PHP функций для
   работы со строками.
   Для получения дополнительной информации о конкретном фильтре,
   обратитесь к странице руководства соответствующей функции.
  </simpara>

  <simpara>
   <literal>string.rot13</literal>
   (с версии PHP 4.3.0)
   Использование этого фильтра эквивалентно обработке всех данных потока
   функцией <function>str_rot13</function>.
  </simpara>
  <example>
   <title>string.rot13</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.rot13');
fwrite($fp, "This is a test.\n");
/* Outputs:  Guvf vf n grfg.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.toupper</literal>
   (с версии PHP 5.0.0)
   Использование этого фильтра эквивалентно обработке всех данных потока
   функцией <function>strtoupper</function>.
  </simpara>
  <example>
   <title>string.toupper</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.toupper');
fwrite($fp, "This is a test.\n");
/* Outputs:  THIS IS A TEST.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.tolower</literal>
   (с версии PHP 5.0.0)
   Использование этого фильтра эквивалентно обработке всех данных потока
   функцией <function>strtolower</function>.
  </simpara>
  <example>
   <title>string.tolower</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.tolower');
fwrite($fp, "This is a test.\n");
/* Outputs:  this is a test.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.strip_tags</literal>
   (с версии PHP 5.0.0)
   Использование этого фильтра эквивалентно обработке всех данных потока
   функцией <function>strip_tags</function>.
   Он принимает аргументы в одной из двух форм:
   Либо в виде строки со списком тегов, как и второй аргумент функции
   <function>strip_tags</function>, либо массив названий тегов.
  </simpara>
  <example>
   <title>string.strip_tags</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, "<b><i><u>");
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, array('b','i','u'));
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */
?>
]]>
   </programlisting>
  </example>
   
 </section>

 <section id="filters.convert">
  <title>Преобразовывающие фильтры</title>

  <simpara>
   Как и фильтры string.*, фильтры convert.* совершают действия,
   соответствующие их именам. Преобразовывающие фильтры были добавлены
   в PHP 5.0.0.
   Для получения дополнительной информации о конкретном фильтре,
   обратитесь к странице руководства соответствующей функции.
  </simpara>

  <simpara>
   <literal>convert.base64-encode</literal> и
   <literal>convert.base64-decode</literal>
   Использование этих фильтров эквивалентно обработке всех данных потока
   функциями <function>base64_encode</function> и
   <function>base64_decode</function> соответственно.
   <literal>convert.base64-encode</literal> поддерживает аргументы, переданные
   в виде ассоциативного массива. Если указан аргумент
   <parameter>line-length</parameter>, результат base64 будет разделён на
   куски длинной <parameter>line-length</parameter> символов каждый.
   Если указан аргумент <parameter>line-break-chars</parameter>,
   каждый кусок будет разделён указанными символами. Эти параметры дают
   такой же эффект, как и использование <function>base64_encode</function>
   в паре с <function>chunk_split</function>.
  </simpara>
  <example>
   <title>convert.base64-encode и convert.base64-decode</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode');
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBpcyBhIHRlc3QuCg==  */

$param = array('line-length' => 8, 'line-break-chars' => "\r\n");
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode', STREAM_FILTER_WRITE, $param);
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBp
          :  cyBhIHRl
          :  c3QuCg==  */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-decode');
fwrite($fp, "VGhpcyBpcyBhIHRlc3QuCg==");
fclose($fp);
/* Outputs:  This is a test.  */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>convert.quoted-printable-encode</literal> и
   <literal>convert.quoted-printable-decode</literal>
   Использование decode-версии этого фильтра эквивалентно обработке всех
   данных потока функцией <function>quoted_printable_decode</function>.
   У фильтра <literal>convert.quoted-printable-encode</literal> нету
   эквивалентной функции.
   <literal>convert.quoted-printable-encode</literal> поддерживает аргументы,
   переданные в виде ассоциативного массива. В дополнение к аргументам,
   поддерживаемыми <literal>convert.base64-encode</literal>,
   <literal>convert.quoted-printable-encode</literal> также поддерживает
   boolean-аргументы <parameter>binary</parameter> и
   <parameter>force-encode-first</parameter>.
   <literal>convert.base64-decode</literal> поддерживает лишь аргумент
   <parameter>line-break-chars</parameter> в качестве подсказки для
   чистки закодированных данных.
  </simpara>
  <example>
   <title>
    convert.quoted-printable-encode &amp;
    convert.quoted-printable-decode
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.quoted-printable-encode');
fwrite($fp, "This is a test.\n");
/* Outputs:  =This is a test.=0A  */
?>
]]>
   </programlisting>
  </example>
 </section>

 <section id="filters.compression">
  <title>Компрессионные фильтры</title>

  <simpara>
   В то время, как <xref linkend="wrappers.compression"/> обеспечивает способ
   создания gzip- и bz2-совместимых файлов в локальной файловой системе,
   они (???) не предоставляют (???) общих средств средств для компрессии в сетевых
   потоках, как не предоставляют и средств для создания потока без компрессии
   с последующим превращением в компрессируемый.
   Для этих целей к любым потоковым ресурсам в любое время могут применяться
   компрессионные фильтры.
  </simpara>

  <note>
   <simpara>
    Компрессионные фильтры <emphasis>не</emphasis> генерируют заголовков и
    окончаний, которые используют утилиты коммандной строки, такие как
    <literal>gzip</literal>. Они просто компрессируют (сжимают) и
    декомпрессируют (разжимают) порции данных в компрессируемом потоке
    данных.
   </simpara>
  </note>

  <simpara>
   <literal>zlib.deflate</literal> (компрессия) и
   <literal>zlib.inflate</literal> (декомпрессия) являются реализациями
   компрессионных методов, описаных в
   <ulink url="&url.rfc;1951">RFC 1951</ulink>.
   Фильтр <literal>deflate</literal> принимает три аргумента, переданных в
   виде ассоциативного массива.  

   <parameter>level</parameter> определяет, какой уровень компрессии
   использовать (1-9). Повышение этого значения приведёт к уменьшению
   объёмов данных за счёт увеличения времени обработки. Существуют так же два
   специальных уровня компрессии:
   0 (для отключения компрессии) и -1 (внутреннее значение по умолчанию
   библиотеки zlib -- на текущий момент равно 6).

   <parameter>window</parameter> - это логарифм размера окна диапазона сжатия,
   где база логарифма составляет 2.
   Высокие значения (вплоть до 15 -- 32768 байт) приводят к улучшению
   компрессии за счёт роста необходимой памяти, в то время как низкие значения
   (вплоть дл 9 -- 512 байт) приводят к ухудшению компрессии за счёт
   уменьшения необходимой памяти.
   Значением аргумента <parameter>window</parameter> по умолчанию на текущий
   момент является <constant>15</constant>.

   <parameter>memory</parameter> определяет масштаб резервируемой памяти.
   Допустимые значения находятся в диапазоне от 1 (минимальное резервирование)
   до 9 (максимальное резервирование). Такое резервирование памяти влияет
   только на скорость и не влияет на размер генерируемых данных..
  </simpara>

  <note>
   <simpara>
    Так как уровень компрессии является наиболее часто используемым
    аргументом, вы можете передать только его в качестве обычного целого
    числа (integer), вместо того чтобы передавать массив из одного элемента.
   </simpara>
  </note>

  <simpara>
   Компрессионные фильтры zlib.* доступны с версии PHP
   <literal>5.1.0</literal>, если включена поддержка
   <xref linkend="ref.zlib"/> (???). Они так же доступны в качестве
   обратного порта для версий <literal>5.0.x</literal> путём установки
   пакета <ulink url="&url.pecl.package;zlib_filter">zlib_filter</ulink>
   из <ulink url="&url.pecl;">PECL</ulink>. Эти фильтры <emphasis>не</emphasis>
   доступны в PHP 4.
  </simpara>

  <example>
   <title>
    <literal>zlib.deflate</literal> и
    <literal>zlib.inflate</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$params = array('level' => 6, 'window' => 15, 'memory' => 9);

$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, $params);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";
echo "The original text was:\n";
/* Use readfile and zlib.inflate to decompress on the fly */
readfile('php://filter/zlib.inflate/resource=test.deflated');

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.
The original text was:
This is a test.
This is only a test.
This is not an important string.

 */
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>
    Упрощённое использование <literal>zlib.deflate</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
/* Here "6" indicates compression level 6 */
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, 6);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.

 */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>bzip2.compress</literal> и
   <literal>bzip2.decompress</literal>
   работают точно так же, как и фильтры zlib, онисанные выше.

   Фильтр <literal>bzip2.compress</literal> принимает два аргумента в виде
   элементов ассоциативного массива: 

   <parameter>blocks</parameter> является целочисленным (integer) значением
   в диапазоне от 1 до 9 и указывает на количество 100-килобайтовых блоков
   памяти для резервирования в качестве рабочего пространства.

   <parameter>work</parameter> - это так же целочисленное (integer) значение
   в диапазоне от 0 до 250, определяющее сколько усилий нужно потратить на
   обычный метод компрессии перед переключением на медленный, но более
   надёжный метод. Изменение этого параметра влияет только на скорость
   компрессии. Ни размер сжатого результата, ни используемый объём памяти не
   изменяются при помощи этой настройки. Значение 0 указывает библиотеке bzip
   использовать собственное внутреннее значение по умолчанию.

   Фильтр <literal>bzip2.decompress</literal> принимает всего один аргумент,
   который может быть передан либо как обычное boolean-значение, либо как
   элемент <parameter>small</parameter> ассоциативного массива.

   Когда <parameter>small</parameter> установлен в &true;, библиотека bzip
   совершит декомпрессию с минимальным расходом памяти за счёт понижения
   скорости.
  </simpara>

  <simpara>
   Компрессионные фильтры bzip2.* доступны с версии PHP
   <literal>5.1.0</literal>, если включена поддержка
   <xref linkend="ref.bzip2"/> (???). Они так же доступны в качестве
   обратного порта для версий <literal>5.0.x</literal> путём установки
   пакета <ulink url="&url.pecl.package;bz2_filter">bz2_filter</ulink>
   из <ulink url="&url.pecl;">PECL</ulink>. Эти фильтры <emphasis>не</emphasis>
   доступны в PHP 4.
  </simpara>

  <example>
   <title>
    <literal>bzip2.compress</literal> и
    <literal>bzip2.decompress</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$param = array('blocks' => 9, 'work' => 0);

echo "The original file is " . filesize('LICENSE') . " bytes long.\n";

$fp = fopen('LICENSE.compressed', 'w');
stream_filter_append($fp, 'bzip2.compress', STREAM_FILTER_WRITE, $param);
fwrite($fp, file_get_contents('LICENSE'));
fclose($fp);

echo "The compressed file is " . filesize('LICENSE.compressed') . " bytes long.\n";

/* Generates output:

The original text is 3288 characters long.
The compressed file is 1488 bytes long.

 */
?>
]]>
   </programlisting>
  </example>
 </section>
</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
