<?xml version="1.0" encoding="windows-1251"?>
<!-- $Revision: 1.2 $ -->
<appendix id="migration">
 <title>Переход от PHP/FI 2.0 к PHP 3.0</title>

 <section id="migration.about">
  <title>О несовместимости в версии 3.0</title>

  <simpara>
   PHP 3.0 был переписан практически 'с нуля. Он обладает надлежащим
   синтаксическим анализатором, который обладает более высоким
   быстродействием и последовательностью, чем использовавшийся
   в версиях 2.0. Версия 3.0 использует меньше памяти. Однако,
   достижение некоторых из улучшений было невозможно без
   изменения условий совместимости, как в синтаксисе, так и
   в функциональности.
  </simpara>

  <simpara>
   Ко всему прочему, разработчики PHP постарались сделать как синтаксис, 
   так и семантику максимально четкими в версии 3.0, и это также
   стало причиной ухудшения совместимости. В конце концов, разработчики
   полагают, что эти изменения приведут только к лучшему.
  </simpara>

  <simpara>
   Эта глава предназначена для того, чтобы дать вам представление
   о несовместимостях во время смены PHP/FI 2.0 на PHP 3.0 и помочь
   вам разрешить их. Новые отличительные особенности здесь не
   упомянуты, за исключением случаев необходимости.
  </simpara>

  <simpara>
   Существует программа преобразования, которая может автоматически
   привести ваши скрипты PHP/FI 2.0 к версии 3.0. Ее можно найти
   в каталоге <filename class="directory">convertor</filename> дистрибутива
   PHP 3.0.  Тем не менее, вы должны внимательно прочитать эту главу,
   так как эта программа устраняет только синтаксическую несовместимость.
  </simpara>
 </section>

 <section id="migration.startendtags">
  <title>Начальный/конечный теги</title>

  <para>
   Первое, что вы, вероятно, заметили - это изменение тегов PHP.
   Прежняя форма <literal>&lt;? &gt;</literal> была заменена на
   новые три возможные:
   <example>
    <title>Переход: прежние начальный/конечный теги</title>
    <programlisting role="php">
&lt;? echo "Это код PHP/FI 2.0.\n"; &gt;
    </programlisting>
   </example>
   В версии 2.0 PHP/FI также поддерживает такой вариант:
   <example>
    <title>Переход: первые новые начальный/конечный теги</title>
    <programlisting role="php">
&lt;? echo "Это код PHP 3.0!\n"; ?&gt;
    </programlisting>
   </example>

   Заметьте, что конечный тег теперь состоит из вопросительного
   знака и символа 'больше' вместо одного символа 'больше'. Однако,
   если вы планируете использовать XML на вашем сервере, вы
   можете столкнуться с проблемами, поскольку PHP будет пытаться
   выполнить разметку XML как код PHP. Вследствие этого, был
   предложен следующий вариант:

   <example>
    <title>Переход: вторые новые начальный/конечный теги</title>
    <programlisting role="php">
&lt;?php echo "Это код PHP 3.0!\n"; ?&gt;
    </programlisting>
   </example>

   Некоторые пользователи столкнулись с проблемой некорректного
   восприятия тегов некоторыми редакторами. Одним из таких
   редакторов является Microsoft FrontPage, и, для решения
   этой проблемы, был введен следующий вариант:

   <example>
    <title>Переход: третьи новые начальный/конечный теги</title>
    <programlisting role="php">
&lt;script language="php"&gt;

  echo "Это код PHP 3.0!\n";

&lt;/script&gt;
    </programlisting>
   </example>
  </para>
 </section>

 <section id="migration.if-endif">
  <title>Синтаксис if..endif</title>

  <para>
   'Альтернативный' способ написания операторов if/elseif/else с использованием
   if(); elseif(); else; endif; не может эффективно выполняться без
   сильного усложнения синтаксического анализатора версии 3.0. Вследствие
   этого, синтаксис был изменен:
   <example>
    <title>Переход: прежний синтаксис if..endif</title>
    <programlisting role="php">
if ($foo);
    echo "да\n";
elseif ($bar);
    echo "почти\n";
else;
    echo "нет\n";
endif;
    </programlisting>
   </example>
   <example>
    <title>Переход: новый синтаксис if..endif</title>
    <programlisting role="php">
if ($foo):
    echo "да\n";
elseif ($bar):
    echo "почти\n";
else:
    echo "нет\n";
endif;
    </programlisting>
   </example>
 
   Заметьте, что во всех операторах, кроме завершающего выражение 
   (endif), вместо точек с запятыми используются запятые.
  </para>
 </section>

 <section id="migration-while">
  <title>Синтаксис while</title>
  <para>
   Как и в случае с if..endif, синтаксис while..endwhile изменился:
   <example>
    <title>Переход: прежний синтаксис while..endwhile</title>
    <programlisting role="php">
while ($more_to_come);
    ...
endwhile;
    </programlisting>
   </example>
   <example>
    <title>Переход: новый синтаксис while..endwhile</title>
    <programlisting role="php">
while ($more_to_come):
    ...
endwhile;
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    Использование прежнего синтаксиса while..endwhile в PHP 3.0
    приведет к получению бесконечного цикла.
   </simpara>
  </warning>
 </section>

 <section id="migration.expr">
  <title>Типы выражений</title>
  <simpara>
   Для определения типа результата выражений в PHP/FI 2.0 использовалась
   их левая часть. В PHP 3.0 при определении типа результата используются
   обе части, и выполнение скриптов PHP/FI 2.0 в среде PHP 3.0 может привести
   к непредсказуемым результатам.
  </simpara>
  <para>
   Рассмотрите этот пример:
   <informalexample>
    <programlisting role="php">
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
    </programlisting>
   </informalexample>

   В PHP/FI 2.0 этот скрипт выводит оба индекса $a. В PHP 3.0
   этот скрипт не выводит ничего. Причиной этого является то,
   что в PHP/FI 2.0 левый аргумент имеет строковый тип, поэтому
   производилось строковое сравнение; в самом деле, <literal>""</literal>
   не равно <literal>"0"</literal>, и цикл успешно продолжал выполнение.
   В PHP 3.0 при сравнении строки с целочисленным значением, выполняется
   целочисленное сравнение (строка переводится в число). Это приводит
   к сравнению <literal>atoi("")</literal>, что равно <literal>0</literal> и
   <literal>variablelist</literal>, что также равно <literal>0</literal>,
   а поскольку <literal>0==0</literal>, тело цикла не выполняется ни разу. 
  </para>
  <para>
   Исправить это просто. Замените оператор while на:
   <informalexample>
    <programlisting role="php">
while ((string)$key != "") {
    </programlisting>
   </informalexample>
  </para>
 </section>

 <section id="migration.errors">
  <title>Изменились сообщения об ошибках</title>
  <simpara>
   Сообщения об ошибках PHP 3.0 обычно более точны, чем в 2.0,
   но вы больше не сможете получить для просмотра фрагмент
   кода, ставший причиной возникновения ошибки. Вместо этого
   вы увидите имя файла и номер строки, в которой произошла
   ошибка.
  </simpara>
 </section>

 <section id="migration.booleval">
  <title>Неполное вычисление логических выражений</title>
  <simpara>
   В PHP 3.0 логические выражения вычисляются неполно. Это означает,
   что в выражении, подобном <literal>(1 || test_me())</literal>
   функция <function>test_me</function> не будет выполнена, поскольку
   ничто не может изменить результат выражения после <literal>1</literal>.
  </simpara>

  <simpara>
   Это второстепенный фактор несовместимости, но, тем не менее, 
   он может приводить к неожиданным побочным эффектам.
  </simpara>
 </section>

 <section id="migration.truefalse">
  <title>Значения &true;/&false;, возвращаемые функциями</title>
  <simpara>
   Большинство внутренних функций были переписаны так, чтобы
   в результате их успешного выполнения возвращалось значение &true;
   и &false; в случае неудачного выполнения, что соотвествует значениям
   0 и -1 в PHP/FI 2.0. Новое поведение функций позволяет создавать
   более логичный код, например <literal>$fp = fopen("/your/file") или
   fail("darn!");</literal>. По причине отсутствия в PHP/FI 2.0
   четких правил, определяющих возвращаемые функциями значения
   в случае их неудачного завершения, скрипты, подвергшиеся
   преобразованию, должны быть проверены вручную.
  </simpara>
  <para>
   <example>
    <title>Переход от 2.0: возвращаемые значения, прежний код</title>
    <programlisting role="php">
$fp = fopen($file, "r");
if ($fp == -1);
    echo("Нельзя открыть файл $file для чтения&lt;br&gt;\n");
endif;
    </programlisting>
   </example>
   <example>
    <title>Переход от from 2.0: возвращаемые значения, прежний код</title>
    <programlisting role="php">
$fp = @fopen($file, "r") or print("Нельзя открыть файл $file для чтения&lt;br&gt;\n");
    </programlisting>
   </example>
  </para>
 </section>

 <section id="migration-other">
  <title>Другие несовместимости</title>

  <itemizedlist>
   <listitem><simpara>
    Модуль PHP 3.0 больше не поддерживает Apache версий более
    ранних, чем 1.2. Теперь требуется Apache версии 1.2 или более поздней.
   </simpara></listitem>

   <listitem><simpara>
    <function>echo</function> больше не поддерживает форматирование строк.
    Вместо нее используйте функцию <function>printf</function>.
   </simpara></listitem>

   <listitem><simpara>
    В PHP/FI 2.0, ошибка в программировании стала причиной того, что
    переменная <literal>$foo[0]</literal> имела такое же значение, как и
    <literal>$foo</literal>. В PHP 3.0 эта ошибка отсутствует.
   </simpara></listitem>

   <listitem>
    <simpara>
     Чтение массивов с использованием <literal>$array[]</literal> 
     больше не поддерживается
    </simpara>
    <simpara>
     Таким образом, вы не можете пройти по массиву циклом, выполняющим
     действие <literal>$data = $array[]</literal>. Вместо этого используйте
     <function>current</function> и <function>next</function>.
    </simpara>
    <simpara>
     Также, <literal>$array1[] = $array2</literal> не добавляет
     значений <literal>$array2</literal> к
     <literal>$array1</literal>, но добавляет
     <literal>$array2</literal> в конец
     <literal>$array1</literal>. Ознакомьтесь также с многомерными
     массивами.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     Оператор конкатенации <literal>"+"</literal> больше не является
     перегруженным по отношению к строкам, вместо этого он
     преобразует свои аргументы в числа и выполняет операцию сложения.
     Вместо этого используйте оператор <literal>"."</literal>.
    </simpara>
   </listitem>
  </itemizedlist>

  <example>
   <title>Переход от 2.0: конкатенация строк</title>
   <programlisting role="php">
echo "1" + "1";
   </programlisting>
   <para> 
    В PHP 2.0 результатом этого будет 11, в PHP 3.0 результатом
    будет 2. Вместо этого используйте:
    <programlisting role="php">
echo "1"."1";
    </programlisting>
    <programlisting role="php">
$a = 1;
$b = 1;
echo $a + $b;
    </programlisting>
   </para>
   <para>
    Результатом этого и в PHP 2.0 и 3.0 будет 2.
    <programlisting role="php">
$a = 1;
$b = 1;
echo $a.$b;
    </programlisting>
    В PHP 3.0 результатом этого будет 11.
   </para>
  </example>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
