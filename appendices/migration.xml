<?xml version="1.0" encoding="windows-1251"?>
<!-- $Revision: 1.4 $ -->
<appendix id="migration">
 <title>Переход от PHP/FI 2 к PHP 3</title>

 <section id="migration.about">
  <title>О несовместимостях в 3.0</title>

  <simpara>
   PHP 3.0 переписан с 'нуля'. Он включает в себя собственный анализатор,
   который является более устойчивым и логически завершенным, чем
   в 2.0. 3.0 также является намного более быстрым и использует
   меньше памяти. Однако, внесение некоторых из вышеупомянутых
   улучшений не могло повлечь за собой изменения в вопросах
   совместимости как в синтаксисе, так и в функциональности.
  </simpara>

  <simpara>
   Кроме того, разработчики PHP в версии 3.0 постарались сделать 
   максимально точными как синтаксис, так и семантику языка,
   что также стало причиной некоторой несовместимости. В конце
   концов, мы полагаем, что эти изменения приведут только к лучшему.
  </simpara>

  <simpara>
   Эта глава призвана осветить вопросы несовместимости, с которыми
   вы можете столкнуться при переходе от PHP/FI 2.0 к PHP 3.0 и
   помочь вам решить их. Новые возможности здесь не упоминаются,
   за исключением необходимых случаев.
  </simpara>

  <simpara>
   Существует программа преобразования, которая способна автоматически
   преобразовать ваши старые скрипты для PHP/FI 2.0. Она находится в
   подкаталоге <filename class="directory">convertor</filename> дистрибутива
   PHP 3.0. Эта программа только устраняет синтаксические несоответствия,
   поэтому в любом случае вам нужно внимательно прочитать эту главу.
  </simpara>
 </section>

 <section id="migration.startendtags">
  <title>Открывающий/закрывающий теги</title>

  <para>
   Изменившийся открывающий и закрывающий теги, возможно, первое, что вы
   заметили. Прежняя форма <literal>&lt;? &gt;</literal> была заменена
   тремя новыми:
   <example>
    <title>Переход: прежние открывающий/закрывающий теги</title>
    <programlisting role="php">
<![CDATA[
<? echo "Это код PHP/FI 2.0.\n"; ?>
]]>
    </programlisting>
   </example>
   В версии 2.0 PHP/FI также поддерживает такой вариант:
   <example>
    <title>Переход: первый вариант открывающих/закрывающих тегов</title>
    <programlisting role="php">
<![CDATA[
<? echo "Это код PHP 3.0!\n"; ?>
]]|
    </programlisting>
   </example>

   Обратите внимание, что теперь закрывающий тег состоит из
   вопросительного знака и символа 'больше' вместо одного символа
   'больше'. Однако, если вы планируете использовать XML,
   у вас могут возникнуть проблемы с использованием первого
   варианта, поскольку PHP сможет попытаться выполнить разметку
   XML как код PHP. Вследствие этого, был создан еще один
   вариант:

   <example>
    <title>Переход: второй вариант открывающих/закрывающих тегов</title>
    <programlisting role="php">
<![CDATA[
<?php echo "Это код PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>

   Некоторые пользователи сталкивались с проблемами при использовании
   редакторов, которые вообще не воспринимают управляющих инструкций.
   Таким редактором, например, является Microsoft FrontPage; и, чтобы
   избавиться от проблем подобного рода, был создан следующий вариант:

   <example>
    <title>Переход: третий вариант открывающих/закрывающих тегов</title>
    <programlisting role="php">
<![CDATA[
<script language="php">

  echo "Это код PHP 3.0!\n";

</script>
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section id="migration.if-endif">
  <title>Синтаксис if..endif</title>

  <para>
   Альтернативный способ создания структур с помощью операторов
   if/elseif/else, используя if(); elseif(); else; endif; не смог
   бы быть осуществлен без усложнения синтаксического анализатора
   версии 3.0. Поэтому синтаксис был изменен:
   <example>
    <title>Переход: прежний синтаксис if..endif</title>
    <programlisting role="php">
<![CDATA[
if ($foo);
    echo "есть\n";
elseif ($bar);
    echo "почти\n";
else;
    echo "нет\n";
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Переход: новый синтаксис if..endif</title>
    <programlisting role="php">
<![CDATA[
if ($foo):
    echo "есть\n";
elseif ($bar):
    echo "почти\n";
else:
    echo "нет\n";
endif;
]]>
    </programlisting>
   </example>

   Обратите внимание, что точки с запятыми были заменены на
   двоеточия во всех операторах кроме завершающего выражение (endif).
  </para>
 </section>

 <section id="migration-while">
  <title>Синтаксис while</title>
  <para>
   Как и в случае с if..endif, синтаксис while..endwhile изменился
   as well:
   <example>
    <title>Переход: прежний синтаксис while..endwhile</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come);
    ...
endwhile;
]]>
    </programlisting>
   </example>
   <example>
    <title>Переход: новый синтаксис while..endwhile</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come):
    ...
endwhile;
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    Если вы будете использовать в PHP 3.0 прежний синтаксис
    while..endwhile syntax, результатом будет бесконечный цикл.
   </simpara>
  </warning>
 </section>

 <section id="migration.expr">
  <title>Типы выражений</title>
  <simpara>
   В версии PHP/FI 2.0 для определения типа результата использовалась
   левая часть выражения. PHP 3.0 при определении типов результата
   принимает во внимание обе части выражений, что может привести
   выполнение скриптов версии 2.0 к непредсказуемым результатам.
  </simpara>
  <para>
   Рассмотрим следующий пример:
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
]]>
    </programlisting>
   </informalexample>

   В PHP/FI 2.0 этот скрипт показал бы оба индекса $a.  В PHP 3.0
   скрипт ничего бы не показал. Причиной этого является то,
   что в PHP 2.0, из-за того, что левая часть аргумента являлась
   строкой, происходило строковое сравнение, в результате чего
   <literal>""</literal> не было равно <literal>"0"</literal>,
   и условие цикла выполнялось. В PHP 3.0, когда строка
   сравнивается с целочисленным значением, происходит целочисленное
   сравнение (строка преобразуется в целочисленное выражение);
   в результате чего происходит сравнение <literal>atoi("")</literal>,
   значение чего равняется <literal>0</literal>, и <literal>variablelist</literal>,
   что также равняется <literal>0</literal>, а, поскольку <literal>0==0</literal>,
   условие цикла не выполнялось и цикл завершался.
  </para>
  <para>
   Существует простое решение этой проблемы. Замените оператор while на:
   <informalexample>
    <programlisting role="php">
<![CDATA[
while ((string)$key != "") {
]]>
    </programlisting>
   </informalexample>
  </para>
 </section>

 <section id="migration.errors">
  <title>Изменения в сообщениях об ошибках</title>
  <simpara>
   Сообщения об ошибках в PHP 3.0 обычно содержат более точную информацию,
   нежели в 2.0, но, вместе с тем, вы не сможете больше увидеть
   фрагмент кода, ставший причиной возникновения ошибки; вместо этого
   вы будете проинформированы об имени файла и номере строки, выполнение
   которой стало причиной появления ошибки.
  </simpara>
 </section>

 <section id="migration.booleval">
  <title>Неполное вычисление логических условий</title>
  <simpara>
   В PHP 3.0 имеет место неполное вычисление логических условий.
   Это означает, что в выражении, подобном <literal>(1 || test_me())</literal>,
   функция <function>test_me</function> не будет выполнена, поскольку
   ничто не сможет изменить результат вычисления выражения после
   <literal>1</literal>.
  </simpara>

  <simpara>
   Это незначительная несовместимость, но, тем не менее, она может
   становиться причиной неожиданных побочных эффектов.
  </simpara>
 </section>

 <section id="migration.truefalse">
  <title>Значения, возвращаемые функцией &true;/&false;</title>
  <simpara>
   Выполнение большинства внутренних функций было изменено таким
   образом, что при успешном завершении они возвращают &true;
   и &false; при неудачном завершении, что соответствует 0 и -1 в
   PHP/FI 2.0. Новое поведение функций позволяет создавать в большей
   степени логичный код, подобный <literal>$fp = fopen("/your/file") or
   fail("darn!");</literal>. Вследствие того, что в PHP/FI 2.0 отсутствуют
   четкие правила, определяющие возвращаемые функциями значения в
   результате их неудачного выполнения, большинство таких скриптов
   должны быть проверены вручную после использования преобразователя
   скриптов версии 2.0 к версии 3.0.
  </simpara>
  <para>
   <example>
    <title>Переход от 2.0: возвращаемые значения, прежний код</title>
    <programlisting role="php">
<![CDATA[
$fp = fopen($file, "r");
if ($fp == -1);
    echo("Ошибка открытия файла $file для чтения<br>\n");
endif;
]]|
    </programlisting>
   </example>
   <example>
    <title>Переход от 2.0: возвращаемые значения, новый код</title>
    <programlisting role="php">
<![CDATA[
$fp = @fopen($file, "r") or print("Ошибка открытия файла $file для чтения<br>\n");
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section id="migration-other">
  <title>Прочие несовместимости</title>

  <itemizedlist>
   <listitem><simpara>
    Apache-модуль PHP 3.0 больше не поддерживает Apache версий
    более ранних, чем 1.2. Для работы необходим Apache 1.2 или
    более поздних версий.
   </simpara></listitem>

   <listitem><simpara>
    <function>echo</function> больше не выполняет форматирование строк.
    Используйте <function>printf</function> для этой цели.
   </simpara></listitem>

   <listitem><simpara>
    В PHP/FI 2.0 побочный эффект программирования приводил к тому, что 
    <literal>$foo[0]</literal> имела то же значение, что и
    <literal>$foo</literal>. Этот недочет был исправлен в PHP 3.0.
   </simpara></listitem>

   <listitem>
    <simpara>
     Чтение массивов с использованием <literal>$array[]</literal> больше
     не поддерживается.
    </simpara>
    <simpara>
     Это означает, что вы не можете прочитать массив с использованием
     цикла, выполняющего <literal>$data = $array[]</literal>. Используйте
     <function>current</function> и <function>next</function> для этой цели.
    </simpara>
    <simpara>
     Также, <literal>$array1[] = $array2</literal> не добавляет
     значений <literal>$array2</literal> к
     <literal>$array1</literal>, а добавляет
     <literal>$array2</literal> в качестве последнего элемента
     <literal>$array1</literal>. Ознакомьтесь также с поддержкой
     многоразмерных массивов.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <literal>"+"</literal> больше не является перегруженным оператором 
     конкатенации по отношению к строкам, вместо этого он преобразует
     их значения в целочисленные выражения и производит операцию
     сложения. Для конкатенации строк используйте <literal>"."</literal>.
    </simpara>
   </listitem>
  </itemizedlist>

  <example>
   <title>Переход от 2.0: конкатенация строк</title>
   <programlisting role="php">
<![CDATA[
echo "1" + "1";
]]>
   </programlisting>
   <para> 
    В PHP 2.0 этот скрипт выведет 11, в PHP 3.0 -
    2. Используйте:
    <programlisting role="php">
<![CDATA[
echo "1"."1";
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a + $b;
]]>
    </programlisting>
   </para>
   <para>
    Этот скрипт выведет 2 и в PHP 2.0 и в PHP 3.0.
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a.$b;
]]>
    </programlisting>
    Этот скрипт выведет 11 в PHP 3.0.
   </para>
  </example>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
