<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1.18  Maintainer: sveta Status: ready -->
<!-- $Revision: 1.3 $ -->
<!-- splitted from ./en/functions/array.xml, last change in rev 1.2 -->
  <refentry xml:id="function.extract" xmlns="http://docbook.org/ns/docbook">
   <refnamediv>
    <refname>extract</refname>
    <refpurpose>
     Импортировать переменные из массива в текущую символьную таблицу.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Описание</title>
     <methodsynopsis>
      <type>int</type><methodname>extract</methodname>
      <methodparam><type>array</type><parameter>var_array</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>extract_type</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>prefix</parameter></methodparam>
     </methodsynopsis>
    <para>
     Эта функция используется для импорта переменных из массива в текущую символьную таблицу.
     Она берёт ассоциативный массив в качестве параметра
     <parameter>var_array</parameter> и трактует его ключи как имена переменных
     и значения как значения переменных.  Для каждой пары ключ/значение будет
     создана переменная в текущей символьной таблице, согласно параметрам
     <parameter>extract_type</parameter> и
     <parameter>prefix</parameter>.
    </para>
    <note>
     <para>
      Начиная с версии 4.0.5, эта функция возвращает количество
      извлечённых переменных.
     </para>
    </note>
    <note>
     <para>
      <constant>EXTR_IF_EXISTS</constant> и <constant>EXTR_PREFIX_IF_EXISTS</constant> были добавлены в версии 4.2.0.
     </para>
    </note>
    <note>
     <para>
      <constant>EXTR_REFS</constant> был добавлен в версии 4.3.0.
     </para>
    </note>
    <para>
     <function>extract</function> проверяет каждый ключ на соответствие
     приемлемости в качестве имени переменной. Эта функция также обрабатывает
     коллизии имён, если ключ совпадает с именем переменной, уже существующей
     в текущей символьной таблице. Способ обработки неприемлемых/числовых
     ключей и коллизий имён устанавливает параметр
     <parameter>extract_type</parameter>. Он может принимать одно из следующих
     значений:
     <variablelist>
      <varlistentry>
       <term><constant>EXTR_OVERWRITE</constant></term>
       <listitem>
        <simpara>
         Если переменная с таким именем существует, она будет переназначена.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>EXTR_SKIP</constant></term>
       <listitem>
        <simpara>
         Если переменная с таким именем существует, будет сохранено её прежнее значение.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>EXTR_PREFIX_SAME</constant></term>
       <listitem>
        <simpara>Если переменная с таким именем существует, к её имени будет добавлен
        префикс, определённый параметром <parameter>prefix</parameter>.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>EXTR_PREFIX_ALL</constant></term>
       <listitem>
        <simpara>
         Добавить префикс <parameter>prefix</parameter> ко всем именам переменных.
         Начиная с PHP 4.0.5, также включает числовые имена.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>EXTR_PREFIX_INVALID</constant></term>
       <listitem>
        <simpara>
         Добавить префикс <parameter>prefix</parameter> только к неприемлемым/числовым
         именам переменных. Этот флаг был добавлен в PHP 4.0.5.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>EXTR_IF_EXISTS</constant></term>
       <listitem>
        <simpara>
         Переназначить только переменные, уже имеющиеся в текущей символьной таблице,
         в противном случае ничего не делать.  Данная возможность полезна
         для определения списка приемлемых переменных и для извлечения только
         тех переменных, которые вы уже определили из массивов типа $_REQUEST, например.
         Этот флаг был добавлен в PHP 4.2.0.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>EXTR_PREFIX_IF_EXISTS</constant></term>
       <listitem>
        <simpara>
         Создать переменные, имена которых начинаются с <parameter>prefix</parameter>
         только если переменная с названием, которому не предшествует <parameter>prefix</parameter>,
         определена в текущей символьной таблице.
         Этот флаг был добавлен в PHP 4.2.0.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>EXTR_REFS</constant></term>
       <listitem>
        <simpara>
         Извлечь переменные как ссылки. Это означает, что значения таких переменных
         будут всё ещё ссылаться на значения массива <parameter>var_array</parameter>.
         Вы можете использовать этот флаг
         отдельно или комбинировать его с другими, используя OR. Этот флаг был добавлен в PHP 4.3.0.
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Если <parameter>extract_type</parameter> не определён, он
     трактуется как <constant>EXTR_OVERWRITE</constant>.
    </para>
    <para>
     Обратите внимание, что <parameter>prefix</parameter> имеет значение, только если
     <parameter>extract_type</parameter> установлен в <constant>EXTR_PREFIX_SAME</constant>,
     <constant>EXTR_PREFIX_ALL</constant>, <constant>EXTR_PREFIX_INVALID</constant> 
     или <constant>EXTR_PREFIX_IF_EXISTS</constant>. Если 
     в результате добавления префикса, не будет получено допустимое имя для переменной, 
     она не будет импортирована в текущую символьную таблицу.
    </para>
    <para>
     <function>extract</function> возвращает количество переменных,
     успешно импортированных в символьную таблицу.
    </para>
    <warning>
     <para>
      Не используйте функцию <function>extract</function> для непроверенных данных, таких как
      пользовательский ввод ($_GET, ...). Если вы сделаете это, например, 
      для того, что бы временно запустить старый код, использующий
      <link linkend="security.globals">register_globals</link>,
      используйте соответствующий флаг <parameter>extract_type</parameter>
      для того, что бы не переназначить уже установленные переменные,
      такой как <constant>EXTR_SKIP</constant> и удостоверьтесь, что вы извлекаете
      содержимое массивов
      <varname>$_SERVER</varname>, <varname>$_SESSION</varname>,
      <varname>$_COOKIE</varname>, <varname>$_POST</varname> и
      <varname>$_GET</varname> в этом порядке.
     </para>
    </warning>
    <para>
     Функцию <function>extract</function> также можно использовать для импорта
     в текущую символьную таблицу переменных, содержащихся в ассоциативном массиве,
     возвращённом функцией <function>wddx_deserialize</function>.
    </para>
    <para>
     <example>
      <title>Пример использования <function>extract</function></title>
      <programlisting role="php">
<![CDATA[
<?php

/* Предположим, что $var_array - это массив, полученный в результате
   wddx_deserialize */

$size = "large";
$var_array = array("color" => "blue",
                   "size"  => "medium",
                   "shape" => "sphere");
extract($var_array, EXTR_PREFIX_SAME, "wddx");

echo "$color, $size, $shape, $wddx_size
";

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
blue, large, sphere, medium
]]>
      </screen>
     </example>
    </para>
    <para>
     Переменная <varname>$size</varname> не была переназначена, потому что мы
     определили <constant>EXTR_PREFIX_SAME</constant>, в результате чего была создана
     переменная <varname>$wddx_size</varname>. Если был бы определён флаг <constant>EXTR_SKIP</constant>,
     тогда переменная <varname>$wddx_size</varname> не была бы создана.
     <constant>EXTR_OVERWRITE</constant> был бы причиной того, что переменной <varname>$size</varname>
     было бы присвоено значение "medium", и <constant>EXTR_PREFIX_ALL</constant> был бы причиной того, что были бы также
     созданы новые переменные <varname>$wddx_color</varname>,
     <varname>$wddx_size</varname> и
     <varname>$wddx_shape</varname>.
    </para>
    <para>
     Вы должны использовать ассоциативный массив, использование числовых массивов
     не приведёт ни к каким результатам, если вы не использууете <constant>EXTR_PREFIX_ALL</constant> и 
     <constant>EXTR_PREFIX_INVALID</constant>.
    </para>
    <para>
     См. также <function>compact</function>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
