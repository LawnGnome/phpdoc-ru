<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: n/a Maintainer: shein Status: old -->
<!-- $Revision$ -->
<refentry xml:id="function.unserialize" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>unserialize</refname>
  <refpurpose>
   Создает значение PHP из хранимого представления
  </refpurpose>
 </refnamediv>
 
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>mixed</type><methodname>unserialize</methodname>
   <methodparam><type>string</type><parameter>str</parameter></methodparam>
  </methodsynopsis>
  <simpara>
   <function>unserialize</function> принимает одну сериализованную переменную и
   конвертирует ее обратно в значение PHP.
  </simpara>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>str</parameter></term>
     <listitem>
      <para>
       Сериализованная строка.
      </para>
      <para>
       Если переменная, требующая десериализации, является объектом, после успешного 
       восстановления объекта PHP автоматически попытается вызвать магический метод
       <function>__wakeup</function> (если он существует).
      </para>
      <para>
       <note>
        <title>Директива unserialize_callback_func</title>
        <para>
         Существует возможность указать функцию обратного вызова, которая будет вызвана,
         если в процессе десериализации должен быть проинициализирован неопределенный класс.
         (для предотвращения получения неполного объекта "__PHP_Incomplete_Class".)
         Используйте &php.ini;, <function>ini_set</function> или &htaccess; 
         для определения функции 'unserialize_callback_func'. Каждый раз, когда должен быть
         проинициализирован неопределенный класс, будет вызываться эта функция. Для отключения этой возможности
         просто оставьте значение директивы пустым.
        </para>
       </note>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Возвращается преобразованное значение, которое может быть одного из типов <type>boolean</type>,
   <type>integer</type>, <type>float</type>, <type>string</type>,
   <type>array</type> или <type>object</type>.
  </para>
  <para>
   В случае, если переданная строка не поддается десериализации, возвращается &false; и
   генерируется <literal>E_NOTICE</literal>.
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>4.2.0</entry>
       <entry>
        Становится доступна директива unserialize_callback_func.
       </entry>
      </row>
      <row>
       <entry>4.0.0</entry>
       <entry>
        При сериализации объекта методы больше не теряются.
        См. 
        <link linkend="language.oop5.serialization">Serializing Objects</link>
        для более подробной информации.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Пример использования <function>unserialize</function></title>
    <programlisting role="php">
<![CDATA[
<?php
// Мы используем функцию unserialize() для загрузки сессионных данных в массив
// $session_data из строки, извлекаемой из базы данных.
// Данный пример дополняет пример, описывающий использование serialize().

$conn = odbc_connect("webdb", "php", "chicken");
$stmt = odbc_prepare($conn, "SELECT data FROM sessions WHERE id = ?");
$sqldata = array($_SERVER['PHP_AUTH_USER']);
if (!odbc_execute($stmt, &$sqldata) || !odbc_fetch_into($stmt, &$tmp)) {
    // если процедура извлечения данных неудачная, то инициализируем пустой массив
    $session_data = array();
} else {
    // сейчас у нас должны быть сериализованные данные в $tmp[0].
    $session_data = unserialize($tmp[0]);
    if (!is_array($session_data)) {
        // что-то пошло не так, инициализируем пустой массив
        $session_data = array();
    }
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Пример использования unserialize_callback_func</title>
    <programlisting role="php">
<![CDATA[
<?php
$serialized_object='O:1:"a":1:{s:5:"value";s:3:"100";}';

// директива unserialize_callback_func доступна в PHP с версии 4.2.0
ini_set('unserialize_callback_func', 'mycallback'); // определяем свою функцию обратного вызова

function mycallback($classname) 
{
    // просто подключаете файл, содержащий определение класса
    // Вы получаете имя $classname для выяснения, определение какого класса требуется
}
?>
]]>
    </programlisting>
   </example>
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <warning>
   <para>
    &false; возвращается как в случае ошибки, так и в случае, если десериализуется
    сериализованное значение &false;. Этот особый случай можно отловить, используя
    сравнение <parameter>str</parameter> со значением
    <literal>serialize(false)</literal>, или перехватив сгенерированную ошибку
    <literal>E_NOTICE</literal>.
   </para>
  </warning>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>serialize</function></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
