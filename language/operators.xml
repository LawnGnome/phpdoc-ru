<?xml version="1.0" encoding="windows-1251"?>
<!-- $Revision: 1.2 $ -->
<!-- EN-Revision: 1.80 Maintainer: young Status: ready -->
 <chapter id="language.operators">
  <title>Операторы</title>
  <simpara>
  Оператором называется нечто, состоящее из одного или более значений (выражений, 
  если говорить на жаргоне программирования), которое можно вычислить как новое 
  значение (таким образом, вся конструкция может рассматриваться как выражение).   
  Отсюда следует, что функции или любые другие конструкции, которые возвращают 
  значение (например, <function>print</function>) являются операторами, в отличие
  от всех остальных языковых конструкций (например, <function>echo</function>), 
  которые ничего не возвращают.
  </simpara>
  <para>
   Операторы бывают трех видов. Во-первых, это унарные операторы, которые работают
   только с одним аргументом, например, <literal>!</literal> 
   (оператор отрицания) или <literal>++</literal> (инкримент). Вторую группу 
   составляют бинарные операторы: в нее входят большинство поддерживаемых в PHP операторов, 
   полный список которых вы можете найти в разделе <link linkend="language.operators.precedence">
   Порядок выполнения операторов</link>.
  </para>
  <para>
   И последнюю, третью группу составляет тернарный оператор <literal>?:</literal>.  
   Он используется для условного выбора между двумя операторами, в зависимости
   от результата вычисления третьего оператора. Говоря другими словами, он позволяет 
   определить две альтернативные ветви дальнейшего выполнения. Тернарный оператор
   рекомендуется заключать в круглые скобки.
  </para>
  
  <sect1 id="language.operators.precedence">
   <title>Приоритет выполнения операторов</title>
   <para>
    Приоритет операторов определяет, насколько "тесно" связанны между
	собой два выражения. Например, выражение  <literal>1 +
    5 * 3</literal> вычисляется как <literal>16</literal>, а не
    <literal>18</literal>, поскольку операция умножения ("*") имеет
	более высокий приоритет, чем операция сложения ("+"). В случае, если
	операторы имеют одинаковый приоритет, они будут выполняться слева направо.
	Круглые скобки могут использоваться для принудительного указания 
	необходимого порядка выполнения операторов. Например, 
	выражение <literal>(1 + 5) * 3</literal> вычисляется как 
    <literal>18</literal>.
   </para>
   <para>
    В следующей таблице приведен список операторов, отсортированный по
	убыванию их приоритетов. Операторы, размещенные в одной строке имеют
	одинаковый приоритет и порядок их выполнения опроделяется исходя из
	их ассоциативности.
    <table>
     <title>Порядок выполнения операторов</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Ассоциативность</entry>
        <entry>Оператор</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>неассоциативна</entry>
        <entry>new</entry>
       </row>
       <row>
        <entry>правая</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>++ --</entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>! ~ - (int) (float) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>== != === !==</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>правая</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>,</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
      Левая ассоциативность подразумевает, что выражение вычисляется слева направо,
	  правая ассоциативность соответственно подразумевает противоположный порядок.
      <example> 
       <title>Ассоциативность</title> 
       <programlisting role="php"> 
  <![CDATA[ 
  <?php 
  $a = 3 * 3 % 5; // (3 * 3) % 5 = 4 
  $a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2 
    
  $a = 1; 
  $b = 2; 
  $a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5 
  ?> 
  ]]> 
       </programlisting> 
      </example>
	   Вы моежете использовать круглые скобки для повышения читабельности кода. 
     </para> 
   <note>
    <para>
     Несмотря на то, что оператор <literal>!</literal>  имеет
	 более высокий приоритет чем <literal>=</literal>, PHP позволяет
	 использовать следующую конструкцию: <literal>if (!$a = foo())</literal>,
	 которая присваивает переменной <varname>$a</varname> результат
	 выполнения функции <literal>foo()</literal>.
    </para>
   </note>
  </sect1>

  <sect1 id="language.operators.arithmetic">
   <title>Арифметические операторы</title>
   <simpara>
    Помните школьные основы арифметики? Описанные ниже операторы
	работают так же.
   </simpara>
   <table>
    <title>Арифметические операции</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row> 
         <entry>-$a</entry> 
         <entry>Отрицание</entry> 
         <entry>Смена знака $a.</entry> 
      </row> 
      <row>
       <entry>$a + $b</entry>
       <entry>Сложение</entry>
       <entry>Сумма $a и $b.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Вычитание</entry>
       <entry>Разность $a и $b.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Умножение</entry>
       <entry>Произведение $a и $b.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Деление</entry>
       <entry>Частное от деления $a на $b.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Деление по модулю</entry>
       <entry>Целочисленный остаток от деления $a на $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
   Операция деления ("/") всегда возвращает вещественный тип, даже если
   оба значения были целочисленными (или строками, которые преобразуются
   в целые числа).
   </simpara>
   <note> 
      <simpara> 
       Остаток <literal>$a % $b</literal> будет негативным, для негативных значений 
       <literal>$a</literal>. 
      </simpara> 
     </note> 
   <simpara>
    Также вы можете ознакомиться с разделом документации 
    <link linkend="ref.math">Математические функции</link>. 
   </simpara>

   <!--
   <simpara>
    The division operator ("/") returns an integer value (the result
    of an integer division) if the two operands are integers (or
    strings that get converted to integers) and the quotient is an
    integer. If either operand is a floating-point value, or the
    operation results in a non-integer value, a floating-point value
    is returned.
   </simpara>
   -->
  </sect1>
  
  <sect1 id="language.operators.assignment">
   <title>Оператор присвоения</title>
   <simpara>
    Базовый оператор присвоения обозначается как
	<literal>=</literal>. На первый взгляд может показаться,
	что это оператор "равно". На самом деле это не так. В действительности,
	оператор присвоения означает, что левый операнд получает значение
	правого выражения, (т.е. устанавливается результирующим значением).
   </simpara>
   <para>
    Результатом выполнения оператора присвоения является само присвоенное значение.
	Таким образом, результат выполнения <literal>$a = 3</literal> будет равен 
	<literal>3</literal>. Это позволяет использовать конструкции вида:
    <informalexample>
     <programlisting role="php"> 
<![CDATA[
<?php

$a = ($b = 4) + 5; // результат: $a установлена значением 9, переменной $b присвоено 4.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    В дополнение к базовому оператору присвоения имеются "комбинированные операторы" для
	всех  бинарных арифметических и строковых операций, которые позволяют
	использовать некоторое значение в выражении, а затем установить его как 
	результат данного выражения. Например:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // устанавливает $a значением 8, аналогично записи: $a = $a + 5;
$b = "Hello ";
$b .= "There!"; // устанавливает $b строкой "Hello There!",  как и $b = $b . "There!";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Обратите внимание, что присвоение копирует оригинальную переменную в новую
   (присвоение по значению), таким образом все последующие изменения
   одной из переменных на другой никак не отражаются. Начиная с PHP 4, также поддерживается
   присваивание по ссылке, используя синтаксис <computeroutput>$var =
    &amp;$othervar;</computeroutput>, но в PHP 3 такая возможность отсутствует.
	'Присвоение по ссылке' означает, что обе переменные указывают на 
	одни и те же данные и никакого копирования не происходит.
	Для получения более полной информации об этой возможности, обратитесь к разделу 
	документации <link linkend="language.references">Подробно об указателях</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.bitwise">
   <title>Побитовые операторы</title>
   <simpara>
    Побитовые операторы позволяют устанавливать конкретные биты
	в 0 или 1 для целочисленных значений. В случае если и левый, и правый 
	операнды строки, побитовые операции будут работать с их ASCII-представлениями.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Выведет '5'

echo "12" ^ "9"; // Отобразит симовол возврата каретки (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Выведет следующие ASCII-значения: #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4
?>
]]>
     </programlisting>
    </informalexample> 
   </para>

   <table>
    <title>Побитовые операторы</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a &amp; $b</entry>
       <entry>Побитовое 'и'</entry>
       <entry>Устанавливаются только те биты, которые установлены и в $a, и в $b.</entry>
      </row>
      <row>
       <entry>$a | $b</entry>
       <entry>Побитовое 'или'</entry>
       <entry>Устанавливаются те биты, которые установлены либо в $a, либо в $b.</entry>
      </row>
      <row>
       <entry>$a ^ $b</entry>
       <entry>Исключающее или</entry>
       <entry>
	   Устанавливаются только те биты, которые установлены либо только в $a, либо только в $b
       </entry>
      </row>
      <row>
       <entry>~ $a</entry>
       <entry>Отрицание</entry>
       <entry>
 	    Устанавливаются те биты, которые в $a не установлены, и наоборот.
       </entry>
      </row>
      <row>
       <entry>$a &lt;&lt; $b</entry>
       <entry>Сдвиг влево</entry>
       <entry>
	   Все биты переменной $a сдвигаються на $b позиций влево (каждая позиция
	   подразумевает 'умножение на 2')
       </entry>
      </row>
      <row>
       <entry>$a &gt;&gt; $b</entry>
       <entry>Сдвиг вправо</entry>
       <entry>
	   Все биты переменной $a сдвигаються на $b позиций вправо (каждая позиция
	   подразумевает 'деление на 2')
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
    <warning> 
      <para>
	   Не используйте сдвиг вправо более чем на 32 бита на тридцатидвухразрядных 
	   системах. Не используйте сдвиг вправо для получения чисел, требующих для записи 
	   более ридцатидвух бит.
      </para> 
     </warning> 
  </sect1>

  <sect1 id="language.operators.comparison">
   <title>Операторы сравнения</title>
   <simpara>
    Операторы сравнения, как это видно из их названия, позволяют
	сравнивать между собой два значения. Также вам возможно будет
	интересно ознакомиться с разделом  <link linkend="types.comparisons">Сравнение типов</link>, 
	в котором приведено большое количество соответствующих примеров.
   </simpara>
   <table>
    <title>Операторы сравнения</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Равно</entry>
       <entry>&true; если $a равно $b.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Тождественно равно</entry>
       <entry>
        &true; если $a равно $b и имеет тот же тип. (Добавлено в PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Не равно</entry>
       <entry>&true; если $a не равно $b.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Не равно</entry>
       <entry>&true; если $a не равно $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Тождественно не равно</entry>
       <entry>
        &true; если $a не равно $b или в случае, если они разных типов
       (Добавлено в PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Меньше</entry>
       <entry>&true; если $a строго меньше $b.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Больше</entry>
       <entry>&true; если $a строго больше $b.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Меньше или равно</entry>
       <entry>&true; если $a is меньше или равно $b.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Больше или равно</entry>
       <entry>&true; если $a больше или равно $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
      В случае, если вы сравниваете целое со строкой, строка будет
	  <link linkend="language.types.string.conversion">преобразована к числу</link>.
	  В случае, если вы сравниваете две числовые строки, они сравниваются
	  как целые числа. Эти правила также распространяются на оператор
      <link linkend="control-structures.switch">switch</link>. 
      <informalexample> 
       <programlisting role="php"> 
  <![CDATA[ 
  <?php 
  var_dump(0 == "a"); // 0 == 0 -> true 
  var_dump("1" == "01"); // 1 == 1 -> true 
    
  switch ("a") { 
  case 0: 
      echo "0"; 
      break; 
  case "a": // Эта ветка никогда не будет достигнута, так как "a" уже сопоставленно с 0 
      echo "a"; 
      break; 
  } 
  ?> 
  ]]> 
       </programlisting> 
      </informalexample> 
     </para> 
   
   <para>
   Еще одним условным оператором является тернарный оператор "?:".
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Пример использования тернарного оператора
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// Приведенный выше код аналогичен следующему блоку с использованием if/else
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}
?>
]]>
     </programlisting>
    </informalexample> 
    Выражение <literal>(expr1) ? (expr2) : (expr3)</literal>
    интерпретируется как <replaceable>expr2</replaceable>, если 
    <replaceable>expr1</replaceable> вычисляется в &true;, или как 
    <replaceable>expr3</replaceable> если 
    <replaceable>expr1</replaceable> вычисляется в &false;.
   </para>
   <para>
    Также ознакомьтесь с описаниями функций <function>strcasecmp</function>,
    <function>strcmp</function>,
    и разделом документации 
    <link linkend="language.types">Типы</link> и <link linkend="language.operators.array">Операторы, работающие с массивами</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.errorcontrol">
   <title>Оператор управления ошибками</title>
   <simpara>
    PHP поддерживает один оператор управления ошибками: знак <literal>@</literal>. 
	В случае, если он предшествует какому-либо выражению в PHP-коде, любые
	сообщения об ошибках, генерируемые этим выражением, будут проигнорированы.
   </simpara>
   <simpara>
    В случае, если установлена опция <link linkend="ini.track-errors"><option>track_errors</option></link>,
	все генерируемые сообщения об ошибках будут сохраняться в переменной
    <link linkend="reserved.variables.phperrormsg">$php_errormsg</link>.
    Эта переменная будет перезаписываться при возникновении каждой новой ошибки,
	поэтому в случае необходимости проверяйте ее сразу же.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Преднамеренная ошибка при работе с файлами
$my_file = @file ('non_existent_file') or
    die ("Failed opening file: error was '$php_errormsg'");

// работает для любых выражений, а не только для функций
$value = @$cache[$key]; 
// В случае если ключа $key нет, сообщение об ошибке не будет отображено

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     Оператор <literal>@</literal> работает только с 
	 <link linkend="language.expressions">выражениями</link>. 
	 Есть простое правило: если произвольная языковая конструкция возвращает
	 значение, значит вы можете использовать предшествующий ей оператор
	 <literal>@</literal>. Например, вы можете использовать <literal>@</literal> перед
	 именем переменной, произвольной функцией или вызовом <function>include</function>, 
	 константой и так далее. В то же время вы не можете использовать этот оператор
	 перед определением функции или класса, условными конструкциями, такими как  <literal>if</literal> или
     <literal>foreach</literal>.
    </simpara>
   </note>
   <simpara>
    Также ознакомьтесь с описанием функции <function>error_reporting</function> 
	и соответствующим разделом документации
    <link linkend="ref.errorfunc">Обработка ошибок и функции логирования</link>.
   </simpara>
   <note>
    <para>
	 Оператор <literal>@</literal> не подавляет вывод ошибок, возникающих на
	 стадии синтаксического разбора скрипта.
    </para>
   </note>
   <warning>
    <para>
	 На сегодняшний день оператор <literal>@</literal> подавляет
	 вывод сообщений даже о критических ошибках прерывающих работу
	 скрипта. Помимо всего прочего, это означает, что если вы использовали
	 <literal>@</literal> для подавления ошибок, возникающих при работе какой-либо
	 функции, в случае если она недоступна или написана неправильно, дальнейшая 
	 работа скрипта будет остановлена без каких-либо уведомлений.
    </para>
   </warning>
  </sect1>
  
  <sect1 id="language.operators.execution">
   <title>Операторы исполнения</title>
   <para>
    PHP поддерживает один оператор исполнения: обратные кавычки (``). Обратите
	внимание, что это не одиночные кавычки. PHP пытается выполнить строку,
	заключенную в обратные кавычки, как консольную команду, и возвращает 
	полученный вывод (т.е. он не просто выдается на выходе а, например, может 
	быть присвоен переменной). Использование обратных кавычек аналогично
	использованию функции <function>shell_exec</function>. 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Обратные кавычки недоступны, в случае, если установлен &safemode; или 
     отключена функция <function>shell_exec</function>.
    </para>
   </note>
   <para>
    Ознакомьтесь также со следующими разделами документации: <link linkend="ref.exec">
	Функции для выполнения программ</link>, <function>popen</function>
    <function>proc_open</function>, и
    <link linkend="features.commandline">Использование PHP в командной строке</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.increment">
   <title>Операторы инкремента и декремента</title>
   <para>
   PHP, аналогично C, поддерживает префиксные и постфиксные
   операторы инкремента и декремента.
   </para>
   <table>
    <title>Операторы инкремента и декремента</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Действие</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Префиксный инкремент</entry>
       <entry>Увеличивает $a на единицу и возвращает значение $a.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Постфиксный инкремент</entry>
       <entry>Возвращает значение $a, а затем увеличивает $a на единицу.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Префиксный декремент</entry>
       <entry>Уменьшает $a на единицу и возвращает значение $a.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Постфиксный декремент</entry>
       <entry>Возвращает значение $a, а затем уменьшает $a на единицу.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
   Приведем пример простого скрипта:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Постфиксный инкремент</h3>";
$a = 5;
echo "Должно быть 5: " . $a++ . "<br />\n";
echo "Должно быть 6: " . $a . "<br />\n";

echo "<h3>Префиксный инкремент</h3>";
$a = 5;
echo "Должно быть 6: " . ++$a . "<br />\n";
echo "Должно быть 6: " . $a . "<br />\n";

echo "<h3>Постфиксный декремент</h3>";
$a = 5;
echo "Должно быть 5: " . $a-- . "<br />\n";
echo "Должно быть 4: " . $a . "<br />\n";

echo "<h3>Префиксный декремент</h3>";
$a = 5;
echo "Должно быть 4: " . --$a . "<br />\n";
echo "Должно быть 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP следует соглашениям Perl (в отличие от С) касательно выполнения
	арифметических операций с символьными переменными. Например в Perl 
	<literal>'Z'+1</literal> будет вычислено как <literal>'AA'</literal>, в то
	время как в C <literal>'Z'+1</literal> будет вычислено как <literal>'['</literal>
	 ( ord('Z') == 90, ord('[') == 91 ). Следует учесть, что к символьным переменным
	 можно применять операцию инкремента, в то время как операцию декремента применять
	 нельзя.
    <example>
     <title>Арифметические операции с символьными переменными</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for($n=0; $n<6; $n++)
  echo ++$i . "\n";

/*
  Результат работы будет следующий:

X
Y
Z
AA
AB
AC

*/
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
      Инкрементирование или декрементирование булевых переменных 
	  не приводит ни к какому результату.
   </para>
   
  </sect1>

  <sect1 id="language.operators.logical">
   <title>Логические операторы</title>

   <table>
    <title>Логические операторы</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>Логическое 'и'</entry>
       <entry>&true; если и $a, и $b &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Логическое 'или'</entry>
       <entry>&true; если или $a, или $b  &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Исключающее или</entry>
       <entry>&true; если $a, или $b &true;, но не оба.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Отрицание</entry>
       <entry>&true; если $a не &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>Логическое 'и'</entry>
       <entry>&true; если и $a, и $b &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Исключающее или	</entry>
       <entry>&true; если или $a, или $b  &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Смысл двух разных вариантов для операторов "and" и "or" в том, что
	они работают с различными приоритетами (смотрите таблицу 
    <link linkend="language.operators.precedence">Приоритет выполнения операторов</link>).
   </simpara>
  </sect1>

  <sect1 id="language.operators.string">
   <title>Строковые операторы</title>
   <simpara>
    В PHP есть два оператора для работы со <type>строками</type>.
	Первый - оператор конкатенации ('.'), который возвращает объединение
	левого и правого аргумента. Второй - оператор присвоения с конкатенацией, 
	который присоединяет правый аргумент к левому. Для получения более полной 
	информации ознакомтесь с разделом 
    <link linkend="language.operators.assignment">Оператор присвоения</link>.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hello ";
$b = $a . "World!"; // $b содержит строку "Hello World!"

$a = "Hello ";
$a .= "World!";     // $a содержит строку "Hello World!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Также ознакомьтесь с разделами документации 
    <link linkend="language.types.string">Строки</link> и 
    <link linkend="ref.strings">Функции для работы со строками</link>.
   </para>
  </sect1>
  
  <sect1 id="language.operators.array">
   <title>Операторы, работающие с массивами</title>
   <table>
    <title>Операторы, работающие с массивами</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Объединение</entry>
       <entry>Объединение массива $a и массива $b.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Равно</entry>
       <entry>&true; в случае, если $a и $b содержат одни и те же элементы.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Тождественно равно</entry>
       <entry>&true; в случае, если $a и $b содержат одни и те же элементы в том же самом порядке.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Не равно</entry>
       <entry>&true; если массив $a не равен массиву $b.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Не равно</entry>
       <entry>&true; если массив $a не равен массиву $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Тождественно не равно</entry>
       <entry>&true; если массив $a не равен тождественно массиву $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Оператор <literal>+</literal> присоединяет правый массив к массиву, 
	размещенному слева НЕ перезаписывая элементы с дублирующимися ключами.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Объеденение $a и $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Объединение $b и $a
echo "Union of \$b and \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    После своего выполнения скрипт напечатает следующее:
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
   При сравнении элементы массива считаются идентичными, если совпадает
   и ключ, и соответствующее значение.
   </para>
   <para>
    <example>
     <title>Сравнение массивов</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Также ознакомьтесь с разделами
    <link linkend="language.types.array">Массивы</link> и 	 
    <link linkend="ref.array">Функции для работы с массивами</link>.
   </para>
  </sect1>
  <sect1 id="language.operators.type">
   <title>Оператор проверки принадлежности к классу</title>
   <para>
    Оператор <literal>instanceof</literal> используется для определения того,
	является ли текущий объект экземпляром указанного <link linkend="language.oop">класса </link>.
   </para>
   <simpara>
    Оператор <literal>instanceof</literal> был добавлен в PHP 5.
   До этого использовалась конструкция <function>is_a</function>,
   которая на данный момент не рекомендуется к применению, 
   более предпочтительно использовать оператор <literal>instanceof</literal> .  
   </simpara>
   <informalexample>
    <programlisting>
<![CDATA[
<?php
class A { }
class B { }

$thing = new A;

if ($thing instanceof A) {
    echo 'A';
}
if ($thing instanceof B) {
    echo 'B';
}
?>
]]>
    </programlisting>
    <simpara>
     Поскольку объект <varname>$thing</varname> является экземпляром <type>класса</type> A, и никак не B,
	 то будет выполнен только первый, опирающийся на класс A, блок:
    </simpara>
    <screen>A</screen>
   </informalexample>
   <para>
    Ознакомьтесь также с описанием функций <function>get_class</function> и 
    <function>is_a</function>.
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
