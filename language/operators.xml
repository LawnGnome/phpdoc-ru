<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 304605 Maintainer: conf Status: ready -->
<!-- Reviewed: no -->
<!-- $Id$ -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>Операторы</title>
  <simpara>
   Оператором называется нечто, принимающее одно или более значений (или выражений,
   если говорить на жаргоне программирования), которое может вычислить новое
   значение (таким образом, вся конструкция может рассматриваться как выражение).
   Поэтому, можно думать о функциях или любых других конструкциях, которые возвращают
   значение (например, print), как об операторах, в отличие от всех остальных
   языковых конструкций (например, echo), которые ничего не возвращают.
  </simpara>
  <para>
   Операторы бывают трех видов. Во-первых, это унарные операторы, которые работают
   только с одним аргументом, например, ! (оператор отрицания) или ++ (инкремент).
   Вторую группу составляют бинарные операторы: в нее входят большинство поддерживаемых
   в PHP операторов, полный список которых вы можете найти в разделе
   <link linkend="language.operators.precedence">Порядок выполнения операторов</link>.
  </para>
  <para>
   И последнюю, третью группу, составляет тернарный оператор ?:.
   Он используется для выбора между двумя выражениями в зависимости
   от результата вычисления третьего. Говоря другими словами, он позволяет
   определить две альтернативные ветви дальнейшего выполнения. Тернарный оператор
   рекомендуется заключать в круглые скобки.
  </para>
  
  <sect1 xml:id="language.operators.precedence">
   <title>Приоритет выполнения операторов</title>
   <para>
    Приоритет операторов определяет, насколько "тесно" связаны между
	   собой два выражения. Например, выражение  <literal>1 +
    5 * 3</literal> вычисляется как <literal>16</literal>, а не
    <literal>18</literal>, поскольку операция умножения ("*") имеет
    более высокий приоритет, чем операция сложения ("+").
    Круглые скобки могут использоваться для принудительного указания
    порядка выполнения операторов. Например, выражение <literal>(1 + 5) * 3</literal>
    вычисляется как <literal>18</literal>. В случае, если
    операторы имеют одинаковый приоритет, они будут выполняться слева направо.
   </para>
   <para>
    В следующей таблице приведен список операторов, отсортированный по
    убыванию их приоритетов. Операторы, размещенные в одной строке имеют
    одинаковый приоритет и порядок их выполнения определяется исходя из
    их ассоциативности.
    <table>
     <title>Порядок выполнения операторов</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Ассоциативность</entry>
        <entry>Оператор</entry>
        <entry>Дополнительная информация</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>неассоциативна</entry>
        <entry>clone new</entry>
        <entry><link linkend="language.oop5.cloning">clone</link> и <link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>[</entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>++ --</entry>
        <entry>
         <link linkend="language.operators.increment">инкремент/декремент</link>
        </entry>
       </row>
       <row>
        <entry>правая</entry>
        <entry>~ - (int) (float) (string) (array) (object) (bool) @</entry>
        <entry>
         <link linkend="language.types">типы</link>
        </entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>instanceof</entry>
        <entry>
         <link linkend="language.types">типы</link>
        </entry>
       </row>
       <row>
        <entry>правая</entry>
        <entry>!</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>* / %</entry>
        <entry>
         <link linkend="language.operators.arithmetic">арифметические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>+ - .</entry>
        <entry>
         <link linkend="language.operators.arithmetic">арифметические операторы</link>&listendand;
         <link linkend="language.operators.string">строковые операторы</link></entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
        <entry>
         <link linkend="language.operators.bitwise">побитовые операторы</link>
        </entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>&lt; &lt;= &gt; &gt;= &lt;&gt;</entry>
        <entry>
         <link linkend="language.operators.comparison">сравнение операторов</link>
        </entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>== != === !==</entry>
        <entry>
         <link linkend="language.operators.comparison">сравнение операторов</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>&amp;</entry>
        <entry>
         <link linkend="language.operators.bitwise">побитовые операторы</link>&listendand;
         <link linkend="language.references">ссылки</link></entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>^</entry>
        <entry>
         <link linkend="language.operators.bitwise">побитовые операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>|</entry>
        <entry>
         <link linkend="language.operators.bitwise">побитовые операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>&amp;&amp;</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>||</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>? :</entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">тернарный оператор</link>
        </entry>
       </row>
       <row>
        <entry>правая</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
        <entry>
         <link linkend="language.operators.assignment">операторы присваивания</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>and</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>xor</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>or</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>,</entry>
        <entry>множество применений</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    Левая ассоциативность подразумевает, что выражение вычисляется слева направо,
	   правая ассоциативность, соответственно, подразумевает противоположный порядок.
    <example>
     <title>Ассоциативность</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
	   Используйте круглые скобки для повышения читабельности кода.
   </para>
   <note>
    <para>
     Несмотря на то, что оператор <literal>=</literal> имеет
     низший приоритет, чем большинство остальных операторов, PHP все равно позволяет
     использовать следующую конструкцию: <literal>if (!$a = foo())</literal>,
     которая присваивает переменной <varname>$a</varname> результат
     выполнения функции <literal>foo()</literal>.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>Арифметические операторы</title>
   <simpara>
    Помните школьные основы арифметики? Описанные ниже операторы работают так же.
   </simpara>
   <table>
    <title>Арифметические операции</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>Отрицание</entry>
       <entry>Смена знака <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Сложение</entry>
       <entry>Сумма <varname>$a</varname> и <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Вычитание</entry>
       <entry>Разность <varname>$a</varname> и <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Умножение</entry>
       <entry>Произведение <varname>$a</varname> и <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Деление</entry>
       <entry>Частное от деления <varname>$a</varname> на <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Деление по модулю</entry>
       <entry>Целочисленный остаток от деления <varname>$a</varname> на <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Операция деления ("/") возвращает число с плавающей точкой, кроме случая,
    когда оба значения являются целыми числами (или строками, которые преобразуются
    в целые числа), которые делятся нацело - в этом случае возвращается целое значение.
   </simpara>
   <simpara>
    При делении по модулю операнды преобразуются в целые числа (удалением дробной части)
    до начала операции.
   </simpara>
   <note>
    <simpara>
     Остаток <literal>$a % $b</literal> будет отрицательным, для отрицательных значений
     <literal>$a</literal>.
    </simpara>
   </note>
   <simpara>
    Также вы можете ознакомиться с разделом документации 
    <link linkend="ref.math">Математические функции</link>.
   </simpara>

  </sect1>
  
  <sect1 xml:id="language.operators.assignment">
   <title>Оператор присваивания</title>
   <simpara>
    Базовый оператор присваивания обозначается как "=". На первый взгляд
    может показаться, что это оператор "равно". На самом деле это не так.
    В действительности, оператор присваивания означает, что левый операнд
    получает значение правого выражения, (т.е. устанавливается значением).
   </simpara>
   <para>
    Результатом выполнения оператора присваивания является само присвоенное значение.
    Таким образом, результат выполнения "<literal>$a = 3</literal>" будет равен
    3. Это позволяет делать трюки наподобие:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a теперь равно 9, а $b было присвоено 4.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Для массивов (<type>array</type>), присвоение значения к именованному ключу происходит
    с помощью оператора "=&gt;". <link linkend="language.operators.precedence">Приоритет</link>
    этого оператора такой же, как и у остальных операторов присваивания.
   </para>
   <para>
    В дополнение к базовому оператору присваивания имеются "комбинированные операторы" для
    всех  <link linkend="language.operators">бинарных арифметических</link> и строковых операций, которые позволяют
    использовать некоторое значение в выражении, а затем установить его как
    результат данного выражения. Например:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // устанавливает $a в 8, как если бы мы написали: $a = $a + 5;
$b = "Hello ";
$b .= "There!"; // устанавливает $b в "Hello There!",  как и $b = $b . "There!";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Обратите внимание, что присвоение копирует оригинальную переменную в новую
    (присвоение по значению), таким образом все последующие изменения
    одной из переменных никак не отразятся на другой. Это может также иметь смысл,
    если вам надо скопировать что-то типа большого массива в длинном цикле.
   </para>
   <para>
    Объекты (<type>object</type>) являются исключением обычному присваиванию 
    по значению в PHP, начиная с версии PHP 5, они присваиваются по ссылке.
    Принудительно скопировать объекты по значению можно с помощью 
    специального ключевого слова <link linkend="language.oop5.cloning">clone</link>.
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>Присваивание по ссылке</title>
    <para>
     Присваивание по ссылке также поддерживается с помощью синтаксиса
     <computeroutput>$var = &amp;$othervar;</computeroutput>.
     'Присвоение по ссылке' означает, что обе переменные указывают на
     одни и те же данные и никакого копирования не происходит.
    </para>
    <para>
     <example>
      <title>Присваивание по ссылке</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b - это ссылка на $a

print "$a\n"; // печатает 3
print "$b\n"; // печатает 3

$a = 4; // меняем $a

print "$a\n"; // печатает 4
print "$b\n"; // также печатает 4, так как $b является ссылкой на $a,
              // которая успела измениться
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Начиная с версии PHP 5, оператор <link linkend="language.oop5.basic.new">new</link>
     автоматически возвращает ссылку, поэтому присваивание результата операции
     <link linkend="language.oop5.basic.new">new</link> по ссылке начиная с версии PHP 5.3 
     генерирует ошибку уровня <constant>E_DEPRECATED</constant>, а в более ранних версиях
     - ошибку уровня <constant>E_STRICT</constant>.
    </para>
    <para>
     Например, следующий код выдаст предупреждение:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

/* Следующая строка сгенерирует следующее сообщение об ошибке:
 * Deprecated: Assigning the return value of new by reference is deprecated in...
 * (Устаревший код: Присвоение результата работы new по ссылке устарело в...)
 */
$o = &new C;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Для получения более полной информации о ссылках и их возможностях, обратитесь к разделу
     <link linkend="language.references">Подробно о ссылках</link>.
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Побитовые операторы</title>
   <simpara>
    Побитовые операторы позволяют считывать и устанавливать конкретные биты
	   целых чисел.
   </simpara>
   <table>
    <title>Побитовые операторы</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>И</entry>
       <entry>Устанавливаются только те биты, которые установлены и в <varname>$a</varname>, и в <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>Или</entry>
       <entry>Устанавливаются те биты, которые установлены в <varname>$a</varname> или в <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>Исключающее или</entry>
       <entry>
	       Устанавливаются только те биты, которые установлены либо только в <varname>$a</varname>,
        либо только в <varname>$b</varname>, но не в обоих одновременно.
       </entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>Отрицание</entry>
       <entry>
 	      Устанавливаются те биты, которые не установлены в <varname>$a</varname> , и наоборот.
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Сдвиг влево</entry>
       <entry>
        Все биты переменной <varname>$a</varname> сдвигаются на <varname>$b</varname>
        позиций влево (каждая позиция подразумевает "умножение на 2")
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Сдвиг вправо</entry>
       <entry>
        Все биты переменной <varname>$a</varname> сдвигаются на <varname>$b</varname> позиций вправо
        (каждая позиция подразумевает "деление на 2")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Побитовый сдвиг в PHP - это арифметическая операция.
    Биты, сдвинутые за границы числа, отбрасываются.
    Сдвиг влево дополняет число нулями справа, сдвигая
    в то же время знаковый бит числа влево, что означает
    что знак операнда не сохраняется.
    Сдвиг вправо сохраняет копию сдвинутого знакового бита слева, что означает
    что знак операнда сохраняется.
   </para>
   <para>
    Используйте скобки для обеспечения необходимого.
    <link linkend="language.operators.precedence"> приоритета операторов</link>.
    Например, <literal>$a &amp; $b == true</literal> сначала проверяет
    на равенство, а потом выполняет побитовое и; тогда как
    <literal>($a &amp; $b) == true</literal> сначала выполняет побитовое и,
    а потом выполняет проверку на равенство.
   </para>
   <para>
    Будьте в курсе преобразований типов. Если оба, и левый и правый
    оператор являются строками, побитовый оператор будет работать
    с ASCII значениями символов этих строк.
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
Опция настроек PHP error_reporting использует побитовые значения,
обеспечивая реальную демонстрацию гашения значений битов.
Чтобы показать все ошибки, кроме замечаний,
инструкции в файле php.ini предлагают использовать:
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Начинаем со значения E_ALL:
<computeroutput>00000000000000000111011111111111</computeroutput>
Затем берем значение E_NOTICE...
<computeroutput>00000000000000000000000000001000</computeroutput>
... и инвертируем его с помощью <literal>~</literal>:
<computeroutput>11111111111111111111111111110111</computeroutput>
Наконец, с помощью AND (&amp;) узнаем биты, выставленные в единицу,
в обоих значениях:
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Другой способ достичь этого - использовать ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR, <literal>^</literal>),
чтобы получить только те биты, которые выставлены в единицу
либо только в одном, либо только в другом значении:
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting также может быть использована для демонстрации
включения битов. Показать только ошибки и обрабатываемые ошибки можно
следующим образом:
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Здесь мы комбинируем E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
и
<computeroutput>00000000000000000001000000000000</computeroutput>
с помощью оператора ИЛИ (OR, <literal>|</literal>),
чтобы получить включенные биты в обоих значениях:
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>Операции с побитовыми И, ИЛИ и ИСКЛЮЧАЮЩИМ ИЛИ (AND, OR и XOR) на целых числах</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Не обращайте внимания на этот верхний раздел кода,
 * это просто форматирование для более ясного вывода.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 результат     значение   оп   тест
 ---------     ---------  -- ---------
EOH;


/*
 * Вот сами примеры.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Побитовое И (AND) \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Побитовое (включающее) ИЛИ (OR) \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 результат     значение   оп   тест
 ---------     ---------  -- ---------
 Побитовое И (AND)
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Побитовое (включающее) ИЛИ (OR)
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>Операции с побитовым ИСКЛЮЧАЮЩИМ ИЛИ (XOR) над строками</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Выводит '5'

echo "12" ^ "9"; // Выводит символ Backspace (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Выводит ascii значения #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Выводит 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Выводит 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Сдвигание битов в целых числах</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Несколько примеров.
 */

echo "\n--- СДВИГ ВПРАВО В ПОЛОЖИТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'копия знакового бита была сдвинута влево');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'биты были сдвинуты за правый край');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'то же, что и выше; нельзя сдвинуть дальше 0');


echo "\n--- СДВИГ ВПРАВО В ОТРИЦАТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'копия знакового бита была сдвинута влево');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'биты были сдвинуты за правый край');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'то же, что и выше; нельзя сдвинуть дальше -1');


echo "\n--- СДВИГ ВЛЕВО В ПОЛОЖИТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'правый край был дополнен нулями');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'знаковые биты были сдвинуты');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'биты были сдвинуты за левый край');


echo "\n--- СДВИГ ВЛЕВО В ОТРИЦАТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'правый край был дополнен нулями');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'биты были сдвинуты за левый край, включая знаковый бит');


/*
 * Не обращайте внимания на этот нижний раздел кода,
 * это просто форматирование для более ясного вывода.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Выражение: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Десятичный вид:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Двоичный вид:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " ЗАМЕЧАНИЕ: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- СДВИГ ВПРАВО В ПОЛОЖИТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---
Выражение: 2 = 4 >> 1
 Десятичный вид:
  val=4
  res=2
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 ЗАМЕЧАНИЕ: копия знакового бита была сдвинута влево

Выражение: 1 = 4 >> 2
 Десятичный вид:
  val=4
  res=1
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Выражение: 0 = 4 >> 3
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были сдвинуты за правый край

Выражение: 0 = 4 >> 4
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше 0


--- СДВИГ ВПРАВО В ОТРИЦАТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---
Выражение: -2 = -4 >> 1
 Десятичный вид:
  val=-4
  res=-2
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 ЗАМЕЧАНИЕ: копия знакового бита была сдвинута влево

Выражение: -1 = -4 >> 2
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 ЗАМЕЧАНИЕ: биты были сдвинуты за правый край

Выражение: -1 = -4 >> 3
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше -1


--- СДВИГ ВЛЕВО В ПОЛОЖИТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---
Выражение: 8 = 4 << 1
 Десятичный вид:
  val=4
  res=8
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: 1073741824 = 4 << 28
 Десятичный вид:
  val=4
  res=1073741824
 Двоичный вид:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Выражение: -2147483648 = 4 << 29
 Десятичный вид:
  val=4
  res=-2147483648
 Двоичный вид:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 ЗАМЕЧАНИЕ: знаковые биты были сдвинуты

Выражение: 0 = 4 << 30
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были сдвинуты за левый край


--- СДВИГ ВЛЕВО В ОТРИЦАТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---
Выражение: -8 = -4 << 1
 Десятичный вид:
  val=-4
  res=-8
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: -2147483648 = -4 << 29
 Десятичный вид:
  val=-4
  res=-2147483648
 Двоичный вид:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Выражение: 0 = -4 << 30
 Десятичный вид:
  val=-4
  res=0
 Двоичный вид:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были сдвинуты за левый край, включая знаковый бит
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- СДВИГ ВПРАВО В ПОЛОЖИТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---
Выражение: 2 = 4 >> 1
 Десятичный вид:
  val=4
  res=2
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 ЗАМЕЧАНИЕ: копия знакового бита была сдвинута влево

Выражение: 1 = 4 >> 2
 Десятичный вид:
  val=4
  res=1
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Выражение: 0 = 4 >> 3
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были сдвинуты за правый край

Выражение: 0 = 4 >> 4
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше 0


--- СДВИГ ВПРАВО В ОТРИЦАТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---
Выражение: -2 = -4 >> 1
 Десятичный вид:
  val=-4
  res=-2
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 ЗАМЕЧАНИЕ: копия знакового бита была сдвинута влево

Выражение: -1 = -4 >> 2
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 ЗАМЕЧАНИЕ: биты были сдвинуты за правый край

Выражение: -1 = -4 >> 3
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше -1


--- СДВИГ ВЛЕВО В ПОЛОЖИТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---
Выражение: 8 = 4 << 1
 Десятичный вид:
  val=4
  res=8
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: 4611686018427387904 = 4 << 60
 Десятичный вид:
  val=4
  res=4611686018427387904
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Выражение: -9223372036854775808 = 4 << 61
 Десятичный вид:
  val=4
  res=-9223372036854775808
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: знаковые биты были сдвинуты

Выражение: 0 = 4 << 62
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были сдвинуты за левый край


--- СДВИГ ВЛЕВО В ОТРИЦАТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---
Выражение: -8 = -4 << 1
 Десятичный вид:
  val=-4
  res=-8
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: -9223372036854775808 = -4 << 61
 Десятичный вид:
  val=-4
  res=-9223372036854775808
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Выражение: 0 = -4 << 62
 Десятичный вид:
  val=-4
  res=0
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были сдвинуты за левый край, включая знаковый бит
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     Не используйте сдвиг вправо более чем на 32 бита на 32-битных
     системах. Не используйте сдвиг влево для получения чисел, требующих для записи
     более 32 бит.
     Используйте функции из расширения gmp на числах, больших PHP_INT_MAX.
    </para>
   </warning>
   <para>
    Смотрите также
    <function>pack</function>,
    <function>unpack</function>,
    <function>gmp_and</function>,
    <function>gmp_or</function>,
    <function>gmp_xor</function>,
    <function>gmp_testbit</function>,
    <function>gmp_clrbit</function>
   </para>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Операторы сравнения</title>
   <simpara>
    Операторы сравнения, как это видно из их названия, позволяют
    сравнивать между собой два значения. Также вам возможно будет
    интересно ознакомиться с разделом  <link linkend="types.comparisons">Сравнение типов</link>,
    в котором приведено большое количество соответствующих примеров.
   </simpara>
   <table>
    <title>Операторы сравнения</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Равно</entry>
       <entry>&true; если <varname>$a</varname> равно <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Тождественно равно</entry>
       <entry>
        &true; если <varname>$a</varname> равно <varname>$b</varname> и имеет тот же тип. (добавлено в PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Не равно</entry>
       <entry>&true; если <varname>$a</varname> не равно <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Не равно</entry>
       <entry>&true; если <varname>$a</varname> не равно <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Тождественно не равно</entry>
       <entry>
        &true; если <varname>$a</varname> не равно <varname>$b</varname> или в случае, если они разных типов
       (добавлено в PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Меньше</entry>
       <entry>&true; если <varname>$a</varname> строго меньше <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Больше</entry>
       <entry>&true; если <varname>$a</varname> строго больше <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Меньше или равно</entry>
       <entry>&true; если <varname>$a</varname> is меньше или равно <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Больше или равно</entry>
       <entry>&true; если <varname>$a</varname> больше или равно <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    В случае, если вы сравниваете целое со строкой или строку, содержащую число,
    строка будет <link linkend="language.types.string.conversion">преобразована к числу</link>.
    В случае, если вы сравниваете две числовые строки, они сравниваются
    как целые числа. Эти правила также распространяются на оператор
    <link linkend="control-structures.switch">switch</link>.
    Преобразование типов не происходит при использовании === или !==
    так как в этом случае кроме самих значений сравниваются еще и типы.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // Эта ветка никогда не будет достигнута, так как "a" уже сопоставленно с 0
    echo "a";
    break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Для различных типов сравнение происходит в соответствии со следующей
    таблицей (по порядку).
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Сравнение различных типов</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Тип операнда 1</entry>
       <entry>Тип операнда 2</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> или <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>&null; преобразуется в "", числовое или лексическое сравнение</entry>
      </row>
      <row>
       <entry><type>bool</type> или <type>null</type></entry>
       <entry>что угодно</entry>
       <entry>Преобразуется в <type>bool</type>, &false; &lt; &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>Встроенные классы могут определять свои собственные правила сравнения,
        объекты разных классов не сравниваются, объекты одного класса - сравниваются свойства
        тем же способом, что и в массивах (PHP 4), в PHP 5 есть свое собственное <link
        linkend="language.oop5.object-comparison">объяснение</link>
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> или <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> или <type>number</type></entry>
       <entry>Строки и ресурсы переводятся в числа, обычная математика</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>Массивы с меньшим числом элементов считаются меньше,
        если ключ из первого операнда не найден во втором операнде
        - массивы не могут сравниваться, иначе идет сравнение соответствующих
        значений (смотри последующий пример)</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>что угодно</entry>
       <entry><type>array</type> всегда больше</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>что угодно</entry>
       <entry><type>object</type> всегда больше</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>Транскрипция сравнения обычных массивов</title>
     <programlisting role="php">
<![CDATA[
<?php
// Массивы сравниваются наподобие этого кода при сравнении стандартными операторами
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // не могут быть сравнимы
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Смотрите также <function>strcasecmp</function>,
    <function>strcmp</function>,
    <link linkend="language.operators.array">операторы массивов</link>,
    и раздел руководства
    <link linkend="language.types">Типы</link>.
   </para>

   <warning>
    <title>Сравнение чисел с плавающей точкой</title>

    <para>
     Из-за особого внутреннего представления <type>float</type>, не нужно
     сравнивать два <type>float</type> числа между собой.
    </para>

    <para>
     Для более подробной информации смотрите документацию по типу <type>float</type>.
    </para>
   </warning>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Тернарный оператор</title>
    <para>
   Еще одним условным оператором является тернарный оператор "?:".
     <example>
      <title>Присваивание значения по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
// Пример использования тернарного оператора
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// Приведенный выше код аналогичен следующему блоку с использованием if/else
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example>
     Выражение <literal>(expr1) ? (expr2) : (expr3)</literal>
     интерпретируется как <replaceable>expr2</replaceable>, если
     <replaceable>expr1</replaceable> имеет значение &true;, или как
     <replaceable>expr3</replaceable> если
     <replaceable>expr1</replaceable> имеет значение &false;.
    </para>
    <para>
     Начиная с версии PHP 5.3 также стало возможным не писать среднюю часть
     тернарного оператора. Выражение <literal>expr1 ?: expr3</literal>
     возвращает <replaceable>expr1</replaceable> если <replaceable>expr1</replaceable>
     имеет значение &true;, и <replaceable>expr3</replaceable> в другом случае.
    </para>
    <note>
     <simpara>
      Пожалуйста, учтите, что тернарный оператор является выражением
      и трактуется не как переменная, а как результат выражения. Это важно знать,
      если вы хотите вернуть переменную по ссылке.
      Выражение <literal>return $var == 42 ? $a : $b;</literal> не будет
      работать в функции, возвращающей значение по ссылке, а в более поздних
      версиях PHP также будет выдано предупреждение.
     </simpara>
    </note>
    <note>
     <para>
      Рекомендуется избегать "нагромождения" тернарных выражений.
      Поведение PHP неочевидно при использовании нескольких тернарных операторов
      в одном выражении:
      <example>
       <title>Неочевидное поведение тернарного оператора</title>
       <programlisting role="php">
<![CDATA[
<?php
// на первый взгляд, следующий код должен вывести 'true'
echo (true?'true':false?'t':'f');

// однако, он выводит 't'
// это происходит потому, что тернарные выражения вычисляются слева направо

// это намного более очевидная версия вышеприведенного кода
echo ((true ? 'true' : false) ? 't' : 'f');

// здесь вы можете видеть, что первое выражение вычисляется в 'true', которое
// в свою очередь вычисляется в (bool)true, таким образом возвращая истинную ветвь
// второго тернарного выражения.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Оператор управления ошибками</title>
   <simpara>
    PHP поддерживает один оператор управления ошибками: знак <literal>@</literal>. 
    В случае, если он предшествует какому-либо выражению в PHP-коде, любые
    сообщения об ошибках, генерируемые этим выражением, будут проигнорированы.
   </simpara>
   <simpara>
    В случае, если установлена опция <link linkend="ini.track-errors"><option>track_errors</option></link>,
	   все генерируемые сообщения об ошибках будут сохраняться в переменной
    <varname>$php_errormsg</varname>.
    Эта переменная будет перезаписываться при каждой новой ошибке,
	   поэтому в случае необходимости проверяйте ее сразу же.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Преднамеренная ошибка при работе с файлами
$my_file = @file ('non_existent_file') or
    die ("Ошибка при открытии файла: сообщение об ошибке было таким: '$php_errormsg'");

// работает для любых выражений, а не только для функций
$value = @$cache[$key];
// В случае если ключа $key нет, сообщение об ошибке не будет отображено

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     Оператор <literal>@</literal> работает только с 
     <link linkend="language.expressions">выражениями</link>.
     Есть простое правило: если что-то возвращает
     значение, значит вы можете использовать перед ним оператор
     <literal>@</literal>. Например, вы можете использовать <literal>@</literal> перед
     именем переменной, произвольной функцией или вызовом <function>include</function>,
     константой и так далее. В то же время вы не можете использовать этот оператор
     перед определением функции или класса, условными конструкциями, такими как  <literal>if</literal>,
     &foreach; и т.д.
    </simpara>
   </note>
   <simpara>
    Также ознакомьтесь с описанием функции <function>error_reporting</function> 
	   и соответствующим разделом руководства
    <link linkend="ref.errorfunc">Обработка ошибок и функции логирования</link>.
   </simpara>
   <warning>
    <para>
     На сегодняшний день оператор <literal>@</literal> подавляет
     вывод сообщений даже о критических ошибках прерывающих работу
     скрипта. Помимо всего прочего, это означает, что если вы использовали
     <literal>@</literal> для подавления ошибок, возникающих при работе какой-либо
     функции, в случае если она недоступна или написана неправильно, дальнейшая
     работа скрипта будет остановлена без каких-либо уведомлений.
    </para>
   </warning>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Операторы исполнения</title>
   <para>
    PHP поддерживает один оператор исполнения: обратные кавычки (``). Обратите
    внимание, что это не одинарные кавычки! PHP попытается выполнить строку,
    заключенную в обратные кавычки, как консольную команду, и вернет
    полученный вывод (т.е. он не просто выводится на экран, а, например, может
    быть присвоен переменной). Использование обратных кавычек аналогично
    использованию функции <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Обратные кавычки недоступны, в случае, если установлен &safemode; или 
     отключена функция <function>shell_exec</function>.
    </para>
   </note>
   <para>
    Ознакомьтесь также со следующими разделами документации:
    <link linkend="ref.exec">Функции для выполнения программ</link>,
    <function>popen</function>  <function>proc_open</function>, и
    <link linkend="features.commandline">Использование PHP в командной строке</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Операторы инкремента и декремента</title>
   <para>
    PHP поддерживает префиксные и постфиксные операторы инкремента и декремента
    в стиле C.
   </para>
   <note>
    <simpara>
     Операторы инкремента/декремента не влияют на булевые значения.
     Декремент &null; также не даст никакого эффекта, однако инкремент
     даст значение <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Операторы инкремента и декремента</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Действие</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Префиксный инкремент</entry>
       <entry>Увеличивает <varname>$a</varname> на единицу и возвращает значение <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Постфиксный инкремент</entry>
       <entry>Возвращает значение <varname>$a</varname>, а затем увеличивает <varname>$a</varname> на единицу.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Префиксный декремент</entry>
       <entry>Уменьшает <varname>$a</varname> на единицу и возвращает значение <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Постфиксный декремент</entry>
       <entry>Возвращает значение <varname>$a</varname>, а затем уменьшает <varname>$a</varname> на единицу.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Приведем пример простого скрипта:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Постфиксный инкремент</h3>";
$a = 5;
echo "Должно быть 5: " . $a++ . "<br />\n";
echo "Должно быть 6: " . $a . "<br />\n";

echo "<h3>Префиксный инкремент</h3>";
$a = 5;
echo "Должно быть 6: " . ++$a . "<br />\n";
echo "Должно быть 6: " . $a . "<br />\n";

echo "<h3>Постфиксный декремент</h3>";
$a = 5;
echo "Должно быть 5: " . $a-- . "<br />\n";
echo "Должно быть 4: " . $a . "<br />\n";

echo "<h3>Префиксный декремент</h3>";
$a = 5;
echo "Должно быть 4: " . --$a . "<br />\n";
echo "Должно быть 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP следует соглашениям Perl (в отличие от С) касательно выполнения
    арифметических операций с символьными переменными. Например, в Perl
    <literal>'Z'+1</literal> будет вычислено как <literal>'AA'</literal>, в то
    время как в C <literal>'Z'+1</literal> будет вычислено как <literal>'['</literal>
    ( <literal>ord('Z') == 90</literal>, <literal>ord('[') == 91</literal> ).
    Следует учесть, что к символьным переменным можно применять операцию инкремента,
    в то время как операцию декремента применять нельзя.
    <example>
     <title>Арифметические операции с символьными переменными</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$i . "\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
X
Y
Z
AA
AB
AC
]]>
     </screen>
    </example>
   </para>
   <para>
    Инкрементирование или декрементирование булевых переменных не приводит ни к какому результату.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>Логические операторы</title>

   <table>
    <title>Логические операторы</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>И</entry>
       <entry>&true; если и <varname>$a</varname>, и <varname>$b</varname> &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Или</entry>
       <entry>&true; если или <varname>$a</varname>, или <varname>$b</varname> &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Исключающее или</entry>
       <entry>&true; если <varname>$a</varname>, или <varname>$b</varname> &true;, но не оба.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Отрицание</entry>
       <entry>&true; если <varname>$a</varname> не &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>И</entry>
       <entry>&true; если и <varname>$a</varname>, и <varname>$b</varname> &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Или</entry>
       <entry>&true; если или <varname>$a</varname>, или <varname>$b</varname> &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Смысл двух разных вариантов для операторов "and" и "or" в том, что
    они работают с различными приоритетами (смотрите таблицу
    <link linkend="language.operators.precedence">Приоритет выполнения операторов</link>).
   </simpara>
   <example>
    <title>Объяснение логических операторов</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() никогда не буде вызвана, так как эти операторы являются шунтирующими (short-circuit)

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" имеет больший приоритет, чем "or"

// Результат выражения (false || true) присваивается переменной $e
// Действует как: ($e = (false || true))
$e = false || true;

// Константа false присваивается $f, а затем значение true игнорируется
// Действует как: (($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" имеет больший приоритет, чем "and"

// Результат выражения (true && false) присваивается переменной $g
// Действует как: ($g = (true && false))
$g = true && false;

// Константа true присваивается $h, а затем значение false игнорируется
// Действует как: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Строковые операторы</title>
   <simpara>
    В PHP есть два оператора для работы со <type>строками</type>.
    Первый - оператор конкатенации ('.'), который возвращает объединение
    левого и правого аргумента. Второй - оператор присваивания с конкатенацией
    ('<literal>.=</literal>'), который присоединяет правый аргумент к левому.
    Для получения более полной информации ознакомьтесь с разделом
    <link linkend="language.operators.assignment">Операторы присваивания</link>.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hello ";
$b = $a . "World!"; // $b теперь содержит строку "Hello World!"

$a = "Hello ";
$a .= "World!";     // $a теперь содержит строку "Hello World!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Также ознакомьтесь с разделами документации
    <link linkend="language.types.string">Строки</link> и 
    <link linkend="ref.strings">Функции для работы со строками</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>Операторы, работающие с массивами</title>
   <table>
    <title>Операторы, работающие с массивами</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Объединение</entry>
       <entry>Объединение массива <varname>$a</varname> и массива <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Равно</entry>
       <entry>&true; в случае, если <varname>$a</varname> и <varname>$b</varname> содержат одни и те же элементы.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Тождественно равно</entry>
       <entry>&true; в случае, если <varname>$a</varname> и <varname>$b</varname> содержат
        одни и те же элементы в том же самом порядке.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Не равно</entry>
       <entry>&true;, если массив <varname>$a</varname> не равен массиву <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Не равно</entry>
       <entry>&true;, если массив <varname>$a</varname> не равен массиву <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Тождественно не равно</entry>
       <entry>&true;, если массив <varname>$a</varname> не равен тождественно массиву <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Оператор <literal>+</literal> присоединяет элементы с отличающимися ключами
    правого массива к левому, НЕ перезаписывая элементы с одинаковыми ключами.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Объединение $a и $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Объединение $b и $a
echo "Union of \$b and \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    После своего выполнения скрипт напечатает следующее:
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
   При сравнении элементы массива считаются идентичными, если совпадает
   и ключ, и соответствующее ему значение.
   </para>
   <para>
    <example>
     <title>Сравнение массивов</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Также ознакомьтесь с разделами
    <link linkend="language.types.array">Массивы</link> и 	 
    <link linkend="ref.array">Функции для работы с массивами</link>.
   </para>
  </sect1>
  <sect1 xml:id="language.operators.type">
   <title>Оператор проверки типа</title>
   <para>
    Оператор <literal>instanceof</literal> используется для определения того,
	   является ли текущий объект экземпляром указанного
    <link linkend="language.oop5.basic.class">класса</link>.
    <example>
     <title>Using <literal>instanceof</literal> with classes</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Оператор <literal>instanceof</literal> также может быть использован
    для определения наследует ли определенный объект какому-либо классу:
    <example>
     <title>Использование <literal>instanceof</literal> с наследуемыми классами</title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Для проверки <emphasis>непринадлежности</emphasis> объекта некоторому классу,
    используйте
    <link linkend="language.operators.logical">логический оператор <literal>not</literal></link>.
    <example>
     <title>Использование <literal>instanceof</literal> для проверки того, что объект <emphasis>не</emphasis>
      является экземпляром класса</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Ну и наконец, <literal>instanceof</literal> может быть также использован
    для проверки реализации объектом некоторого
    <link linkend="language.oop5.interfaces">интерфейса</link>:
    <example>
     <title>Использование <literal>instanceof</literal> для класса</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Хотя <literal>instanceof</literal> обычно используется с именем класса в строковых константах,
    он также может быть использован с другим объектом или строковой переменной:
    <example>
     <title>Использование <literal>instanceof</literal> с другими переменными</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b это объект класса MyClass
var_dump($a instanceof $c); // $c это строка 'MyClass'
var_dump($a instanceof $d); // $d это строка 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Есть несколько подводных камней, которых следует остерегаться.  До версии PHP 5.1.0,
    <literal>instanceof</literal> вызывал <link linkend="language.oop5.autoload">__autoload()</link>
    если имя класса не существовало. Вдобавок, если класс не был загружен,
    происходила фатальная ошибка. Это можно было обойти с помощью динамической ссылки на класс
    или использования строковой переменной с именем класса:
    <example>
     <title>Избежание поиска класса и фатальных ошибок с <literal>instanceof</literal> в PHP 5.0</title>
     <programlisting role="php">
<![CDATA[
<?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // нет фатальной ошибки
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    Оператор <literal>instanceof</literal> был добавлен в PHP 5.
    До этого времени использовалась функция <function>is_a</function>,
    но позже <function>is_a</function> была помечена устаревшей в пользу
    <literal>instanceof</literal>. Учтите, что с версии PHP 5.3.0,
    <function>is_a</function> больше не является устаревшей.
   </simpara>
   <para>
    Ознакомьтесь также с описанием функций <function>get_class</function> и
    <function>is_a</function>.
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
