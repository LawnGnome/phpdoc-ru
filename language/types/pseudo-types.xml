<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 293478 Maintainer: shein Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision$ -->
<sect1 xml:id="language.pseudo-types">
 <title>Псевдо-типы и переменные, используемые в этой документации</title>

 <sect2 xml:id="language.types.mixed">
  <title>mixed</title>

  <para>
   <literal>mixed</literal> говорит о том, что параметр может принимать много
   (но необязательно все) типов.
  </para>

  <para>
   <function>gettype</function> например, принимает все типы PHP, тогда как
   <function>str_replace</function> принимает только <type>string</type> и
   <type>array</type>.
  </para>

 </sect2>

 <sect2 xml:id="language.types.number">
  <title>number</title>

  <para>
   <literal>number</literal> говорит о том, что параметр может быть либо
   <type>integer</type>, либо <type>float</type>.
  </para>

 </sect2>

 <sect2 xml:id="language.types.callback">
  <title>callback</title>

  <para>
   Некоторые функции, такие как <function>call_user_func</function> или
   <function>usort</function> принимают в качестве параметра определенные пользователем
   callback-функции. Callback-функции могут быть не только простыми функциями, но также и
   методами объектов, включая статические методы классов.
  </para>

  <para>
   PHP-функция передается просто как строка ее имени. Можно использовать любую
   встроенную или пользовательскую функцию, кроме языковых конструкций, таких как:
   <function>array</function>, <function>echo</function>,
   <function>empty</function>, <function>eval</function>, 
   <function>exit</function>, <function>isset</function>, 
   <function>list</function>, <function>print</function> и
   <function>unset</function>.
  </para>

  <para>
   Метод созданного объекта передается как массив, содержащий сам объект в элементе
   с индексом 0 и имя метода в элементе с индексом 1.
  </para>

  <para>
   Статические методы классов также могут быть переданы без создания экземпляра объекта
   данного класса путем передачи имени класса вместо имени объекта в элементе с индексом 0.
  </para>

  <para>
   Кроме общих пользовательских функций, <function>create_function</function>
   также может быть использована для создания анонимной callback-функции.
   Начиная с версии PHP 5.3.0 стала возможным также передача
   <link linkend="functions.anonymous">замыканий</link> в callback-параметр.
  </para>

  <para>
   <example>
    <title>
      Примеры callback-функций
    </title>
    <programlisting role="php">
<![CDATA[
<?php 

// пример callback-функции
function my_callback_function() {
    echo 'hello world!';
}

// пример callback-метода
class MyClass {
    static function myCallbackMethod() {
        echo 'Hello World!';
    }
}

// Вариант 1: простой вызов callback
call_user_func('my_callback_function'); 

// Вариант 2: вызов статического метода класса
call_user_func(array('MyClass', 'myCallbackMethod')); 

// Вариант 3: вызов метода объекта
$obj = new MyClass();
call_user_func(array($obj, 'myCallbackMethod'));

// Вариант 4: вызов статического метода класса (с версии PHP 5.2.3)
call_user_func('MyClass::myCallbackMethod');

// Вариант 5: вызов относительного статического метода класса (с версии PHP 5.3.0)
class A {
    public static function who() {
        echo "A\n";
    }
}

class B extends A {
    public static function who() {
        echo "B\n";
    }
}

call_user_func(array('B', 'parent::who')); // A
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>
     Пример callback-вызова с использованием замыканий
    </title>
   <programlisting role="php">
<![CDATA[
<?php
// наше замыкание
$double = function($a) {
    return $a * 2;
};

// это наш диапазон чисел
$numbers = range(1, 5);

// Используем здесь замыкание в качестве callback-функции
// для удвоения размера каждого элемента в диапазоне
$new_numbers = array_map($double, $numbers);

print implode(' ', $new_numbers);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
2 4 6 8 10
]]>
    </screen>
   </example>
  </para>

  <note>
   <simpara>
    В PHP4 было необходимо использовать ссылку при создании callback-функции для того,
    чтобы она указывала на реальный объект, а не на его копию.
    За подробностями обращайтесь к разделу
    <link linkend="language.references">Объяснение ссылок</link>.
   </simpara>
  </note>

  &note.func-callback-exceptions;

 </sect2>
 
 <sect2 xml:id="language.types.void">
  <title>void</title>

  <para>
   <literal>void</literal> в качестве типа результата означает, что возвращенное
   значение бесполезно. <literal>void</literal> в списке параметров означает, что
   функция не принимает параметров.
  </para>

 </sect2>

 <sect2 xml:id="language.types.dotdotdot">
  <title>...</title>

  <para>
   <parameter>$...</parameter> в прототипах функции означает
   <literal>and so on</literal> (и так далее). Это имя переменной используется когда
   функция может принимать бесконечное количество параметров.
  </para>

 </sect2>
</sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
