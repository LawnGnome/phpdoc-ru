<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 305086 Maintainer: shein Status: ready -->
<!-- Reviewed: no -->
<!-- $Id$ -->
<sect1 xml:id="language.types.string">
 <title>Строки</title>

 <!-- FIXME PHP_6 Likely unicode support will alter this -->
 <para>
  Строка - это набор символов, поэтому символ - это то же самое, что
  и байт. Это значит, что возможно ровно 256 различных символов.
  Это также означает, что PHP не имеет встроенной поддержки
  Unicode. Некоторую базовую поддержку Unicode обеспечивают функции
  <function>utf8_encode</function> и
  <function>utf8_decode</function>.
 </para>

 <note>
  <simpara>
   Нет никаких проблем, если строка очень велика. Практически
   не существует ограничений на размер строк, налагаемых PHP; единственный лимит
   - это доступная память на компьютере, на котором запущен PHP.
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Синтаксис</title>

  <para>
   Строка может быть определена четырьмя различными способами:
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">одинарными кавычками</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">двойными кавычками</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">heredoc-синтаксисом</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">nowdoc-синтаксисом</link>
     (начиная с версии PHP 5.3.0)
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Одинарные кавычки</title>

   <para>
    Простейший способ определить строку - это заключить ее в
    одинарные кавычки (символ <literal>'</literal>).
   </para>

   <para>
    Чтобы использовать одинарную кавычку внутри строки,
    проэкранируйте ее обратной косой чертой (<literal>\</literal>).
    Если необходимо написать саму обратную косую черту, продублируйте ее
    (<literal>\\</literal>).
    Все остальные случаи применения обратной косой черты будут интерпретированы как
    обычные символы: это означает, что если вы попытаетесь использовать другие управляющие
    последовательности, такие как <literal>\r</literal> или <literal>\n</literal>,
    они будут выведены как есть вместо какого-либо особого поведения.
   </para>

   <note>
    <simpara>
     В отличие от синтаксиса <link linkend="language.types.string.syntax.double">двойных кавычек</link>
     и <link linkend="language.types.string.syntax.heredoc">heredoc</link>,
     <link linkend="language.variables">переменные</link> и
     управляющие последовательности для специальных
     символов, заключенных в одинарные кавычки, <emphasis>не</emphasis>
     обрабатываются.
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'это простая строка';

echo 'Также вы можете вставлять в строки
символ новой строки вот так,
это нормально';

// Выводит: Однажды Арнольд сказал: "I'll be back"
echo 'Однажды Арнольд сказал: "I\'ll be back"';

// Выводит: Вы удалили C:\*.*?
echo 'Вы удалили C:\\*.*?';

// Выводит: Вы удалили C:\*.*?
echo 'Вы удалили C:\*.*?';

// Выводит: Это не будет развернуто: \n новая строка
echo 'Это не будет развернуто: \n новая строка';

// Выводит: Переменные $expand также $either не разворачиваются
echo 'Переменные $expand также $either не разворачиваются';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Двойные кавычки</title>

   <para>
    Если строка заключена в двойные кавычки ("), PHP распознает
    большее количество управляющих последовательностей для
    специальных символов:
   </para>

   <table>
    <title>Управляющие последовательности</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Последовательность</entry>
       <entry>Значение</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>новая строка (LF или 0x0A (10) в ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>возврат каретки (CR или 0x0D (13) в ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>горизонтальная табуляция (HT или 0x09 (9) в ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>вертикальная табуляция (VT или 0x0B (11) в ASCII) (с версии PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>подача страницы (FF или 0x0C (12) в ASCII) (с версии PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>обратная косая черта</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>знак доллара</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>двойная кавычка</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        последовательность символов, соответствующая
        регулярному выражению символа в восьмеричной
        системе счисления
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        последовательность символов, соответствующая
        регулярному выражению символа в шестнадцатеричной
        системе счисления
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Как и в строке, заключенной в одинарные кавычки, экранирование любого символа
    выведет также и саму обратную косую черту. До версии PHP 5.1.1, обратная косая
    черта в <literal>\{$var}</literal> не печаталась.
   </para>

   <para>
    Но самым важным свойством строк в двойных кавычках является
    обработка переменных.
    Смотрите более подробно: <link linkend="language.types.string.parsing">обработка строк</link>
   </para>
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>

   <simpara>
    Третий способ определения строк - это использование
    heredoc-синтаксиса: <literal>&lt;&lt;&lt;</literal>. После
    этого оператора необходимо указать идентификатор,
    затем перевод строки. После этого идет сама строка,
    а потом этот же идентификатор, закрывающий вставку.
   </simpara>

   <simpara>
    Строка <emphasis>должна</emphasis> начинаться с закрывающего идентификатора,
    т.е. он должен стоять в первом столбце строки. Кроме того, идентификатор должен
    соответствовать тем же правилам именования, что и все остальные
    метки в PHP: содержать только буквенно-цифровые символы и знак
    подчеркивания, и не должен начинаться с цифры (знак подчеркивания разрешается).
   </simpara>
   
   <warning>
    <simpara>
     Очень важно отметить, что строка с закрывающим идентификатором
     не содержит других символов, за исключением,
     <emphasis>возможно</emphasis>, точки с запятой
     (<literal>;</literal>). Это означает, что идентификатор
     <emphasis>не должен вводиться с отступом</emphasis> и что не
     может быть никаких пробелов или знаков табуляции до или после
     точки с запятой. Важно также понимать, что первым символом перед
     закрывающим идентификатором должен быть символ новой строки,
     определенный в вашей операционной системе. Например, на Macintosh
     это <literal>\r</literal>. После закрывающего идентификатора (необязательно
     дополненного точкой с запятой) также сразу должна начинаться новая строка.
    </simpara>

    <simpara>
     Если это правило нарушено и закрывающий идентификатор не является
     "чистым", считается, что закрывающий идентификатор отсутствует и
     PHP продолжит его поиск дальше. Если в этом случае верный
     закрывающий идентификатор так и не будет найден, то это вызовет
     ошибку парсинга с номером строки в конце скрипта.
    </simpara>

    <para>
     Heredoc не может быть использован для инициализации полей класса.
     Начиная с версии PHP 5.3, это ограничение распространяется только на heredoc,
     содержащие внутри себя переменные.
    </para>
    
    <example>
     <title>Неверный пример</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </warning>

   <para>
    Heredoc-текст ведет себя так же, как и строка в двойных кавычках,
    при этом их не имея. Это означает, что вам нет необходимости
    экранировать кавычки в heredoc, но вы по-прежнему можете
    использовать вышеперечисленные управляющие последовательности.
    Переменные обрабатываются, но с применением сложных переменных
    внутри heredoc нужно быть также внимательным, как и при работе
    со строками.
   </para>

   <example> 
    <title>Пример определения heredoc-строки</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Пример строки,
охватывающей несколько строчек,
с использованием heredoc-синтаксиса.
EOD;

/* Более сложный пример с переменными. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'МоеИмя';

echo <<<EOT
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я вывожу {$foo->bar[1]}.
Это должно вывести заглавную букву 'A': \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
Меня зовут "МоеИмя". Я печатаю Foo.
Теперь, я вывожу Bar2.
Это должно вывести заглавную букву 'A': A]]>
   </screen>

   <para>
    Также возможно использовать heredoc-синтаксис для передачи данных
    через аргументы функции:
   </para>

   <example> 
    <title>Пример применения heredoc в аргументах</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
?>
]]>
    </programlisting>
   </example>

   <para>
    Начиная с версии 5.3.0, стала возможной инциализация статических переменных
    и свойств/констант класса с помощью синтаксиса heredoc:
   </para>

   <example> 
    <title>Использование heredoc для инциализации статических переменных</title>
    <programlisting role="php">
<![CDATA[
<?php
// Статические переменные
function foo()
{
    static $bar = <<<LABEL
Здесь ничего нет...
LABEL;
}

// Class properties/constants
class foo
{
    const BAR = <<<FOOBAR
Пример использования константы
FOOBAR;

    public $baz = <<<FOOBAR
Пример использования поля
FOOBAR;
}
?>
]]>
    </programlisting>
   </example>

   <para>
    В PHP 5.3.0 также была введена возможность использования двойных кавычек
    при объявлении идентификатора:
   </para>

   <example> 
    <title>Использование двойных кавычек в heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<"FOOBAR"
Привет, мир!
FOOBAR;
?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
      Поддержка heredoc была добавлена в PHP 4.
    </para>
   </note>

  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>
   
   <para>
    Nowdoc - это то же самое для строк в одинарных кавычках, что и
    heredoc для строк в двойных кавычках.
    Nowdoc похож на heredoc, но внутри него <emphasis>не осуществляется
    никаких подстановок</emphasis>. Эта конструкция идеальна для внедрения
    PHP-кода или других больших блоков текста без необходимости
    его экранирования. В этом он немного похож на SGML-конструкцию
    <literal>&lt;![CDATA[ ]]&gt;</literal> тем, что объявляет блок текста,
    не предназначенный для обработки.
   </para>
   
   <para>
    Nowdoc указывается той же последовательностью <literal>&lt;&lt;&lt;</literal>,
    что используется в heredoc, но последующий за ней идентификатор заключается
    в одинарные кавычки, например, <literal>&lt;&lt;&lt;'EOT'</literal>.
    Все условия, действующие для heredoc идентификаторов также действительны
    и для nowdoc, особенно те, что относятся к закрывающему идентификатору.
   </para>
   
   <example>
    <title>Пример использования nowdoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<'EOD'
Пример текста,
занимающего несколько строк,
с помощью синтаксиса nowdoc.
EOD;

/* Более сложный пример с переменными. */
class foo
{
    public $foo;
    public $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'МоеИмя';

echo <<<'EOT'
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я печатаю {$foo->bar[1]}.
Это не должно вывести заглавную 'A': \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я печатаю {$foo->bar[1]}.
Это не должно вывести заглавную 'A': \x41]]></screen>
   
   <note>
    <para>
     В отличие от heredoc, nowdoc может быть использован в любом контексте
     со статическими данными. Типичный пример инициализации полей класса
     или констант:
    </para>
    
    <example>
     <title>Пример использования статичных данных</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </note>

   <note>
    <para>
     Поддержка nowdoc была добавлена в PHP 5.3.0.
    </para>
   </note>

  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Обработка переменных</title>

   <simpara>
    Если строка указывается в двойных кавычках, либо при помощи
    heredoc, <link linkend="language.variables">переменные</link> внутри
    нее обрабатываются.
   </simpara>

   <simpara>
    Существует два типа синтаксиса:
    <link linkend="language.types.string.parsing.simple">простой</link> и
    <link linkend="language.types.string.parsing.complex">сложный</link>.
    Простой синтаксис более легок и удобен. Он дает возможность
    обработки переменной, значения массива (<type>array</type>) или
    свойства объекта (<type>object</type>) с минимумом усилий.
   </simpara>

   <simpara>
    Сложный синтаксис был введен в PHP 4 и может быть определен
    по фигурным скобкам, окружающих выражение.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.simple">
    <title>Простой синтаксис</title>

    <simpara>
     Если интерпретатор встречает знак доллара (<literal>$</literal>), он
     захватывает так много символов, сколько возможно, чтобы сформировать
     правильное имя переменной. Если вы хотите точно определить конец имени,
     заключайте имя переменной в фигурные скобки.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's taste is great"; // работает, "'" - это неверный символ для имени переменной
echo "He drank some $beers";   // не работает, 's' - это верный символ для имени переменной, но наша переменная имеет имя "$beer"
echo "He drank some ${beer}s"; // работает
echo "He drank some {$beer}s"; // работает
?>
]]>
     </programlisting>
    </informalexample>

    <simpara>
     Аналогично могут быть обработаны элемент массива
     (<type>array</type>) или свойство объекта (<type>object</type>).
     В индексах массива закрывающая квадратная скобка
     (<literal>]</literal>) обозначает конец определения индекса.
     Для свойств объекта применяются те же правила, что и для простых
     переменных.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Это специальные примеры об использовании массивов внутри
// строк. Вне строк всегда заключайте строковые ключи вашего
// массива в кавычки и не используйте {фигурные скобки} вне строк.

// Показываем все ошибки
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red', 'banana' => 'yellow');

// Работает, но заметьте, что вне кавычек строки это работает по-другому
echo "A banana is $fruits[banana].";

// Работает
echo "A banana is {$fruits['banana']}.";

// Работает, но PHP, как описано ниже, сначала ищет константу banana.
echo "A banana is {$fruits[banana]}.";

// Не работает, используйте фигурные скобки. Это вызовет ошибку обработки.
echo "A banana is $fruits['banana'].";

// Работает
echo "A banana is " . $fruits['banana'] . ".";

// Работает
echo "This square is $square->width meters broad.";

// Не работает. Для решения смотрите сложный синтаксис.
echo "This square is $square->width00 centimeters broad.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
     </programlisting>
    </informalexample>

    <simpara>
      Для чего-либо более сложного, используйте сложный синтаксис.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.complex">
    <title>Сложный (фигурный) синтаксис</title>

    <simpara>
     Он называется сложным не потому, что труден в понимании,
     а потому что позволяет использовать сложные выражения.
    </simpara>

    <simpara>
     Любая скалярная переменная, элемент массива или свойство объекта,
     отображаемое в строку, может быть представлена в строке этим синтаксисом.
     Просто запишите выражение так же, как и вне строки, а
     затем заключите его в { и }. Поскольку <literal>{</literal> не может быть
     экранирован, этот синтаксис будет распознаваться только когда <literal>$</literal>
     следует непосредственно за <literal>{</literal>. Используйте
     <literal>{\$</literal>, чтобы напечатать <literal>{$</literal>.
     Несколько поясняющих примеров:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Показываем все ошибки
error_reporting(E_ALL);

$great = 'здорово';

// Не работает, выводит: Это { здорово}
echo "Это { $great}";

// Работает, выводит: Это здорово
echo "Это {$great}";
echo "Это ${great}";

// Работает
echo "Этот квадрат шириной {$square->width}00 сантиметров.";

// Работает, ключи, заключенные в кавычки, работают только с синтаксисом фигурных скобок
echo "Это работает: {$arr['key']}";

// Работает
echo "Это работает: {$arr[4][3]}";

// Это неверно по той же причине, что и $foo[bar] вне
// строки. Другими словами, это по-прежнему будет работать,
// но поскольку PHP сначала ищет константу foo, это вызовет
// ошибку уровня E_NOTICE (неопределенная константа).
echo "Это неправильно: {$arr[foo][3]}";

// Работает. При использовании многомерных массивов внутри
// строк всегда используйте фигурные скобки
echo "Это работает: {$arr['foo'][3]}";

// Работает.
echo "Это работает: " . $arr['foo'][3];

echo "Это тоже работает: {$obj->values[3]->name}";

echo "Это значение переменной по имени $name: {${$name}}";

echo "Это значение переменной по имени, которое возвращает функция getName(): {${getName()}}";

echo "Это значение переменной по имени, которое возвращает \$object->getName(): {${$object->getName()}}";

// Не работает, выводит: Это то, что возвращает getName(): {getName()}
echo "Это то, что возвращает getName(): {getName()}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
     </programlisting>
    </informalexample>

    <para>
     С помощью этого синтаксиса также возможен доступ к свойствам объекта
     внутри строк.
    </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    var $bar = 'I am bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo->$bar}\n";
echo "{$foo->$baz[1]}\n";
?>
]]>
    </programlisting>
   &example.outputs;
   <screen>
I am bar.
I am bar.
   </screen>
   </informalexample>
    
    <note>
     <para>
      Функции, вызовы методов, статические переменные классов, а также
      константы классов работает внутри <literal>{$}</literal>, начиная
      с версии PHP 5.
      Однако, указываемое значение будет обработано как имя переменной
      в том же контексте, что и строка, в которой она определяется.
      Использование одинарных фигурных скобок (<literal>{}</literal>)
      не будет работать для доступа к значениям функций, методов,
      констант классов или статических переменных класса.
     </para>
    </note>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Показываем все ошибки
error_reporting(E_ALL);

class beers {
    const softdrink = 'rootbeer';
    public static $ale = 'ipa';
}

$rootbeer = 'A & W';
$ipa = 'Alexander Keith\'s';

// Это работает, выводит: Я бы хотел A & W
echo "Я бы хотел {${beers::softdrink}}\n";

// Это тоже работает, выводит: Я бы хотел Alexander Keith's
echo "Я бы хотел {${beers::$ale}}\n";
?>
]]>
     </programlisting>
    </informalexample>

   </sect4>
  </sect3>
  
  <sect3 xml:id="language.types.string.substr">
   <title>Доступ к символу в строке и его изменение</title>

   <para>
    Символы в строках можно использовать и модифицировать,
    определив их смещение относительно начала строки, начиная с
    нуля, в квадратных скобках после строки, например, <varname>$str[42]</varname>.
    Думайте о строке для этой цели, как о массиве символов.
    Если нужно получить или заменить более 1 символа, можно использовать
    функции <function>substr</function> и <function>substr_replace</function>.
   </para>

   <note>
    <simpara>
     К символу в строке также можно обращаться с помощью фигурных скобок,
     например, <varname>$str{42}</varname>.
    </simpara>
   </note>

   <warning>
    <simpara>
     Попытка записи в смещение за границами строки дополнит строку
     пробелами до этого смещения. Нецелые типы будет преобразованы в целые.
     Неверный тип смещения вызовет ошибку уровня <constant>E_NOTICE</constant>.
     Запись по отрицательному смещению вызовет ошибку уровня <constant>E_NOTICE</constant>,
     а при чтении вернет пустую строку.
     Используется только первый символ присваемой строки.
     Присвоение пустой строки присваивает нулевой байт (NUL).
    </simpara>
   </warning>

   <example>
    <title>Несколько примеров строк</title>
    <programlisting role="php">
<![CDATA[
<?php
// Получение первого символа строки
$str = 'This is a test.';
$first = $str[0];

// Получение третьего символа строки
$third = $str[2];

// Получение последнего символа строки
$str = 'This is still a test.';
$last = $str[strlen($str)-1]; 

// Изменение последнего символа строки
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Попытка доступа к переменным других типов (исключая массивы или
     объекты, реализующие определенные интерфейсы) с помощью <literal>[]</literal>
     или <literal>{}</literal> молча вернет &null;.
    </para>
   </note>

  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Полезные функции и операторы</title>

  <para>
   Строки могут быть объединены при помощи оператора '.' (точка).
   Обратите внимание, оператор сложения '+' <emphasis>здесь не работает</emphasis>.
   Дополнительную информацию смотрите в разделе <link
   linkend="language.operators.string">Строковые операторы</link>.
  </para>

  <para>
   Для модификации строк существует множество полезных функций.
  </para>

  <simpara>
   Основные функции описаны в разделе
   <link linkend="ref.strings">строковых функций</link>, а
   для расширенного поиска и замены - функции
   <link linkend="ref.regex">регулярных выражений</link>
   или <link linkend="ref.pcre">Perl-совместимых регулярных выражений</link>.
  </simpara>

  <simpara>
   Также существуют <link linkend="ref.url">функции для работы с URL</link>,
   и функции шифрования/дешифрования строк (<link
   linkend="ref.mcrypt">mcrypt</link> и <link
   linkend="ref.mhash">mhash</link>).
  </simpara>

  <simpara>
   Наконец, смотрите также
   <link linkend="ref.ctype">функции символьных типов</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Преобразование в строку</title>
  
  <para>
   Значение может быть преобразовано в строку, с помощью приведения
   <literal>(string)</literal>, либо функции <function>strval</function>.
   В выражениях, где необходима строка, преобразование происходит автоматически.
   Это происходит, когда вы используете функции <function>echo</function>
   или <function>print</function>, либо когда значение переменной сравнивается
   со строкой. Прочтение разделов руководства <link
   linkend="language.types">Типы</link> и <link
   linkend="language.types.type-juggling">Манипуляции с типами</link> сделает
   следующее более понятным. Смотрите также <function>settype</function>.
  </para>
  
  <para>
   Значение <type>boolean</type> &true; преобразуется в строку
   <literal>"1"</literal>, а значение &false; преобразуется в
   <literal>""</literal> (пустую строку). Это позволяет преобразовывать значения
    в обе стороны - из булева типа в строковый и наоборот.
  </para>

  <para> 
   Целое (<type>integer</type>) или число с плавающей точкой
   (<type>float</type>) преобразуется в строку, представленную числом,
   состоящим из его цифр (включая показатель степени для чисел с плавающей
   точкой). Числа с плавающей точкой могут быть преобразованы с помощью
   экспоненциального представления (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    Символ десятичной точки определяется из настроек локали текущего скрипта
    (категория LC_NUMERIC). Смотрите также <function>setlocale</function>.
   </para>
  </note>

  <para>
   Массивы всегда преобразуются в строку <literal>"Array"</literal>,
   так что вы не можете отобразить содержимое массива (<type>array</type>),
   используя <function>echo</function> или <function>print</function>,
   чтобы узнать, что он содержит. Чтобы просмотреть отдельный элемент, используйте
   что-нибудь вроде <literal>echo $arr['foo']</literal>. Смотрите
   ниже советы о том, как отобразить/просмотреть все содержимое.
  </para>

  <para>
   Объекты в PHP 4 всегда преобразовывались в строку <literal>"Object"</literal>.
   Если вы хотите вывести значения полей объекта
   (<type>object</type>) с целью отладки, читайте дальше. Если
   вы хотите получить имя класса требуемого объекта, используйте
   <function>get_class</function>. Начиная с PHP 5, также стал доступен метод
   <link linkend="language.oop5.magic">__toString</link>.
  </para>

  <para>
   Ресурсы всегда преобразуются в строки со структурой
   <literal>"Resource id #1"</literal>, где <literal>1</literal> - это
   уникальный номер ресурса (<type>resource</type>), присвоенный ему PHP
   во время выполнения. Не полагайтесь на эту структуру, она может измениться в любое время.
   Если вы хотите получить тип ресурса, используйте <function>get_resource_type</function>.
  </para>

  <para>
    &null; всегда преобразуется в пустую строку.
  </para>
  
  <para>
   Как вы могли видеть выше, прямое преобразование в строку массивов, объектов
   или ресурсов не дает никакой полезной информации о самих значениях, кроме их типов.
   Более подходящий способ вывода значений для отладки - использовать функции
   <function>print_r</function> и <function>var_dump</function>.
  </para>
  
  <para>
   Большинство значений в PHP может быть преобразовано в строку для постоянного
   хранения. Этот метод называется сериализацией и может быть выполнен
   при помощи функции <function>serialize</function>. Кроме того, если в
   вашей установке PHP есть поддержка <link linkend="ref.wddx">WDDX</link>,
   возможна также сериализация в XML-структуру.
  </para>

 </sect2>

 <sect2 xml:id="language.types.string.conversion">
  <title>Преобразование строк в числа</title>

  <simpara>
   Если строка распознается как числовое значение, результирующее значение
   и тип определяется так, как показано далее.
  </simpara>

  <simpara>
   Если строка не содержит какой-либо из символов '.', 'e', или 'E', и
   значение числа помещается в пределы целых чисел (определенных
   <constant>PHP_INT_MAX</constant>), строка будет распознана как целое число (<type>integer</type>).
   Во всех остальных случаях она считается числом с плавающей точкой (<type>float</type>).
  </simpara>

  <para>
   Значение определяется по начальной части строки. Если строка
   начинается с верного числового значения, будет использовано это
   значение. Иначе значением будет 0 (ноль). Верное числовое значение
   - это одна или более цифр (могущих содержать десятичную точку),
   по желанию предваренных знаком, с последующим необязательным
   показателем степени. Показатель степени - это 'e' или 'E' с
   последующими одной или более цифрами.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo это float (11.5)
$foo = 1 + "-1.3e3";              // $foo это float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo это integer (1)
$foo = 1 + "bob3";                // $foo это integer (1)
$foo = 1 + "10 Small Pigs";       // $foo это integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo это float (14.2)
$foo = "10.0 pigs " + 1;          // $foo это float (11)
$foo = "10.0 pigs " + 1.0;        // $foo это float (11)
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   Более подробную информацию об этом преобразовании смотрите в разделе
   о strtod(3) документации Unix.
  </simpara>

  <para>
   Если вы хотите протестировать любой из примеров этого раздела,
   скопируйте и вставьте его и следующую строку, чтобы
   увидеть, что происходит:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; тип: " . gettype ($foo) . "<br />\n";
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Не ожидайте получить код символа, преобразовав его в целое (как
   это делается, например, в C). Для преобразования символов в
   их ASCII коды и обратно используйте функции <function>ord</function>
   и <function>chr</function>.
  </para>

 </sect2>
</sect1><!-- end string -->
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
