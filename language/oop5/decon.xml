<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1.1 Maintainer: tronic Status: ready -->
<!-- $Revision: 1.3 $ -->
 <sect1 id="language.oop5.decon">
  <title>Конструкторы и деструкторы</title>
  <sect2 id="oop5-decon-constructor">
    <title>Constructor</title>
    <para>
     PHP 5 позволяет объявлять методы-конструкторы. Классы, в которых
     объявлен метод-констуктор, будут вызывать этот метод при каждом
     создании нового объекта, так что это может оказаться полезным,
     чтобы, например, инициализировать какое-либо состояние объекта
     перед его использованием.
    </para>
    <note>
     <simpara>
      Конструкторы в классах-родителях не вызываются автоматически.
      Чтобы вызвать конструктор, объявленный в родительском классе,
      следует обратиться к методу <function>parent::__construct</function>.
     </simpara>
    </note>
    <example>
     <title>Использование унифицированных конструкторов</title>
     <programlisting role="php">
<![CDATA[
<?php
class BaseClass {
    function __construct() {
        print "Конструктор класса BaseClass\n";
    }
}

class SubClass extends BaseClass {
    function __construct() {
        parent::__construct();
        print "Конструктор класса SubClass\n";
    }
}

$obj = new BaseClass();
$obj = new SubClass();
?> 
]]>
     </programlisting>
    </example>
    <para>
     Если PHP 5 не может обнаружить объявленный метод <function>__construct</function>,
     вызов конструктора произойдет по прежней схеме, через обращение к методу,
     имя которого соответствует имени класса. Может возникнуть только
     одна проблема совместимости старого кода, если в нём присутствуют
     классы с методами <function>__construct</function>.
    </para>
  </sect2>

  <sect2 id="oop5-decon-destructor">
    <title>Деструкторы</title>
    <para>
     PHP 5 предоставляет концепцию деструкторов, сходную с теми,
     что применяются в других ОО языках, таких, как Java:
     когда освобождается последняя ссылка на объект, перед высвобождением
     памяти, занимаемой этим объектом, вызывается метод
     <function>__destruct</function>, не принимающий параметров.
    </para>
    <example>
     <title>Пример использования деструктора</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyDestructableClass {
    function __construct() {
        print "Конструктор\n";
        $this->name = "MyDestructableClass";
    }

    function __destruct() {
        print "Уничтожается " . $this->name . "\n";
    }
}

$obj = new MyDestructableClass();
?> 
]]>
     </programlisting>
    </example>
    <para>
     Как и в случае с конструкторами, деструкторы, объявленные
     в родительском классе, не будут вызваны автоматически.
     Для вызова деструктора, объявленном в классе-родителе,
     следует обратиться к методу <function>parent::__destruct</function>.
    </para>
  </sect2>

 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
