<?xml version="1.0" encoding="utf-8" ?>
<!-- EN-Revision: 1.26 -->
<!-- $Revision$ -->

 <sect1 xml:id="language.oop5.basic" xmlns="http://docbook.org/ns/docbook">
  <title>Основы</title>

  <sect2 xml:id="language.oop5.basic.class">
   <title>class</title>
   <para>
    Каждое определение класса начинается с ключевого слова class, затем 
    следует имя класса, которое может быть любым именем не входящим в список
    <link linkend="reserved">зарезервированных</link> слов PHP. После идет
    пара фигурных скобок, в которых находится определение свойств и методов
    класса. Псевдо-переменная <varname>$this</varname> доступна в том случае,
    когда метод был вызван в контексте объекта. <varname>$this</varname>
    является ссылкой на вызываемый объект. Обычно это тот объект, которому
    принадлежит вызванный метод, но может быть и другой объект, если метод был
    вызван <link linkend="language.oop5.static">статически</link> из контекста
    другого объекта. Это показано на следующих примерах:
    <example>
     <title>переменная <varname>$this</varname> в объектно-ориентированном языке</title>
     <programlisting role="php">
<![CDATA[
<?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this определена (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this не определена.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo();
    }
}

$a = new A();
$a->foo();
A::foo();
$b = new B();
$b->bar();
B::bar();
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
$this определена (a)
$this не определена.
$this определена (b)
$this не определена.
]]>
     </screen>
    </example>
   </para>
   <example>
    <title>Определение класса Simple Class</title>
    <programlisting role="php">
<![CDATA[
<?php
class SimpleClass
{
    // объявление свойства
    public $var = 'значение по умолчанию';

    // объявление метода
    public function displayVar() {
        echo $this->var;
    }
}
?>
]]>
    </programlisting>
   </example>

   <para>
    Значение по умолчанию должно быть постоянным выражением и не может
    быть, например, переменной, членом класса или вызовом функции.
    <example>
     <title>Значение свойства класса по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
class SimpleClass
{
    // неправильное объявление свойств:
    public $var1 = 'hello '.'world';
    public $var2 = <<<EOD
привет, мир
EOD;
    public $var3 = 1+2;
    public $var4 = self::myStaticMethod();
    public $var5 = $myVar;

    // правильное объявление свойств:
    public $var6 = myConstant;
    public $var7 = self::classConstant;
    public $var8 = array(true, false);
    
    
}
?>
]]>
     </programlisting>   
    </example>
   </para>
   <note>
    <para>
    Тут представлены несколько полезных функций для управления классами и
    объектами. Возможно, вам будет интересно взглянуть на
    <link linkend="ref.classobj">функции Класса/Объекта</link>.
    </para>
   </note>

   <para>
    В отличии от heredocs, nowdocs могут быть использованы как статические данные в любом контексте.
    <example>
     <title>Пример использования nowdocs в контексте статических данных</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    // Для PHP 5.3.0
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Поддержка nowdocs добавлена в PHP 5.3.0.
    </para>
   </note>

  </sect2>

  <sect2 xml:id="language.oop5.basic.new">
   <title>new</title>
   <para>
    Для создания экземпляра класса новый объект должен быть создан и присвоен
    переменной. Новый объект всегда будет присвоен переменной, за
    исключением случаев, когда объект имеет <link linkend="language.oop5.decon">
    конструктор</link>, в котором определен вызов
    <link linkend="language.exceptions">исключения</link> в случае ошибки.
    Рекомендуется определять классы до создания их экземпляров 
    (в некоторых случаях это уже не рекомендуется, а требуется).
   </para>
   <example>
    <title>Создание экземпляра класса</title>
    <programlisting role="php">
<![CDATA[
<?php
$instance = new SimpleClass();
?>
]]>
    </programlisting>
   </example>
   <para>
    В контексте класса возможно создать новый объект через
    <literal>new self</literal> и <literal>new parent</literal>.
   </para>
   <para>
    Когда происходит назначение уже существующего экземпляра класса новой
    переменной, то это переменная будет иметь доступ к экземпляру класса того
    объекта, который был назначен. Это поведение будет таким же, как и в случае
    передачи экземпляра класса в функцию. Копию уже созданного объекта
    можно создать через <link linkend="language.oop5.cloning">клонирование</link>.
   </para>
   <example>
    <title>Присваивание объекта</title>
    <programlisting role="php">
<![CDATA[
<?php
$assigned   =  $instance;
$reference  =& $instance;

$instance->var = '$assigned будет иметь это значение';

$instance = null; // $instance и $reference становятся null

var_dump($instance);
var_dump($reference);
var_dump($assigned);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=>
     string(30) "$assigned будет иметь это значение"
}
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.basic.extends">
   <title>extends</title>
   <para>
    Класс может наследовать методы и свойства другого класса используя
    ключевое слово extends при декларации. Невозможно наследовать несколько
    классов, один класс может наследовать только один базовый класс.
   </para>
   <para>
    Наследуемые методы и свойства могут быть переопределены (за исключением
    случаев, когда метод класса объявлен как <link linkend="language.oop5.final">final</link>)
    путем объявления их с теми же именами, как и в родительском классе.
    Существует возможность доступа к переопределенным методам или статическим 
    методам путем обращения к ним через
    <link linkend="language.oop5.paamayim-nekudotayim">parent::</link>
   </para>
   <example>
    <title>Простое наследование класса</title>
    <programlisting role="php">
<![CDATA[
<?php
class ExtendClass extends SimpleClass
{
    // Переопределение родительского метода
    function displayVar()
    {
        echo "Расширенный класс\n";
        parent::displayVar();
    }
}

$extended = new ExtendClass();
$extended->displayVar();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Расширенный класс
значение по умолчанию
]]>
    </screen>
   </example>
  </sect2>

 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
