<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 339526 Maintainer: irker Status: ready -->
<!-- Reviewed: yes -->
<!-- $Revision$ -->
 <sect1 xml:id="language.oop5.magic" xmlns="http://docbook.org/ns/docbook">
  <title>Магические методы</title>
  <para>
   Имена методов
   <link linkend="object.construct">__construct()</link>,
   <link linkend="object.destruct">__destruct()</link>,
   <link linkend="object.call">__call()</link>,
   <link linkend="object.callstatic">__callStatic()</link>,
   <link linkend="object.get">__get()</link>,
   <link linkend="object.set">__set()</link>,
   <link linkend="object.isset">__isset()</link>,
   <link linkend="object.unset">__unset()</link>,
   <link linkend="object.sleep">__sleep()</link>,
   <link linkend="object.wakeup">__wakeup()</link>,
   <link linkend="object.tostring">__toString()</link>,
   <link linkend="object.invoke">__invoke()</link>,
   <link linkend="object.set-state">__set_state()</link>,
   <link linkend="object.clone">__clone()</link> и
   <link linkend="object.debuginfo">__debugInfo()</link>
   зарезервированы для "магических" методов в PHP.
   Не стоит называть свои методы этими именами, если вы не хотите
   использовать их "магическую" функциональность.
  </para>

  <caution>
   <simpara>
    PHP оставляет за собой право все методы, начинающиеся с __,
    считать "магическими". Не рекомендуется использовать имена
    методов с __ в PHP, если вы не желаете использовать соответствующий
    "магический" функционал.
   </simpara>
  </caution>
 
  <sect2 xml:id="language.oop5.magic.sleep">
   <title>
    <link linkend="object.sleep">__sleep()</link> и
    <link linkend="object.wakeup">__wakeup()</link>
   </title>
   
   <methodsynopsis xml:id="object.sleep">
    <modifier>public</modifier> <type>array</type><methodname>__sleep</methodname>
    <void/>
   </methodsynopsis>
   <methodsynopsis xml:id="object.wakeup">
    <type>void</type><methodname>__wakeup</methodname>
    <void/>
   </methodsynopsis>
   
   <para>
    Функция <function>serialize</function> проверяет, присутствует ли в вашем
    классе метод с "магическим" именем <link linkend="object.sleep">__sleep()</link>.
    Если это так, то этот метод выполняется прежде любой операции сериализации. Он может
    очистить объект и предполагается, что будет возвращен массив с именами
    всех переменных объекта, который должен быть сериализован.
    Если метод ничего не возвращает кроме &null;, то это значит, что объект
    сериализован и выдается предупреждение <constant>E_NOTICE</constant>.
   </para>
   <note>
    <para>
     Недопустимо возвращать в <link linkend="object.sleep">__sleep()</link>
     имена приватных свойств объекта в родительский класс. Это
     приведет к предупреждению <constant>E_NOTICE</constant>.
     Вместо этого вы можете использовать интерфейс
     <classname>Serializable</classname>.
    </para>
   </note>
   <para>
    Рекомендованное использование <link linkend="object.sleep">__sleep()</link>
    состоит в завершении работы над данными, ждущими обработки или
    других подобных задач очистки. Кроме того, этот метод можно
    выполнять в тех случаях, когда нет необходимости сохранять
    полностью очень большие объекты.
   </para>
   <para>
    С другой стороны, функция <function>unserialize</function> проверяет
    наличие метода с "магическим" именем
    <link linkend="object.wakeup">__wakeup()</link>.
    Если такой имеется, то он может воссоздать все ресурсы объекта,
    принадлежавшие ему.
   </para>
   <para>
    Обычно <link linkend="object.wakeup">__wakeup()</link>
    используется для восстановления любых соединений с базой данных,
    которые могли быть потеряны во время операции сериализации и
    выполнения других операций повторной инициализации.
   </para>
   <example>
    <title>Sleep и wakeup</title>
    <programlisting role="php">
<![CDATA[
<?php
class Connection
{
    protected $link;
    private $dsn, $username, $password;
    
    public function __construct($dsn, $username, $password)
    {
        $this->dsn = $dsn;
        $this->username = $username;
        $this->password = $password;
        $this->connect();
    }
    
    private function connect()
    {
        $this->link = new PDO($this->dsn, $this->username, $this->password);
    }
    
    public function __sleep()
    {
        return array('dsn', 'username', 'password');
    }
    
    public function __wakeup()
    {
        $this->connect();
    }
}?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.tostring">
   <title><link linkend="object.tostring">__toString()</link></title>
   <methodsynopsis xml:id="object.tostring">
    <modifier>public</modifier> <type>string</type><methodname>__toString</methodname>
    <void/>
   </methodsynopsis>
   <para>
    Метод <link linkend="object.tostring">__toString()</link> позволяет классу решать
    самостоятельно, как он должен реагировать при преобразовании в
    строку. Например, что напечатает <literal>echo $obj;</literal>. Этот метод
    должен возвращать строку, иначе выдастся неисправимая ошибка
    <constant>E_RECOVERABLE_ERROR</constant>.
   </para>
   <warning>
    <simpara>
     Нельзя бросить исключение из метода <link linkend="object.tostring">__toString()</link>.
     Попытка это сделать закончится фатальной ошибкой.
    </simpara>
   </warning>
   <example>
    <title>Простой пример</title>
    <programlisting role="php">
<![CDATA[
<?php
// Объявление простого класса
class TestClass
{
    public $foo;

    public function __construct($foo)
    {
        $this->foo = $foo;
    }

    public function __toString()
    {
        return $this->foo;
    }
}

$class = new TestClass('Привет');
echo $class;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Привет
]]>
    </screen>
   </example>
   <para>
    Ранее, до PHP 5.2.0, метод <link linkend="object.tostring">__toString()</link>
    вызывался только непосредственно в сочетании с функциями
    <function>echo</function> или <function>print</function>.
    Начиная с PHP 5.2.0, он вызывается в любом строчном контексте
    (например, в <function>printf</function> с модификатором
    <literal>%s</literal>), но не в контекстах других типов (например,
    с <literal>%d</literal> модификатором).
    Начиная с PHP 5.2.0, преобразование объекта в строку при отсутствии
    метода <link linkend="object.tostring">__toString()</link>
    вызывает ошибку <constant>E_RECOVERABLE_ERROR</constant>.
   </para>
  </sect2>

  <sect2 xml:id="language.oop5.magic.invoke">
   <title><link linkend="object.invoke">__invoke()</link></title>
   <methodsynopsis xml:id="object.invoke">
    <type>mixed</type><methodname>__invoke</methodname>
    <methodparam choice="opt"><parameter>...</parameter></methodparam>
   </methodsynopsis>
   <para>
    Метод <link linkend="object.invoke">__invoke()</link>
    вызывается, когда скрипт пытается выполнить объект как функцию.
   </para>
   <note>
    <para>
     Данный метод доступен начиная с PHP 5.3.0.
    </para>
   </note>
   <example>
    <title>Использование <link linkend="object.invoke">__invoke()</link></title>
    <programlisting role="php">
<![CDATA[
<?php
class CallableClass
{
    public function __invoke($x)
    {
        var_dump($x);
    }
}
$obj = new CallableClass;
$obj(5);
var_dump(is_callable($obj));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
int(5)
bool(true)
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.set-state">
   <title><link linkend="object.set-state">__set_state()</link></title>
   <methodsynopsis xml:id="object.set-state">
    <modifier>static</modifier> <type>object</type><methodname>__set_state</methodname>
    <methodparam><type>array</type><parameter>properties</parameter></methodparam>
   </methodsynopsis>
   <para>
    Этот <link linkend="language.oop5.static">статический</link> метод
    вызывается для тех классов, которые экспортируются функцией
    <function>var_export</function> начиная с PHP 5.1.0.
   </para>
   <para>
    Параметр этого метода должен содержать массив, состоящий из экспортируемых
    свойств в виде <literal>array('property' => value, ...)</literal>.
   </para>
   <example>
    <title>Использование <link linkend="object.set-state">__set_state()</link> (начиная с PHP 5.1.0)</title>
    <programlisting role="php">
<![CDATA[
<?php

class A
{
    public $var1;
    public $var2;

    public static function __set_state($an_array) // С PHP 5.1.0
    {
        $obj = new A;
        $obj->var1 = $an_array['var1'];
        $obj->var2 = $an_array['var2'];
        return $obj;
    }
}

$a = new A;
$a->var1 = 5;
$a->var2 = 'foo';

eval('$b = ' . var_export($a, true) . ';'); // $b = A::__set_state(array(
                                            //    'var1' => 5,
                                            //    'var2' => 'foo',
                                            // ));
var_dump($b);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(A)#2 (2) {
  ["var1"]=>
  int(5)
  ["var2"]=>
  string(3) "foo"
}
]]>
    </screen>
   </example>
   <note>
    <simpara>
     Когда вы экспортируете объект, <function>var_export</function> не проверяет
     реализует ли класс объекта метод <link linkend="object.set-state">__set_state()</link>
     , так что импорт такого объекта завершится с ошибкой в случае, если метод
     __set_state() не реализован. В частности
     это относится к некоторым встроенным классам.
    </simpara>
    <simpara>
     Необходимость проверки, реализует ли импортируемый класс метод __set_state(), полностью 
     лежит на разработчике.
    </simpara>
   </note>
  </sect2>
  
  <sect2 xml:id="language.oop5.magic.debuginfo">
   <title><link linkend="object.debuginfo">__debugInfo()</link></title>
   <methodsynopsis xml:id="object.debuginfo">
    <type>array</type><methodname>__debugInfo</methodname>
    <void/>
   </methodsynopsis>
   <para>
    Этот метод вызывается функцией <function>var_dump</function>, когда
    необходимо вывести список свойств объекта. Если этот метод не определен,
    тогда будут выведены все public, protected и private свойства объекта. 
   </para>
   <para>
    Этот метод был добавлен в PHP 5.6.0.
   </para>
   <example>
    <title>Использование <link linkend="object.debuginfo">__debugInfo()</link></title>
    <programlisting role="php">
<![CDATA[
<?php
class C {
    private $prop;

    public function __construct($val) {
        $this->prop = $val;
    }

    public function __debugInfo() {
        return [
            'propSquared' => $this->prop ** 2,
        ];
    }
}

var_dump(new C(42));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(C)#1 (1) {
  ["propSquared"]=>
  int(1764)
}
]]>
    </screen>
   </example>
  </sect2>
 </sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
