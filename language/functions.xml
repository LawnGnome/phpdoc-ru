<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.4 $ -->
<!-- EN-Revision: 1.55 Maintainer: young Status: ready -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>Функции</title>

  <sect1 xml:id="functions.user-defined">
   <title>Функции, определяемые пользователем</title>
 
   <para>
   Приведем  пример синтаксиса, используемого для описания функций:
   </para>
   <para>
    <example>
     <title>Псевдокод для демонстрации использования функций</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Example function.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <!--
    
    status of func(const $param) ?
    zend doesn't care at all whether or not you specify it.
    I've never seen it before... what's its use? (or was...)
    
    -->
     
   <simpara>
   Внутри функции можно использовать любой корректный PHP-код, 
   в том числе другие функции и даже объявления <link linkend="keyword.class">классов</link>.
   </simpara>
   <simpara>
   В PHP 3 функции должны были быть определены прежде, чем они будут 
   использованы. Начиная с PHP 4 такого ограничения нет, <emphasis>исключая</emphasis> 
   тот случай, когда функции определяются условно, как это показано
   в двух последующих примерах.
   </simpara>
   <para>
    В случае, когда функция определяется в зависимости от какого-либо условия, например,
    как это показано в двух приведенных ниже примерах, обработка описания функции
    должна <emphasis>предшествовать</emphasis> ее вызову.
   </para>
   <para>
    <example>
     <title>Функции, зависящие от условий</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Мы не можем вызвать функцию foo() в этом месте,
   поскольку она еще не определена, но мы можем 
   обратиться к bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "I don't exist until program execution reaches me.\n";
  }
}

/* Теперь мы благополучно можем вызывать foo(),
   поскольку $makefoo была интерпретирована как true */

if ($makefoo) foo();

function bar() 
{
  echo "I exist immediately upon program start.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Вложенные функции</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "I don't exist until foo() is called.\n";
  }
}

/* Мы пока не можем обратиться к bar(),
   поскольку она еще не определена. */

foo();

/* Теперь мы можем вызвать функцию bar(),
   обработка foo() сделала ее доступной. */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    PHP не поддерживает перегрузку функции, также отсутствует возможность
	переопределить или удалить объявленную ранее функцию.
   </simpara>
   <note>
    <simpara>
	 Имена функций регистронезависимы, тем не менее, более предпочтительно
	 вызывать функции так, как они были объявлены.
    </simpara>
   </note>   
   <simpara>
    PHP 3 не поддерживает переменное количество аргументов функции,
	хотя поддержка значений по умолчанию для аргументов присутствует (смотрите раздел
	<link linkend="functions.arguments.default">Значения аргументов по умолчанию</link>). 
	Начиная с 4-й версии PHP поддерживает и то, и другое: смотрите раздел
	<link linkend="functions.variable-arg-list">Списки аргументов переменной длины
    </link> и описания функций
    <function>func_num_args</function>,
    <function>func_get_arg</function>, и
    <function>func_get_args</function> для более детальной информации.
   </simpara>

  </sect1>
 
  <sect1 xml:id="functions.arguments">
   <title>Аргументы функции</title>
 
   <simpara>
    Функция может принимать информацию в виде списка аргументов,
	который является списком разделенных запятыми переменных и/или
	констант.
   </simpara> 
   <para>
    PHP поддерживает передачу аргументов по значению (по умолчанию), <link
    linkend="functions.arguments.by-reference">передачу аргументов по ссылке</link>, 
    и <link linkend="functions.arguments.default">значения по умолчанию</link>. 
	Списки аргументов переменной длины поддерживаются, начиная с PHP 4: смотрите раздел
	<link linkend="functions.variable-arg-list">Списки аргументов переменной длины
    </link> и описания функций
    <function>func_num_args</function>,
    <function>func_get_arg</function> и
    <function>func_get_args</function> для более детальной информации.
	Подобного эффекта можно достичь в PHP 3, передавая функции массив аргументов:
   </para>
   <para>
    <example>
     <title>Передача массива в функцию</title>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
 
   <sect2 xml:id="functions.arguments.by-reference">
    <title>Передача аргументов по ссылке</title>
 
    <simpara>
	 По умолчанию аргументы в функцию передаются по значению (это означает, что
	 если вы измените значение аргумента внутри функции, то вне ее значение 
	 все равно останется прежним). Если вы хотите разрешить функции
	 модифицировать свои аргументы, вы должны передавать их по ссылке.
    </simpara>
    <para>
	 Если вы хотите, что бы аргумент всегда передавался по ссылке,
	 вы можете указать амперсанд (&amp;) перед именем аргумента в описании
	 функции:
    </para>
    <para>
     <example>
      <title>Передача аргументов по ссылке</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'and something extra.';
}
$str = 'This is a string, ';
add_some_extra($str);
echo $str;    // Выведет 'This is a string, and something extra.'
?>
]]>
      </programlisting>
     </example>
    </para>
 
   </sect2>
 
   <sect2 xml:id="functions.arguments.default">
    <title>Значения аргументов по умолчанию</title>
 
    <para>
	Функция может определять значения по умолчанию в стиле C++ для
	скалярных аргументов, например:
    </para>
    <para>
     <example>
      <title>Использование значений по умолчанию в определении функции</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "cappuccino")
{
    return "Making a cup of $type.\n";
}
echo makecoffee();
echo makecoffee("espresso");
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Результат работы приведенного выше кода будет таким:
    </para>
    <para>
     <screen>
Making a cup of cappuccino.
Making a cup of espresso.
     </screen>
    </para>
    <para>  
       PHP также позволяет использовать массивы и специальный тип NULL в 
       качестве значений по умолчанию, например:
    </para>  
      <para>  
       <example>  
        <title>Использование нескалярных типов в качестве значений по умолчанию</title>  
        <programlisting role="php">  
  <![CDATA[  
  <?php  
  function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)  
  {  
      $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;  
      return "Making a cup of ".join(", ", $types)." with $device.\n";  
  }  
  echo makecoffee();  
  echo makecoffee(array("cappuccino", "lavazza"), "teapot");  
  ?>  
  ]]>  
        </programlisting>  
       </example>  
    
    </para>  
 
    <simpara>
	 Значение по умолчанию должно быть константным выражением, а не
	 (к примеру) переменной или вызовом функции/метода класса.
    </simpara>
    <para>
	 Обратите внимание, что все аргументы, для которых установлены 
	 значения по умолчанию, должны находится правее аргументов,
	 для которых значения по умолчанию не заданы, в противном случае
	 ваш код может работать не так, как вы этого ожидаете. Рассмотрим
	 следующий пример:
    </para>
    <para>
     <example>
      <title>Некорректное использование значений по умолчанию</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($type = "acidophilus", $flavour)
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt("raspberry");   // Не будет работать так, как мы могли бы ожидать
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Результат работы приведенного выше примера будет следующим:
    </para>
    <para>
     <screen>
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Making a bowl of raspberry .
     </screen>
    </para>
    <para>
     Теперь сравним эго со следующим примером:
    </para>
    <para>
     <example>
      <title>Некорректное использование значений по умолчанию</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($flavour, $type = "acidophilus")
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt("raspberry");   // отрабатывает правильно
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Теперь результат работы примера будет выглядеть так:
    </para>
    <para>
     <screen>
Making a bowl of acidophilus raspberry.
     </screen>
    </para>
     <note> 
       <simpara> 
        Начиная с PHP 5, значения по умолчанию могут быть переданны по ссылке.
       </simpara> 
      </note> 

   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>Списки аргументов переменной длины</title>
	
    <simpara>
     PHP 4 и выше поддерживает списки аргументов переменной длины для функций,
     определяемых пользователем. Реализация этой возможности достаточно прозрачна
     и заключается в использовании функций <function>func_num_args</function>,
     <function>func_get_arg</function> и
     <function>func_get_args</function>.
    </simpara>

    <simpara>
     Необходимости в специфическом синтаксисе нет, при этом список аргументов 
     также может быть указан явно и будет обладать тем же поведением.
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 xml:id="functions.returning-values">
   <title>Возврат значений</title>
 
   <para>
    Значения возвращаются при помощи необязательного оператора возврата.
    Возвращаемые значения могут быть любого типа, в том числе это могут
    быть списки и объекты. Возврат приводит к завершению выполнения функции и передаче 
    управления обратно к той строке кода, в которой данная функция была
    вызвана. Для получения более детальной информации ознакомьтесь с описанием
    функции <function>return</function>.
   </para>
   <para>
    <example>
     <title>Использование функции <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // выводит '16'.
?>
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
    Функция не может возвращать несколько значений, но аналогичного
    результата можно добиться, возвращая массив.
   </para>
   <para>
    <example>
     <title>Возврат нескольких значений в виде массива</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Для того, чтобы функция возвращала результат по ссылке, вам 
    необходимо использовать оператор &amp; и при описании функции, 
    и при присвоении переменной возвращаемого значения:
   </para>
   <para>
    <example>
     <title>Возврат результата по ссылке</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Для получения более детальной информации о ссылках обратитесь
    к разделу документации <link linkend="language.references">Подробно об указателях</link>.
   </simpara>
  </sect1>
 
  <sect1 xml:id="functions.variable-functions">
   <title>Обращение к функциям через переменные</title>

   <para>
    PHP поддерживает концепцию переменных функций. Это означает, что
    если к имени переменной присоединены круглые скобки, PHP ищет
    функцию с тем же именем, что и результат вычисления переменной, и 
    пытается ее выполнить. Эту возможность можно использовать для 
    реализации обратных вызовов, таблиц функций и множества других вещей.
   </para>
   <para>
    Переменные функции не будут работать с такими языковыми конструкциями
    как <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> и другими подобными им операторами. 
    Вам необходимо реализовывать свою функцию-обертку (wrapper) для того,
    чтобы приведенные выше конструкции могли работать с переменными
    функциями.
   </para>
   <para>
    <example>
     <title>Работа с функциями посредством переменных</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br />\n";
}

// Функция-обертка для echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Вызывает функцию foo()

$func = 'bar';
$func('test');  // Вызывает функцию bar()

$func = 'echoit';
$func('test');  // Вызыывет функцию echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Вы также можете вызвать методы объекта, используя возможности PHP 
    для работы с переменными функциями.
    <example>
     <title>Обращение к методам класса посредством переменных</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Вызываем метод Bar()
    }
    
    function Bar()
    {
        echo "This is Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // Обращаемся к $foo->Variable()

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Смотрите также <function>call_user_func</function>,
    <link linkend="language.variables.variable">Переменные переменные</link> и 
    <function>function_exists</function>.
   </para>
  </sect1>
  
  <sect1 xml:id="functions.internal">
   <title>Встроенные функции</title>
   
   <para>
    В самом PHP содержится достаточно большое количество встроенных функций
    и языковых конструкций. Также есть функции, которые требуют, чтобы PHP был
    собран со специфическими расширениями, в противном случае вы получите
    сообщение об ошибке, вызванной использованием неизвестной функции.
    Например, для того чтобы использовать <link linkend="ref.image">Функции для работы с изображениями</link>,
    например <function>imagecreatetruecolor</function>, вам необходимо собрать PHP с 
    поддержкой <productname>GD</productname>.  Или же для того, чтобы воспользоваться 
    функцией <function>mysql_connect</function>, вам необходима  поддержка модуля 
    <link linkend="ref.mysql">MySQL</link>. Тем не менее, есть много встроенных
    функций, которые доступны всегда: например <link linkend="ref.strings">Функции обработки строк</link> и
    <link linkend="ref.var">Функции для работы с переменными</link>.
    Вызвав <function>phpinfo</function> или <function>get_loaded_extensions</function>,
    вы можете узнать, поддержка каких модулей есть в используемом вами PHP.
    Также следует учесть, что поддержка некоторых дополнительных расширений 
    включена по умолчанию, и что сама документация к PHP разбита по расширениям.
    Ознакомьтесь с разделами <link linkend="configuration">Конфигурация</link>,  
    <link linkend="install">Установка</link>, а также с документацией
    непосредственно к дополнительным расширениям для получения более детальной
    информации о том, как настроить ваш PHP.
   </para>
   <para>
    Более подробную информацию о том, как следует читать и интерпретировать
    прототипы функций, вы можете найти в разделе <link linkend="about.prototypes">Как правильно 
    читать описания функций</link>. Очень важно понимать, что возвращает функция,
    или как именно она модифицирует передаваемые аргументы. Например,
    функция <function>str_replace</function> возвращает модифицированную строку,
    в то время как функция <function>usort</function> работает с фактически 
    переданной переменной. Каждая страница документации также содержит
    информацию, которая специфична для данной функции, например, информацию о 
    передаваемых параметрах, изменениях в поведении, возвращаемых
    значениях в случае как удачного, так и неудачного выполнения, доступности
    функции в различных версиях. Знание и применение этих (порой даже незаметных)
    нюансов очень важно для написания корректного PHP-кода.
   </para>
   <para>
    Ознакомьтесь также со  
    <link linkend="funcref">Справочником функций</link> и более 
    детальными описаниями функций
    <function>function_exists</function>, 
    <function>get_extension_funcs</function> и 
    <function>dl</function>.
   </para>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
