<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1.37 Maintainer: Nick Shaforostoff Status: ready -->
<!-- $Revision: 1.2 $ -->
 <chapter id="language.references">
  <title>Ссылки. Разъяснения</title>

  <sect1 id="language.references.whatare">
   <title>Что такое ссылки</title>
   <simpara>  
    Ссылки в PHP - это средство доступа к содержимому одной переменной под разными именами. Они не похожи на указатели C и не являются псевдонимами таблицы символов. В PHP имя переменной и её содержимое - это разные вещи, поэтому одно содержимое может иметь разные имена. Ближайшая аналогия - имена файлов Unix и файлы - имена переменных являются элементами каталогов, а содержимое переменных это сами файлы. Ссылки в PHP - аналог жёстких ссылок (hardlinks) в файловых системах Unix.
   </simpara>
  </sect1>

  <sect1 id="language.references.whatdo">
   <title>Что делают ссылки</title>
   <para>
    Ссылки в PHP дают возможность двум переменным ссылаться на одно содержимое. Например:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a =& $b;
?>
]]>
     </programlisting>
    </informalexample>
    означает, что <varname>$a</varname> указывает на то же содержание, что и <varname>$b</varname>.
    <note>
     <para>
      <varname>$a</varname> и <varname>$b</varname> здесь абсолютно эквивалентны, но это не означает, что $a указывает на $b или наоборот. Это означает, что $a и $b указывают на одно место.
     </para>
    </note>
   </para>
   <note>
    <para>
     При копировании массива ссылок, они не разыменовываются.
     Это также касается массивов, передаваемых функциям по значению.
    </para>
   </note>
   <para>
   Такой же синтаксис можно использовать и в функциях, возвращая ссылки, а так же в операторе <literal>new</literal> (начиная с PHP 4.0.4):
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar =& new fooclass();
$foo =& find_var($bar);
?>
]]>
    </programlisting>
    </informalexample>
    </para>
    <note>
     <para>
      Если опустить <literal>&amp;</literal>, это приведёт к копированию объекта.
      Если вы используете <literal>$this</literal> в классе, операция проводится над текущим экземпляром этого класса.
      Присвоение без <literal>&amp;</literal> приведёт к копированию экземпляра, и <literal>$this</literal> будет работать с копией, что не всегда желательно.
      Обычно, вам нужно иметь один экземпляр, из соображений производительности и использования памяти.
     </para>
     <para>
      Операция <literal>@</literal>, которая <emphasis>скрывает</emphasis> сообщения об ошибках, например в конструкторе <literal>@new</literal>, не может быть использована совместно с операцией <literal>&amp;</literal> (<literal>&amp;new</literal>).
      Это ограничение интерпретатора Zend.
     </para>
   </note>
   <warning>
    <para>
     Если переменной, объявленной внутри функции как <literal>global</literal>, будет присвоена ссылка, она будет видна только в функции.
     Чтобы избежать это, воспользуйтесь массивом <varname>$GLOBALS</varname>.
     <example>
      <title>Присвоение ссылок глобальным переменным внутри функции</title>
      <programlisting role="php">
<![CDATA[
<?php
$var1 = "Example variable";
$var2 = "";

function global_references($use_globals)
{
    global $var1, $var2;
    if (!$use_globals) {
        $var2 =& $var1; // только локально
    } else {
        $GLOBALS["var2"] =& $var1; // глобально
    }
}

global_references(false);
echo "значение var2: '$var2'\n"; // значение var2: ''
global_references(true);
echo "значение var2: '$var2'\n"; // значение var2: 'Example variable'
?>
]]>
      </programlisting>
     </example>
     Думайте о <literal>global $var;</literal> как о сокращении от <literal>$var =&amp; $GLOBALS['var'];</literal>. Таким образом, присвоение <literal>$var</literal> другой ссылки влияет лишь на локальную переменную.
    </para>
   </warning>
   <note>
    <para>
     При использовании переменной-ссылки в <link
     linkend="control-structures.foreach">foreach</link>,
     изменяется содержание, на которое она ссылается.
     <example>
      <title>Ссылки и foreach</title>
      <programlisting role="php">
<![CDATA[
<?php
$ref = 0;
$row =& $ref;
foreach (array(1, 2, 3) as $row) {
    // do something
}
echo $ref; // 3 - последнее значение, используемое в цикле
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
   <warning>
    <para>
     Сложные массивы в некоторых случаях могут копироваться вместо создания ссылок. например, следующий пример не будет работать как ожидалось.
     <example>
      <title>Ссылки и сложные массивы</title>
      <programlisting role="php">
<![CDATA[
<?php
$top = array(
    'A' => array(),
    'B' => array(
        'B_b' => array(),
    ),
);

$top['A']['parent'] = &$top;
$top['B']['parent'] = &$top;
$top['B']['B_b']['data'] = 'test';
print_r($top['A']['parent']['B']['B_b']); // array()
?>
]]>
      </programlisting>
     </example>
    </para>
   </warning>
   <para>
    Второе, что делают ссылки - передача параметров по ссылке.
    При этом локальная переменная в функции и переменная в области видимости вызывателя ссылаются на одно и то же содержимое.
    Пример:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var)
{
    $var++;
}

$a=5;
foo($a);
?>
]]>
     </programlisting>
    </informalexample>
    Этот код присвоит <varname>$a</varname> значение 6. Это происходит, потому что в функции <varname>foo</varname> переменная <varname>$var</varname> ссылается на то же содержимое, что и переменная <varname>$a</varname>. См. также детальное объяснение <link
    linkend="language.references.pass">передачи по ссылке</link>.
   </para>
   <simpara>
    Третье, что могут ссылк - <link
    linkend="language.references.return">возвращение значение по ссылке</link>.
   </simpara>
  </sect1>

  <sect1 id="language.references.arent">
   <title>Чем ссылки не являются</title>
   <para>
    Как уже было сказано, ссылки не являются указателями. Это означает, что следующая конструкция не будет делать то, что вы ожидаете:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var)
{
    $var =& $GLOBALS["baz"];
}
foo($bar); 
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Переменная <varname>$var</varname> в фукнции     <varname>foo</varname> будет связана с <varname>$bar</varname> в вызывателе, но затем она будет перепривязана к <varname>$GLOBALS["baz"]</varname>.
    Нет способа связать <varname>$bar</varname> в области видимости вызывателя с чем-либо ещё путём использования механизма ссылок, поскольку <varname>$bar</varname> не доступна в функции <varname>foo</varname> (доступно лишь её значение через 
    <varname>$var</varname>).
    Вы можете воспользоваться <link linkend="language.references.return">возвращением ссылок</link> из функции для привязки внешней перменной к другому значению.
   </simpara>
  </sect1>

  <sect1 id="language.references.pass">
   <title>Передача по ссылке</title>
   <para>
   Вы можете передавать переменные в функцию по ссылке, и функция сможет изменять свои аргументы. Синтаксис таков:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var)
{
    $var++;
}

$a=5;
foo($a);
// $a здесь равно 6
?>
]]>
     </programlisting>
    </informalexample>
  Заметьте, что в вызове функции отсутствует знак ссылки - он есть только в определении функции. Этого достаточно для корректной передачи аргументов по ссылке.
  </para>
  <para>
  По ссылке можно передавать:
   <itemizedlist>
    <listitem>
     <simpara>
      Переменные, например <literal>foo($a)</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Оператор new, например <literal>foo(new foobar())</literal>
     </simpara>
    </listitem>
    <listitem>
     <para>
      Ссылки, возвращаемые функцией, например:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function &bar()
{
    $a = 5;
    return $a;
}
foo(bar());
?>
]]>
     </programlisting>
    </informalexample>
    См. также объяснение <link
    linkend="language.references.return">возвращения по ссылке</link>. 
     </para>
    </listitem>
  </itemizedlist>
  </para>
  <para>
  Любое другое выражение не должно передаваться по ссылке, так как результат не определён. Например, следующая передача по ссылке является неправильной:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function bar() // Операция & отсутствует
{
    $a = 5;
    return $a;
}
foo(bar());

foo($a = 5); // Выражение, а не переменная
foo(5); // Константа, а не переменная
?>
]]>
     </programlisting>
    </informalexample>
    Эти требования для PHP 4.0.4 и позже.
  </para>
  </sect1>

  <sect1 id="language.references.return">
   <title>Возвращение по ссылке</title>
   <para>
    Возвращение по ссылке используется в тех случаях, когда вы хотите использовать функцию для выбора переменной, с которой должна быть связана данная ссылка. При возвращении по ссылке используйте такой синтаксис:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function &find_var($param)
{
    /* ... код ... */
    return $found_var;
}

$foo =& find_var($bar);
$foo->x = 2;
?>
]]>
     </programlisting>
    </informalexample>
    В этом примере устанавливается свойство объекта, возвращённого функцией <varname>find_var</varname>, а не его копии, как было бы без использования ссылок.
   </para>
   <note>
    <simpara>
     В отличие от передачи параметров по ссылке, <literal>&amp;</literal> здесь нужно использовать в обоих местах - для указания на то, что вы возвращаете ссылку, а не копию, как обычно, и для указания того, что происходит связывание по ссылке, а не обычное присвоение.
    </simpara>
   </note>
  </sect1>

  <sect1 id="language.references.unset">
   <title>Сброс переменных-ссылок</title>
   <para>
    При сбросе ссылки, просто разрывается связь имени и содержимого переменной. Это не означает, что содержимое переменной будет разрушено. Например:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b =& $a;
unset($a); 
?>
]]>
     </programlisting>
    </informalexample>
    Этот код не сбросит <varname>$b</varname>, а только  <varname>$a</varname>. 
   </para>
   <simpara>
    Опять же, можно провести аналогию с вызовом
    <command>unlink</command> (в Unix).
   </simpara>
  </sect1>

  <sect1 id="language.references.spot">
   <title>Неявное использование механизма ссылок</title>
   <simpara>
    Многие синтаксические конструкции PHP реализованы через механизм ссылок, поэтому всё сказанное выше о ссылочном связывании применимо также и к этим конструкциям. Некоторые конструкции, вроде передающих и возвращающих по ссылке, рассмотрены ранее. Другие конструкции, использующие ссылки:
   </simpara>

   <sect2 id="references.global">
    <title>Ссылки <literal>global</literal></title>
    <para>
     Если вы объявляете переменную как <command>global $var</command>, вы фактически создаёте ссылку на глобальную переменную. Это означает то же самое, что:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var =& $GLOBALS["var"];
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Это значит, например, что сброс (unset) <varname>$var</varname> не приведёт к сбросу глобальной переменной.
    </simpara>
   </sect2>

   <sect2 id="references.this">
    <title><literal>$this</literal></title>
    <simpara>
     В методах объекта, <varname>$this</varname> всегда является ссылкой на вызывающий объект.
    </simpara>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
