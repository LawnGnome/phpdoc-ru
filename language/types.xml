<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1.138 Maintainer: Kai Status: ready -->
<!-- $Revision: 1.9 $ -->
 <chapter id="language.types">
  <title>Типы</title>

  <sect1 id="language.types.intro">
  <title>Введение</title>
  
  <simpara>
   PHP поддерживает восемь простых типов.
  </simpara>
  
  <para>
   Четыре скалярных типа:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>boolean</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>integer</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>float</type> (число с плавающей точкой или '<type>double</type>')
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>string</type>
     </simpara>
    </listitem>

   </itemizedlist>

   Два смешанных типа:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>array</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>object</type>
     </simpara>
    </listitem>

   </itemizedlist>

   И, наконец, два специальных типа:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>resource</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>NULL</type>
     </simpara>
    </listitem>

   </itemizedlist>

   Для удобства понимания в этом руководстве используется также несколько
   <link linkend="language.pseudo-types">псевдо-типов</link>:

   <itemizedlist>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">mixed</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.number">number</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">callback</link>
     </simpara>
    </listitem>

   </itemizedlist>
   Вы также можете найти несколько упоминаний типа двойной точности.
   Рассматривайте его как число с плавающей точкой, два имени существуют только
   по историческим причинам.
  </para>
  
  <simpara>
   Как правило, программист не устанавливает тип переменной;
   предпочтительнее, чтобы это делал PHP во время выполнения программы в
   зависимости от контекста, в котором используется переменная.
  </simpara>
  <note>
   <simpara>
    Если вы желаете проверить тип и значение определенного <link
     linkend="language.expressions">выражения</link>, используйте
    <function>var_dump</function>.
   </simpara>
   <para>
    Если же вам для отладки необходимо просто удобочитаемое представление
    типа, используйте <function>gettype</function>. Чтобы проверить на
    определенный тип, <emphasis>не</emphasis> используйте <function>gettype</function>,
    применяйте для этого <literal>is_<replaceable>type</replaceable></literal>
    функции. Вот несколько примеров:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // логический
$str  = "foo";  // строковый
$int  = 12;     // целочисленный

echo gettype($bool); // выводит "boolean"
echo gettype($str);  // выводит "string"

// Если это целое, увеличить на четыре
if (is_int($int)) {
    $int += 4;
}

// Если $bool - это строка, вывести ее
// (ничего не выводит)
if (is_string($bool)) {
    echo "Строка: $bool";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>
  <simpara>
   Если вы хотите принудительно изменить тип переменной, вы можете либо
   <link linkend="language.types.typecasting">привести</link>
   переменную, либо использовать функцию <function>settype</function>.
  </simpara>
  <simpara>
   Обратите внимание, что переменная, в зависимости от ее типа в данный
   момент, в определенных ситуациях может иметь разные значения.
   Более подробную информацию смотрите в разделе <link
   linkend="language.types.type-juggling">Манипуляции с типами</link>.
   Также вам, возможно, будет интересно посмотреть
   <link linkend="types.comparisons">таблицы сравнения типов</link>,  
   поскольку в них приведены примеры связанных сравнений различных
   типов.
  </simpara>
 </sect1>
   
   <sect1 id="language.types.boolean">
    <title>Булев</title>
    
    <simpara>
     Это простейший тип. Он выражает истинность значения - это может
     быть либо &true;, либо &false;. 
    </simpara>

    <note>
     <simpara>
      Булев тип был введен в PHP 4.
     </simpara>
    </note>

    <sect2 id="language.types.boolean.syntax">
     <title>Синтаксис</title>
     <para>
      Чтобы определить булев тип, используйте ключевое слово &true; 
      или &false;. Оба регистро-независимы.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo = True; // присвоить $foo значение TRUE
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Обычно вы используете некий
      <link linkend="language.operators">оператор</link>,
      который возвращает логическое выражение, а затем предает его
      <link linkend="language.control-structures">управляющей конструкции</link>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// == это оператор, который проверяет
// эквивалентность и возвращает булево значение
if ($action == "показать_версию") {
    echo "Версия 1.23";
}

// это не обязательно...
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// ...потому что вы можете просто написать
if ($show_separators) {
    echo "<hr>\n";
}
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>Преобразование в булев тип</title>
      <simpara>
       Для несомненного преобразования значения в булев тип используйте приведение
       типа <literal>(bool)</literal> или <literal>(boolean)</literal>.
       Однако в большинстве случаев вам нет необходимости использовать приведение типа,
       поскольку значение будет автоматически преобразовано, если оператор, функция или 
       управляющая конструкция требует булев аргумент.
      </simpara>
      <simpara>
       Смотрите также <link linkend="language.types.type-juggling">Манипуляции с типами</link>.
      </simpara>
      
      <para>
       При преобразовании в логический тип, следующие значения
       рассматриваются как &false;:
  
       <itemizedlist>
        <listitem>
         <simpara>Сам <link linkend="language.types.boolean">булев</link> 
          &false;</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.integer">целое</link
         > 0 (ноль) </simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.float">число с плавающей точкой</link> 
         0.0 (ноль) </simpara>
        </listitem>
        <listitem>
         <simpara>пустая <link linkend="language.types.string"
           >строка</link> и <link linkend="language.types.string"
           >строка</link>
           "0"</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.array">массив</link> 
         с нулевыми элементами</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.object">объект</link> 
         с нулевыми переменными-членами</simpara>
        </listitem>
        <listitem>
         <simpara>специальный тип <link linkend="language.types.null"
           >NULL</link> (включая неустановленные переменные)
         </simpara>
        </listitem>
       </itemizedlist>
       
       Все остальные значения рассматриваются как &true; (включая 
       любой <link linkend="language.types.resource">ресурс</link>).
       <warning>
        <simpara>
         <literal>-1</literal> считается &true;, как и любое
         ненулевое (отрицательное или положительное) число!
        </simpara>
       </warning>
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
var_dump((bool) "");        // bool(false)
var_dump((bool) 1);         // bool(true)
var_dump((bool) -2);        // bool(true)
var_dump((bool) "foo");     // bool(true)
var_dump((bool) 2.3e5);     // bool(true)
var_dump((bool) array(12)); // bool(true)
var_dump((bool) array());   // bool(false)
var_dump((bool) "false");   // bool(true)
?>
]]>
        </programlisting>
       </informalexample>
      </para>
     </sect2>
   </sect1>

   <sect1 id="language.types.integer">
    <title>Целые</title>
    
    <simpara>
     Целое это число из множества Z = {..., -2, -1, 0, 1, 2, ...}.
    </simpara>
     
    <para>
     Смотрите также:
     <link linkend="ref.gmp">Целые произвольной длины / GMP</link>,
     <link linkend="language.types.float">Числа с плавающей точкой</link> и
     <link linkend="ref.bc">Произвольная точность / BCMath</link>
    </para>

    <sect2 id="language.types.integer.syntax">
     <title>Синтаксис</title>
     <simpara>
      Целые могут быть указаны в десятичной, шестнадцатеричной или
      восьмеричной системе счисления, по желанию с предшествующим знаком (- или +).
     </simpara>
     <para>
      Если вы используете восьмеричную систему счисления, вы должны
      предварить число <literal>0</literal> (нулем), для использования
      шестнадцатеричной системы нужно поставить перед числом <literal>0x</literal>.
      <example>
       <title>Целые</title>
       <programlisting role="php">
<![CDATA[
<?php
$a = 1234; // десятичное число
$a = -123; // отрицательное число
$a = 0123; // восьмеричное число (эквивалентно 83 в десятичной системе)
$a = 0x1A; // шестнадцатеричное число (эквивалентно 26 в десятичной системе)
?>
]]>
       </programlisting>
      </example>
      Формально возможная структура целых такова:
      <informalexample>
       <programlisting>
<![CDATA[
десятичные        : [1-9][0-9]*
                  | 0

шестнадцатеричные : 0[xX][0-9a-fA-F]+

восьмеричные      : 0[0-7]+

целые             : [+-]?десятичные
                  | [+-]?шестнадцатеричные
                  | [+-]?восьмеричные
]]>
       </programlisting>
      </informalexample>
      Размер целого зависит от платформы, хотя, как правило,
      максимальное значение около двух миллиардов
      (это 32-битное знаковое). PHP не поддерживает беззнаковые целые.
     </para>
    </sect2>
   
    <sect2 id="language.types.integer.overflow">
     <title>Превышение размера целого</title>
     <para>
      Если вы определите число, превышающее пределы целого типа, оно будет
      интерпретировано как число с плавающей точкой. Также, если вы
      используете оператор, результатом работы которого будет число,
      превышающее пределы целого, вместо него будет возвращено число с
      плавающей точкой.

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$large_number =  2147483647;
var_dump($large_number);
// вывод: int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// вывод: float(2147483648)

// это справедливо и для шестнадцатеричных целых:
var_dump( 0x80000000 );
// вывод: float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// вывод: float(50000000000)
?>
]]>
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        К сожалению, в PHP была ошибка, так что это не всегда верно
        работает, когда используются отрицательные числа.
        Например: когда вы умножаете <literal>-50000 *
        $million</literal>, результатом будет
        <literal>-429496728</literal>. Однако, если оба операнда
        положительны, проблем не возникает.
       </simpara>
       <simpara>
        Эта ошибка устранена в PHP 4.1.0.
       </simpara>
      </warning>
     </para>
     <para>
      в PHP не существует оператора деления целых.
      Результатом <literal>1/2</literal> будет число с плавающей точкой
      <literal>0.5</literal>. Вы можете привести значение к целому, что
      всегда округляет его в меньшую сторону, либо использовать функцию
      <function>round</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286) 
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4)
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>
   

    <sect2 id="language.types.integer.casting">
     <title>Преобразование в целое</title>
      <simpara>
       Для несомненного преобразования значения в целое используйте приведение
       типа <literal>(int)</literal> или <literal>(integer)</literal>.
       Однако в большинстве случаев вам нет необходимости использовать приведение типа,
       поскольку значение будет автоматически преобразовано, если оператор, функция или 
       управляющая конструкция требует целый аргумент. Вы также можете преобразовать
       значение в целое при помощи функции <function>intval</function>.
      </simpara>
      <simpara>
       Смотрите также <link linkend="language.types.type-juggling">Манипуляции с типами</link>.
      </simpara>
      
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>Из <link linkend="language.types.boolean"
           >булева</link> типа</title>
       <simpara>
        &false; преобразуется в
        <literal>0</literal> (ноль), а &true; 
        - в <literal>1</literal> (единицу).
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title>Из <link linkend="language.types.float">чисел с плавающей точкой</link></title> 
       <simpara>
        При преобразовании из числа с плавающей точкой в целое, число будет
        округлено <emphasis>в сторону нуля</emphasis>.
       </simpara>
       
       <para>
        Если число с плавающей точкой превышает пределы целого
        (как правило, это <literal>+/- 2.15e+9 = 2^31</literal>), 
        результат будет неопределенным, так как целое не имеет достаточной
        точности, чтобы вернуть верный результат. В этом случае не будет
        выведено ни предупреждения, ни даже замечания!
       </para>
       
       <warning><para>
        Никогда не приводите неизвестную дробь к целому, так как это
        может иногда дать неожиданные результаты.
        <informalexample>
         <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // выводит 7!
?>
]]>
         </programlisting>
        </informalexample>
        
        Смотрите более подробно: <link 
        linkend="warn.float-precision">предупреждение о точности
        чисел с плавающей точкой</link>.
       </para></warning>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-string">
       <title>Из строк</title>
       <simpara>
        Смотрите <link linkend="language.types.string.conversion">Преобразование
        строк в числа</link>
       </simpara>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-other">
       <title>Из других типов</title>
       <para>
        <caution>
         <simpara>
          Для других типов поведение преобразования в целое не определено.
          В настоящее время поведение такое же, как если бы значение
          сперва было <link linkend="language.types.boolean.casting"
          >преобразовано в булев тип</link>. Однако
          <emphasis>не</emphasis> полагайтесь на это поведение, так
          как он может измениться без предупреждения.
         </simpara>
        </caution>
       </para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>Числа с плавающей точкой</title>
   <para>
    Числа с плавающей точкой (они же числа двойной точности или
    действительные числа) могут быть определены при помощи любого
    из следующих синтаксисов:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1.234;
$b = 1.2e3;
$c = 7E-10;
?>  
]]> 

     </programlisting>
    </informalexample>
    Формально:
    <informalexample>
     <programlisting role="php">
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
     </programlisting>
    </informalexample>
    Размер целого зависит от платформы, хотя максимум, как правило,
    ~1.8e308 с точностью около 14 десятичных цифр (это 64-битный
    IEEE-формат).
   </para>
 
   <warning id="warn.float-precision">
    <title>Точность числа с плавающей точкой</title>
    <para>
     Довольно часто простые десятичные дроби вроде
     <literal>0.1</literal> или <literal>0.7</literal> не могут быть
     преобразованы в свои внутренние двоичные аналоги без небольшой
     потери точности. Это может привести к неожиданным результатам:
     например, <literal>floor((0.1+0.7)*10)</literal> скорее всего
     возвратит <literal>7</literal> вместо ожидаемой
     <literal>8</literal> как результат внутреннего представления
     числа, являющегося в действительности чем-то вроде <literal>7.9999999999...</literal>.
    </para>
    <para>
     Это связано с невозможностью точно выразить некоторые дроби в
     десятичной системе счисления конечным числом цифр. Например,
     <literal>1/3</literal> в десятичной форме принимает вид
     <literal>0.3333333. . .</literal>.
    </para>
    <para>
     Так что никогда не доверяйте точности последних цифр в результатах
     с числами с плавающей точкой и никогда не проверяйте их на
     равенство. Если вам действительно необходима высокая точность, вам
     следует использовать <link
     linkend="ref.bc">математические функции произвольной точности</link>
     или <link linkend="ref.gmp">gmp</link>-функции.
    </para>
   </warning>

   <sect2 id="language.types.float.casting">
    <title>Преобразование в число с плавающей точкой</title>
    
    <para>
     О том, когда и как строки преобразуются в числа с плавающей точкой
     читайте в разделе <link linkend="language.types.string.conversion">Преобразование
     строк в числа</link>. Для значений других типов преобразование будет
     таким же, как если бы значение сначала было преобразовано в целое,
     а затем в число с плавающей точкой. Дополнительную информацию
     смотрите в разделе <link linkend="language.types.integer.casting">Преобразование
     в целое</link>.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.string">
   <title>Строки</title>
   <para>
    Строка - это набор символов. В PHP символ это то же самое, что
    и байт, это значит, что возможно ровно 256 различных символов.
    Это также означает, что PHP не имеет встроенной поддержки
    Unicode'а. Некоторую поддержку Unicode'а обеспечивают функции
    <function>utf8_encode</function> и
    <function>utf8_decode</function>.
   </para>
   <note>
    <simpara>
     Нет никаких проблем, если строка очень велика. Практически
     не существует ограничений на размер строк, налагаемых PHP,
     так что нет абсолютно никаких причин беспокоиться об их
     длине.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>Синтаксис</title>
    <para>
     Строка может быть определена тремя различными способами.
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">одинарными кавычками</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">двойными кавычками</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">heredoc-синтаксисом</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>Одинарные кавычки</title>
     <para>
      Простейший способ определить строку - это заключить ее в
      одинарные кавычки (символ <literal>'</literal>). 
     </para>
     <para>
      Чтобы использовать одинарную кавычку внутри строки,
      как и во многих других языках, ее необходимо предварить
      символом обратной косой черты (<literal>\</literal>),
      т. е. экранировать ее. Если обратная косая черта
      должна идти перед одинарной кавычкой либо быть в конце
      строки, вам необходимо продублировать ее. Обратите
      внимание, что если вы попытаетесь экранировать любой
      другой символ, обратная косая черта также будет напечатана!
      Так что, как правило, нет необходимости экранировать
      саму обратную косую черту.
      <note>
       <simpara>
        В PHP 3 в данном случае будет выдано сообщение уровня
        <literal>E_NOTICE</literal>.
       </simpara>
      </note>
      <note>
       <simpara>
        В отличие от двух других синтаксисов,
        <link linkend="language.variables">переменные</link> и
        экранирующие последовательности для специальных
        символов, встречающиеся в строках, заключенных в
        одинарные кавычки, <emphasis>не</emphasis>
        обрабатываются.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo 'это простая строка';

echo 'Также вы можете вставлять в строки
символ новой строки таким образом,
поскольку это нормально';

// Выведет: Однажды Арнольд сказал: "I'll be back"
echo 'Однажды Арнольд сказал: "I\'ll be back"';

// Выведет: Вы удалили C:\*.*?
echo 'Вы удалили C:\\*.*?';

// Выведет: Вы удалили C:\*.*?
echo 'Вы удалили C:\*.*?';

// Выведет: Это не вставит: \n новую строку
echo 'Это не вставит: \n новую строку';

// Выведет: Переменные $expand также $either не подставляются
echo 'Переменные $expand также $either не подставляются';
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>Двойные кавычки</title>
     <para>
      Если строка заключена в двойные кавычки ("), PHP распознает
      большее количество управляющих последовательностей для
      специальных символов:
     </para>
     <table>
      <title>Управляющие последовательности</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>последовательность</entry>
         <entry>значение</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>новая строка (LF или 0x0A (10) в ASCII)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>возврат каретки (CR или 0x0D (13) в ASCII)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>горизонтальная табуляция (HT или 0x09 (9) в ASCII)</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>обратная косая черта</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>знак доллара</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>двойная кавычка</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          последовательность символов, соответствующая
          регулярному выражению, символ в восьмеричной
          системе счисления
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          последовательность символов, соответствующая
          регулярному выражению, символ в шестнадцатеричной
          системе счисления
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Повторяем, если вы захотите мнемнонизировать любой другой
      символ, обратная косая черта также будет напечатана!
     </para>
     <para>
      Но самым важным свойством строк в двойных кавычках является
      обработка переменных.
      Смотрите более подробно: <link linkend="language.types.string.parsing">обработка 
      строк</link>.
     </para>
    </sect3>
    
    <sect3 id="language.types.string.syntax.heredoc">
     <title>Heredoc</title>
     <simpara>
      Другой способ определения строк - это использование
      heredoc-синтаксиса ("&lt;&lt;&lt;"). После
      <literal>&lt;&lt;&lt;</literal> необходимо указать идентификатор,
      затем идет строка, а потом этот же идентификатор, закрывающий вставку. 
     </simpara>
     <simpara>
      Закрывающий идентификатор <emphasis>должен</emphasis> начинаться в
      первом столбце строки. Кроме того, идентификатор должен
      соответствовать тем же правилам именования, что и все остальные
      метки в PHP: содержать только буквенно-цифровые символы и знак
      подчеркивания, и должен начинаться с нецифры или знака подчеркивания.
     </simpara>
     
     <warning>
      <simpara>
       Очень важно отметить, что строка с закрывающим идентификатором
       не содержит других символов, за исключением,
       <emphasis>возможно</emphasis>, точки с запятой
       (<literal>;</literal>). Это означает, что идентификатор
       <emphasis>не должен вводиться с отступом</emphasis> и что не
       может быть никаких пробелов или знаков табуляции до или после
       точки с запятой. Важно также понимать, что первым символом перед
       закрывающим идентификатором должен быть символ новой строки,
       определенный в вашей операционной системе. Например, на Macintosh
       это <literal>\r</literal>.
      </simpara>
      <simpara>
       Если это правило нарушено и закрывающий идентификатор не является
       "чистым", считается, что закрывающий идентификатор отсутствует и
       PHP продолжит его поиск дальше. Если в этом случае верный
       закрывающий идентификатор так и не будет найден, то это вызовет
       ошибку в обработке с номером строки в конце скрипта.
      </simpara>
     </warning>

     <para>
      Heredoc-текст ведет себя так же, как и строка в двойных кавычках,
      при этом их не имея. Это означает, что вам нет необходимости
      экранировать кавычки в heredoc, но вы по-прежнему можете
      использовать вышеперечисленные управляющие последовательности.
      Переменные обрабатываются, но с применением сложных переменных
      внутри heredoc нужно быть также внимательным, как и при работе
      со строками.
      <example> 
       <title>Пример определения heredoc-строки</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Пример строки,
охватывающей несколько строчек,
с использованием heredoc-синтаксиса.
EOD;

/* Более сложный пример с переменными. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'МоеИмя';

echo <<<EOT
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я вывожу {$foo->bar[1]}.
Это должно вывести заглавную букву 'A': \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>
  
     <note>
      <para>
       Поддержка heredoc была добавлена в PHP 4.
      </para>
     </note>
    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>Обработка переменных</title>
     <simpara>
      Если строка определяется в двойных кавычках, либо при помощи
      heredoc, <link linkend="language.variables">переменные</link> внутри
      нее обрабатываются.
     </simpara>
     <simpara>
      Существует два типа синтаксиса:
      <link linkend="language.types.string.parsing.simple">простой</link> и
      <link linkend="language.types.string.parsing.complex">сложный</link>.
      Простой синтаксис более легок и удобен. Он дает возможность
      обработки переменной, значения массива (<type>array</type>) или
      свойства объекта (<type>object</type>).
     </simpara>
     <simpara>
      Сложный синтаксис был введен в PHP 4 и может быть распознан
      по фигурным скобкам, окружающих выражение.
     </simpara>

     <sect4 id="language.types.string.parsing.simple">
      <title>Простой синтаксис</title>
      <simpara>
       Если интерпретатор встречает знак доллара (<literal>$</literal>), он
       захватывает так много символов, сколько возможно, чтобы сформировать
       правильное имя переменной. Если вы хотите точно определить конец имени,
       заключайте имя переменной в фигурные скобки.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's taste is great"; // работает, "'" это неверный символ для имени переменной
echo "He drank some $beers";   // не работает, 's' это верный символ для имени переменной
echo "He drank some ${beer}s"; // работает
echo "He drank some {$beer}s"; // работает
?>
]]>
       </programlisting>
      </informalexample>
      <simpara>
       Точно также могут быть обработаны элемент массива
       (<type>array</type>) или свойство объекта (<type>object</type>).
       В индексах массива закрывающая квадратная скобка
       (<literal>]</literal>) обозначает конец определения индекса.
       Для свойств объекта применяются те же правила, что и для простых
       переменных, хотя с ними невозможен трюк, как с переменными.
       
       <!-- XXX isn't &true; :(, this would be the trick
       Also, the same trick with curly-braces works if you
       want to limit the greediness of parsers.
       -->
      
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Эти примеры специфически об использовании массивов внутри
// строк. Вне строк всегда заключайте строковые ключи вашего
// массива в кавычки и не используйте вне строк {скобки}.

// Давайте покажем все ошибки
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red', 'banana' => 'yellow');

// Работает, но заметьте, что вне кавычек строки это работает по-другому
echo "A banana is $fruits[banana].";

//Работает
echo "A banana is {$fruits['banana']}.";

// Работает, но PHP, как описано ниже, сначала ищет
// константу banana.
echo "A banana is {$fruits[banana]}.";

// Не работает, используйте фигурные скобки. Это вызовет ошибку обработки.
echo "A banana is $fruits['banana'].";

// Работает
echo "A banana is " . $fruits['banana'] . ".";

// Работает
echo "This square is $square->width meters broad.";

// Не работает. Для решения см. сложный синтаксис.
echo "This square is $square->width00 centimeters broad.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       Для чего-либо более сложного вы должны использовать сложный синтаксис.
      </simpara>
     </sect4>

     <sect4 id="language.types.string.parsing.complex">
      <title>Сложный (фигурный) синтаксис</title>
      <simpara>
       Он называется сложным не потому, что труден в понимании,
       а потому что позволяет использовать сложные выражения.
     </simpara>
     <simpara>
      Фактически, вы можете включить любое значение, находящееся в
      пространстве имени в строке с этим синтаксисом. Вы просто
      записываете выражение таким же образом, как и вне строки, а
      затем заключаете его в { и }. Поскольку вы не можете экранировать
      '{', этот синтаксис будет распознаваться только когда $ следует
      непосредственно за {. (Используйте "{\$" или "\{$" чтобы
      отобразить "{$"). Несколько поясняющих примеров:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Давайте покажем все ошибки
error_reporting(E_ALL);

$great = 'fantastic';

// Не работает, выведет: This is { fantastic}
echo "This is { $great}";

// Работает, выведет: This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// Работает
echo "Этот квадрат шириной {$square->width}00 сантиметров.";

// Работает
echo "Это работает: {$arr[4][3]}";

// Это неверно по той же причине, что и $foo[bar] неверно вне
// строки. Другими словами, это по-прежнему будет работать,
// но поскольку PHP сначала ищет константу foo, это вызовет
// ошибку уровня E_NOTICE (неопределенная константа).
echo "Это неправильно: {$arr[foo][3]}";

// Работает. При использовании многомерных массивов, внутри
// строк всегда используйте фигурные скобки
echo "Это работает: {$arr['foo'][3]}";

// Работает.
echo "Это работает: " . $arr['foo'][3];

echo "Вы даже можете записать {$obj->values[3]->name}";

echo "Это значение переменной по имени $name: {${$name}}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>Доступ к символу в строке и его изменение</title>
     <para>
      Символы в строках можно использовать и модифицировать,
      определив их смещение относительно начала строки, начиная с
      нуля, в фигурных скобках после строки.
     </para>
     <note>
      <simpara>
       Для обеспечения обратной совместимости, вы по-прежнему имеете
       возможность использовать в тех же целях скобки массива.
       Однако, начиная с PHP 4, этот синтаксис нежелателен к
       использованию.
      </simpara>
     </note>
     <para>
      <example>
       <title>Несколько примеров строк</title>
       <programlisting role="php">
<![CDATA[
<?php
// Получение первого символа строки
$str = 'Это тест.';
$first = $str{0};

// Получение третьего символа строки
$third = $str{2};

// Получение последнего символа строки
$str = 'Это все еще тест.';
$last = $str{strlen($str)-1};

// Изменение последнего символа строки
$str = 'Посмотри на море';
$str{strlen($str)-1} = 'я';

?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>Полезные функции и операторы</title>
    <para>
     Строки могут быть объединены при помощи оператора '.' (точка).
     Обратите внимание, оператор сложения '+' здесь не работает.
     Дополнительную информацию смотрите в разделе <link
     linkend="language.operators.string">Строковые операторы</link>.
    </para>
    <para>
     Для модификации строк существует множество полезных функций.
    </para>
    <simpara>
     Основные функции описаны в разделе
     <link linkend="ref.strings">строковых функций</link>, функции
     регулярных выражений для расширенного поиска и замены (в двух частях: 
     <link linkend="ref.pcre">Perl</link> и <link
     linkend="ref.regex">POSIX расширенный</link>).
    </simpara>
    <simpara>
     Также существуют <link linkend="ref.url">функции для URL-строк</link>,
     и функции для шифрования/дешифрования строк (<link
     linkend="ref.mcrypt">mcrypt</link> и <link
     linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Наконец, если вы все еще не нашли, что искали, смотрите также
     <link linkend="ref.ctype">функции для символьного типа</link>.
    </simpara>
   </sect2>

   <sect2 id="language.types.string.casting">
    <title>Преобразование в строку</title>
    
    <para>
     Вы можете преобразовать значение в строку, используя приведение
     <literal>(string)</literal>, либо функцию <function>strval</function>.
     В выражениях, где необходима строка, преобразование происходит автоматически.
     Это происходит, когда вы используете функции <function>echo</function>
     или <function>print</function>, либо когда вы сравниваете значение
     переменной со строкой. Прочтение разделов руководства <link
     linkend="language.types">Типы</link> и <link
     linkend="language.types.type-juggling">Манипуляции с типами</link> сделает
     следующее более понятным. Смотрите также <function>settype</function>.
    </para>
    
    <para>
     Булево (<type>boolean</type>) значение &true; преобразуется в строку
     <literal>"1"</literal>, а значение &false; представляется как
     <literal>""</literal> (пустая строка). Этим способом вы можете
     преобразовывать значения в обе стороны - из булева типа в строковый
     и наоборот.
    </para>
    <para> 
     Целое (<type>integer</type>) или число с плавающей точкой
     (<type>float</type>) преобразуется в строку, представленную числом,
     состоящим из его цифр (включая показатель степени для чисел с плавающей
     точкой).
    </para>
    <para>
     Массивы всегда преобразуются в строку <literal>"Array"</literal>,
     так что вы не можете отобразить содержимое массива (<type>array</type>),
     используя <function>echo</function> или <function>print</function>,
     чтобы узнать, что он содержит. Чтобы просмотреть один элемент, вам
     нужно сделать что-то вроде <literal>echo $arr['foo']</literal>. Смотрите
     ниже советы о том, как отобразить/просмотреть все содержимое.
    </para>
    <para>
     Объекты всегда преобразуются в строку <literal>"Object"</literal>.
     Если вы хотите вывести значение переменной-члена объекта
     (<type>object</type>) с целью отладки, прочтите следующие абзацы. Если
     вы хотите получить имя класса требуемого объекта, используйте
     <function>get_class</function>.  
    </para>
    <para>
     Ресурсы всегда преобразуются в строки со структурой
     <literal>"Resource id #1"</literal>, где <literal>1</literal> - это
     уникальный номер ресурса (<type>resource</type>), присвоенный ему PHP
     во время выполнения. Если вы хотите получить тип ресурса, используйте
     <function>get_resource_type</function>.
    </para>
    <para>
     &null; всегда преобразуется в пустую строку.
    </para>
    
    <para>
     Как вы могли видеть выше, вывод массивов, объектов или ресурсов не
     предоставляет вам никакой полезной информации о самих значениях. Более
     подходящий способ вывода значений для отладки - использовать функции
     <function>print_r</function> и <function>var_dump</function>.
    </para>
    
    <para>
     Вы также можете преобразовать значения PHP в строки для постоянного
     хранения. Этот метод называется сериализацией и может быть выполнен
     при помощи функции <function>serialize</function>. Кроме того, если в
     вашей установке PHP есть поддержка <link linkend="ref.wddx">WDDX</link>,
     вы можете сериализовать значения PHP в структуры XML.
    </para>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>Преобразование строк в числа</title>

    <simpara>
     Если строка распознается как числовое значение, результирующее значение
     и тип определяется так как показано далее.
    </simpara>
    <simpara>
     Строка будет распознана как <type>float</type>, если она содержит
     любой из символов '.', 'e', или 'E'. Иначе она будет определена как
     целое.
    </simpara>
    <para>
     Значение определяется по начальной части строки. Если строка
     начинается с верного числового значения, будет использовано это
     значение. Иначе значением будет 0 (ноль). Верное числовое значение
     - это одна или более цифр (могущих содержать десятичную точку),
     по желанию предваренных знаком, с последующим необязательным
     показателем степени. Показатель степени - это 'e' или 'E' с
     последующими одной или более цифрами.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo это float (11.5)
$foo = 1 + "-1.3e3";              // $foo это float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo это integer (1)
$foo = 1 + "bob3";                // $foo это integer (1)
$foo = 1 + "10 Small Pigs";       // $foo это integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo это float (14.2)
$foo = "10.0 pigs " + 1;          // $foo это float (11)
$foo = "10.0 pigs " + 1.0;        // $foo это float (11)     
?>    
]]>
     </programlisting>
    </informalexample>
    <simpara>
     Более подробную информацию об этом преобразовании смотрите в разделе
     о strtod(3) документации Unix.
    </simpara>
    <para>
     Если вы хотите протестировать любой из примеров этого раздела,
     вы можете скопировать и вставить его и следующую строку, чтобы
     увидеть, что происходит:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; тип: " . gettype ($foo) . "<br />\n";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Не ожидайте получить код символа, преобразовав его в целое (как
     вы могли бы сделать, например, в C). Для преобразования символов в
     их коды и обратно используйте функции <function>ord</function>
     и <function>chr</function>.
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>Массивы</title>

   <para>
    На самом деле массив в PHP - это упорядоченное отображение, которое
    устанавливает соответствие между <emphasis>значением</emphasis> и
    <emphasis>ключем</emphasis>. Этот тип оптимизирован в нескольких
    направлениях, поэтому вы можете использовать его как собственно
    массив, список (вектор), хэш-таблицу (являющуюся реализацией карты),
    словарь, коллекцию, стэк, очередь или, возможно, как что-то еще.
    Поскольку вы можете иметь в качестве значения другой массив PHP, вы
    можете также легко эмулировать деревья.
   </para>
   <para>
    Объяснение этих структур данных выходит за рамки данного
    справочного руководства, но вы найдете как минимум один пример
    каждой из них. За дополнительной информацией вы можете обратиться к
    соответствующей литературе по этой обширной теме.
   </para>
   
   <sect2 id="language.types.array.syntax">
    <title>Синтаксис</title>
    
    <sect3 id="language.types.array.syntax.array-func">
     <title>Определение при помощи <function>array</function></title>
     <para>
      Массив может быть создан языковой конструкцией <function>array</function>.
      В качестве параметров она принимает определенное количество разделенных
      запятыми пар
      <literal><replaceable>key</replaceable> =&gt; <replaceable
      >value</replaceable></literal> (ключ =&gt; значение).
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> <replaceable>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> может быть <type>integer</type> или <type>string</type>
// <replaceable>value</replaceable> может быть любым значением
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      <varname>key</varname> может быть либо <type>integer</type>, либо
      <type>string</type>. Если ключ - это стандартное представление
      <type>integer</type>, он так и будет интерпретироваться (т.е.
      <literal>"8"</literal> будет восприниматься как <literal>8</literal>,
      тогда как <literal>"08"</literal> будет интерпретироваться как
      <literal>"08"</literal>). В PHP нет разницы между индексными и
      ассоциативными массивами; существует только один тип массива,
      который может содержать и числовые, и строковые индексы.
     </para>
     <para>
      Значение может быть любого имеющегося в PHP типа.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("somearray" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["somearray"][6];    // 5
echo $arr["somearray"][13];   // 9
echo $arr["somearray"]["a"];  // 42
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Если вы не указываете ключ для приведенного значения, то берется
      максимальный числовой индекс и новый ключ будет равен этому
      максимуму + 1. Если вы укажите ключ, которому уже присвоено
      значение, оно будет перезаписано.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Этот массив эквивалентен ...
array(5 => 43, 32, 56, "b" => 12);

// ...этому массиву
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <warning>
      <simpara>
         Начиная с PHP 4.3.0, вышеописанное поведение генерации индекса
         изменено. Теперь, если вы будете использовать массив, в котором
         максимальным в настоящий момент является отрицательный ключ, то
         следующий созданный ключ будет нулевым (<literal>0</literal>).
         Раньше новым индексом становился самый большой существующий
         ключ + 1, так же как и у положительных индексов.
      </simpara>
     </warning>
     <para>
      Используя в качестве ключа &true; вы получите ключ
      <literal>1</literal> типа <type>integer</type>. Используя в
      качестве ключа &false; вы получите ключ <literal>0</literal> типа
      <type>integer</type>. Используя в качестве ключа
      <literal>NULL</literal>, вы получите пустую строку. Использование в
      качестве ключа пустой строки создаст (или перезапишет) ключ с пустой
      строкой и его значение; это не то же самое, что использование пустых
      квадратных скобок.
     </para>
     <para>
      Вы не можете использовать в качестве ключей массивы или объекты. Это
      вызовет предупреждение: <literal>Illegal offset type</literal>
      ('Недопустимый тип смещения').
     </para>
    </sect3>
    
    <sect3 id="language.types.array.syntax.modifying">
     <title>Создание/модификация с помощью синтаксиса квадратных скобок</title>
     <para>
      Также вы можете изменять существующий массив, явно устанавливая значения
      в нем.
     </para>
     <para>
      Это выполняется присвоением значений массиву при указании в скобках
      ключа. Кроме того, вы можете опустить ключ, в этом случае добавьте к
      имени переменной пустую пару скобок ("<literal>[]</literal>").
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> может быть <type>integer</type> или <type>string</type>
// <replaceable>value</replaceable> может быть любым значением
      </synopsis>
      Если массив <varname>$arr</varname> еще не существует, он будет создан.
      Таким образом, это еще один способ определить массив. Для изменения
      определенного значения просто присвойте элементу с его ключом новое
      значение. Если вы хотите удалить пару ключ/значение, вам нужно
      использовать функцию <function>unset</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // В этом месте скрипта это
                // эквивалентно $arr[13] = 56;

$arr["x"] = 42; // Это добавляет к массиву новый
                // элемент с ключом "x"
                
unset($arr[5]); // Это удаляет элемент из массива

unset($arr);    // Это удаляет массив полностью
?>
]]> 
       </programlisting>
      </informalexample>
     </para>
     <note>
      <para>
       Как уже говорилось выше, если вы не укажите в скобках ключа,
       то будет взят максимальный из существующих целочисленных
       индексов, и новым ключом будет это максимальное значение + 1.
       Если целочисленных индексов еще нет, то ключом будет
       <literal>0</literal> (ноль). Если вы укажите ключ, которому
       уже присвоено значение, оно будет перезаписано.
      </para>
      <para>
       <warning>
        <simpara>
         Начиная с PHP 4.3.0, вышеописанное поведение генерации индекса
         изменено. Теперь, если вы будете использовать массив, в котором
         максимальным в настоящий момент является отрицательный ключ, то
         следующий созданный ключ будет нулевым (<literal>0</literal>).
         Раньше новым индексом становился самый большой существующий
         ключ + 1, так же как и у положительных индексов.
        </simpara>
       </warning>
      </para>
      <para>
       Обратите внимание, что максимальный числовой ключ, используемый
       для этого <emphasis>не обязательно должен существовать в массиве
       в настоящий момент</emphasis>. Он просто должен был существовать
       с момента последнего переиндексирования массива. Это
       иллюстрирует следующий пример:
      </para>

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Создаем простой массив.
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Теперь удаляем каждый элемент, но сам массив оставляем нетронутым:
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// Создаем элемент (обратите внимание, что новым ключом будет 5,
// а не 0, как вы возможно ожидали).
$array[] = 6;
print_r($array);

// Переиндексация:
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]> 
       </programlisting>
       <para>
        Вышеприведенный пример выведет следующее:
        <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
        </screen>
       </para>
      </informalexample>       

     </note>
    </sect3>
   </sect2><!-- end syntax -->
   
   <sect2 id="language.types.array.useful-funcs">
    <title>Полезные функции</title>
    <para>
     Для работы с массивами существует достаточное количество полезных
     функций. Смотрите раздел <link linkend="ref.array">функции для работы
     с массивами</link>.
    </para>
    <note>
     <para>
      Функция <function>unset</function> позволяет удалять ключи массива.
      Обратите внимание, что массив НЕ будет переиндексирован. Если вы
      использовали только "обычные числовые индексы" (увеличивающиеся на
      единицу, начиная с нуля), вы можете переиндексировать массив
      используя <function>array_values</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'один', 2 => 'два', 3 => 'три');
unset($a[2]);
/* даст массив, представленный так:
   $a = array(1 => 'один', 3 => 'три');
   а НЕ так:
   $a = array(1 => 'один', 2 =>'три');
*/

$b = array_values($a);
// Теперь $b это array(0 => 'один', 1 =>'три')
?>
]]>
      </programlisting>
     </informalexample>
     
     </para>    
    </note> 
    <para>
     Управляющая конструкция
     <link linkend="control-structures.foreach">foreach</link> существует
     специально для массивов. Она предоставляет возможность легко
     пройтись по массиву.
    </para>
   </sect2>
   
   <sect2 id="language.types.array.donts">
    <title>Массив делает и не делает</title>

    <sect3 id="language.types.array.foo-bar">
     <title>Почему <literal>$foo[bar]</literal> это неверно?</title>
     <para>
      Вы всегда должны заключать индекс ассоциативного массива в кавычки.
      К примеру, пишите $foo['bar'], а не $foo[bar]. Но почему $foo[bar]
      это неверно? Возможно, вы встречали в старых скриптах следующий
      синтаксис:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'враг';
echo $foo[bar];
// и т. д.
?>
]]>
       </programlisting>
      </informalexample>
      Это неверно, хотя и работает. Тогда почему же это неверно? Причина
      в том, что этот код содержит неопределенную константу (bar), а не
      строку ('bar' - обратите внимание на кавычки), и PHP в будущем
      может определить константу, которая к несчастью для вашего кода
      будет иметь то же самое имя. Это работает, потому что PHP
      автоматически преобразует <emphasis>голую строку</emphasis> (не
      заключенную в кавычки строку, которая не соответствует ни одному
      из известных символов) в строку, которая содержит голую строку.
      Например, если константа с именем <constant>bar</constant> не
      определена, то PHP заменит bar на строку <literal>'bar'</literal> и
      использует ее.
     </para>
     <note>
      <simpara>
       Это не означает, что нужно <emphasis>всегда</emphasis> заключать
       ключ в кавычки. Нет необходимости заключать в кавычки <link
       linkend="language.constants">константы</link> или <link
       linkend="language.variables">переменные</link>, поскольку это
       помешает PHP обрабатывать их.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Простой массив:
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nПроверяем $i: \n";
    echo "Плохо: " . $array['$i'] . "\n";
    echo "Хорошо: " . $array[$i] . "\n";
    echo "Плохо: {$array['$i']}\n";
    echo "Хорошо: {$array[$i]}\n";
}
?>
]]>
       </programlisting>
      </informalexample>
      <para>
       Вышеприведенный код выведет следующее:
       <screen>
<![CDATA[
Проверяем 0: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Плохо: 
Хорошо: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Плохо: 
Хорошо: 1

Проверяем 1: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Плохо: 
Хорошо: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Плохо: 
Хорошо: 2
]]>        
       </screen>
      </para>
     </note>
     <para>
      Дополнительные примеры, демонстрирующие этот факт:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Давайте покажем все ошибки
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// Верно
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// Неверно. Это работает, но из-за неопределенной константы с
// именем fruit также вызывает ошибку PHP уровня E_NOTICE
// 
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Давайте определим константу, чтобы продемонстрировать, что
// происходит. Мы присвоим константе с именем fruit значение 'veggie'.
define('fruit', 'veggie');

// Теперь обратите внимание на разницу
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// Внутри строки это нормально. Внутри строк константы не
// рассматриваются, так что ошибки E_NOTICE здесь не произойдет
print "Hello $arr[fruit]";      // Hello apple

// С одним исключением: фигурные скобки вокруг массивов внутри
// строк позволяют константам находится там
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// Это не будет работать и вызовет ошибку обработки, такую как:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Это, конечно, также приложимо и к использованию в строках автоглобальных переменных
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// Еще одна возможность - конкатенация
print "Hello " . $arr['fruit']; // Hello apple
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Когда вы переведете <function>error_reporting</function>
      в режим отображения ошибок уровня
      <constant>E_NOTICE</constant> (такой как
      <constant>E_ALL</constant>), вы увидите эти ошибки. По
      умолчанию <link linkend="ini.error-reporting">
      error_reporting</link> установлена их не отображать.
     </para>
     <para>
      Как указано в разделе <link linkend="language.types.array.syntax"
      >синтаксис</link>, внутри квадратных скобок ('<literal>[</literal>'
      и '<literal>]</literal>') должно быть выражение. Это означает, что вы
      можете писать подобно этому:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      Это пример использования возвращаемого функцией значения
      в качестве индекса массива. PHP известны также и константы,
      как вы, возможно, видели упоминание <literal>E_*</literal> раньше.

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "Произошла фатальная ошибка";
$error_descriptions[E_WARNING] = "PHP сообщает предупреждение";
$error_descriptions[E_NOTICE]  = "Это лишь неофициальное замечание";
?>
]]>
       </programlisting>
      </informalexample>
      Обратите внимание, что <literal>E_ERROR</literal> - это такой же
      верный идентификатор, как и <literal>bar</literal> в первом примере.
      Но последний пример по сути эквивалентен такой записи:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "Произошла фатальная ошибка";
$error_descriptions[2] = "PHP сообщает предупреждение";
$error_descriptions[8] = "Это лишь неофициальное замечание";
?>
]]>
       </programlisting>
      </informalexample>
      поскольку <literal>E_ERROR</literal> соответствует
      <literal>1</literal> и т. д.
     </para>
     <para>
      Как мы уже объяснили в вышеприведенных примерах,
      <literal>$foo[bar]</literal> по-прежнему работает, но это неверно.
      Это работает, поскольку в соответствии со своим синтаксисом
      <literal>bar</literal> ожидается как константа. Однако, в данном
      случае константы с именем <literal>bar</literal> не существует.
      В таком случае PHP предполагает, что, написав
      <literal>bar</literal>, вы имели ввиду строку
      <literal>"bar"</literal>, но забыли указать кавычки.
     </para>
     <sect4>
      <title>Так что же в этом плохого?</title>
      <para>
       Когда-нибудь в будущем команда разработчиков PHP возможно пожелает
       добавить еще одну константу или ключевое слово, либо вы можете
       ввести в ваше приложение еще одну константу и тогда у вас могут
       возникнуть проблемы. Например, вы уже не можете использовать таким
       образом слова <literal>empty</literal> и
       <literal>default</literal>, поскольку они являются
       <link linkend="reserved">зарезервированными ключевыми словами</link>.
      </para>
      <note>
       <simpara>
        Повторим, внутри строки (<type>string</type>), заключенной
        в двойные кавычки правильным является не окружать индексы
        массива кавычками, поэтому <literal>"$foo[bar]"</literal>
        является верным. Более подробно почему - смотрите
        вышеприведенные примеры, а также раздел
        <link linkend="language.types.string.parsing">обработка
        переменных в строках</link>.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.casting">
    <title>Преобразование в массив</title>
    
    <para>
     Для любого из типов: <type>integer</type>, <type>float</type>,
     <type>string</type>, <type>boolean</type> и <type>resource</type>,
     если вы преобразуете значение в массив, вы получите массив с
     одним элементом (с индексом 0), являющимся скалярным значением, с
     которого вы начали.
    </para>
    
    <para>
     Если вы преобразуете в массив объект (<type>object</type>), вы
     получите в качестве элементов массива свойства (переменные-члены)
     этого объекта. Ключами будут имена переменных-членов.
    </para>
    
    <para>
     Если вы преобразуете в массив значение &null;, вы получите
     пустой массив.
    </para>
   </sect2>

   <sect2 id="language.types.array.comparing">
    <title>Сравнение</title>
    <para>
     Массивы можно сравнивать при помощи функции
     <function>array_diff</function> и
     <link linkend="language.operators.array">Операторов массивов</link>.
    </para>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>Примеры</title>
    <para>
     Тип массив в PHP является очень гибким, поэтому мы приведем
     здесь несколько примеров, чтобы продемонстрировать вам все
     возможности массивов.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// это
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
                       4        // ключом будет 0
          );

// полностью соответствует
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // ключом будет 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// создаст массив array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// или просто array('a', 'b', 'c')
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    
    <example>
     <title>Использование array()</title>
     <programlisting role="php">
<![CDATA[
<?php
// Массив как карта (свойств)
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );
            
// исключительно числовые ключи
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// это то же самое, что и array(0 => 7, 1 => 8, ...)

$switching = array(         10, // ключ = 0
                    5    =>  6,
                    3    =>  7, 
                    'a'  =>  4,
                            11, // ключ = 6 (максимальным числовым индексом был 5)
                    '8'  =>  2, // ключ = 8 (число!)
                    '02' => 77, // ключ = '02'
                    0    => 12  // значение 10 будет перезаписано на 12
                  );
                  
// пустой массив
$empty = array();
?>
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>Коллекция</title>
     <programlisting role="php">
<![CDATA[
<?php
$colors = array('красный', 'синий', 'зеленый', 'желтый');

foreach ($colors as $color) {
    echo "Вам нравится $color?\n";
}
?>  
  ]]>  
       </programlisting>  
  <para>  
        Результат работы приведенного скрипта будет следующий:  
       </para>  
       <screen>  
  <![CDATA[  
Вам нравится красный?
Вам нравится синий?
Вам нравится зеленый?
Вам нравится желтый?
]]>
		</screen> 
    </example>
    
    <para>
     Обратите внимание, что в настоящее время невозможно изменять
     значения массива в таком цикле напрямую.
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &$color )
      
       See bug#3074
      -->
     Однако можно сделать так:
     <example id="language.types.array.examples.changeloop">
      <title>Коллекция</title>
      <programlisting role="php">
<![CDATA[
<?php
foreach ($colors as $key => $color) {
    // не будет работать:
    //$color = strtoupper($color);
    
    // работает:
    $colors[$key] = strtoupper($color);
}
print_r($colors);

?>  
]]>  
        </programlisting>  
        <para>  
        Результат работы приведенного скрипта будет следующий:  
        </para>  
        <screen>  
  <![CDATA[  
Array
(
    [0] => КРАСНЫЙ
    [1] => СИНИЙ
    [2] => ЗЕЛЕНЫЙ
    [3] => ЖЕЛТЫЙ
)
]]>
      </screen>
     </example>
    </para>
    <para>
     Следующий пример создает начинающийся с единицы массив.
     <example>
      <title>Индекс, начинающийся с единицы</title>
      <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'Январь', 'Февраль', 'Март');
print_r($firstquarter);

?>  
]]>  
        </programlisting>  
        <para>  
        Результат работы приведенного скрипта будет следующий:  
        </para>  
        <screen>  
  <![CDATA[  
Array 
(
    [1] => 'Январь'
    [2] => 'Февраль'
    [3] => 'Март'
)
]]>   
      </screen>
     </example>
    </para>
    <example>
     <title>Заполнение массива</title>
     <programlisting role="php">
<![CDATA[
<?php
// заполняет массив всеми элементами директории
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle);
?>
]]>
     </programlisting>
    </example>
    <para>
     Массивы упорядочены. Вы можете изменять порядок элементов,
     используя различные функции сортировки. Для дополнительной
     информации смотрите раздел <link linkend="ref.array">функции
     для работы с массивами</link>. Вы можете подсчитать количество
     элементов в массиве, используя функцию
     <function>count</function>.
    </para>
    <example>
     <title>Сортировка массива</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     Поскольку значение массива может быть чем угодно, им также
     может быть другой массив. Таким образом вы можете создавать
     рекурсивные и многомерные массивы.
    </para>
    <example>
     <title>Рекурсивные и многомерные массивы</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "фрукты" => array ( "a" => "апельсин",
                                      "b" => "банан",
                                      "c" => "яблоко"
                                    ),
                  "числа"  => array ( 1,
                                      2,
                                      3,
                                      4,
                                      5,
                                      6
                                    ),
                  "дырки"  => array (      "первая",
                                      5 => "вторая",
                                           "третья"
                                    )
                );

// Несколько примеров доступа к значениям предыдущего массива
echo $fruits["дырки"][5];    // напечатает "вторая"
echo $fruits["фрукты"]["a"]; // напечатает "апельсин"
unset($fruits["дырки"][0]);  // удалит "первая"

// Создаст новый многомерный массив
$juices["яблоко"]["зеленое"] = "хорошее";
?>
]]>
     </programlisting>
    </example>
    <para>
     Обратите внимание, что при присваивании массива всегда
     происходит копирование значения. Чтобы копировать массив по
     ссылке, вам нужно использовать оператор ссылки.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 изменился,
             // $arr1 по прежнему array(2,3)
             
$arr3 = &$arr1;
$arr3[] = 4; // теперь $arr1 и $arr3 эквивалентны
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Объекты</title>

   <sect2 id="language.types.object.init">
    <title>Инициализация объекта</title>

    <para>
     Для инициализации объекта используется выражение
     <literal>new</literal>, создающее в переменной экземпляр
     объекта.

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Полное рассмотрение производится в разделе <link
     linkend="language.oop">Классы и Объекты</link>.
    </simpara>
   </sect2>
   
   <sect2 id="language.types.object.casting">
    <title>Преобразование в объект</title>
    
    <para>
     Если объект преобразуется в объект, он не изменяется. Если же в
     объект преобразуется значение любого иного типа, создается новый
     экземпляр встроенного класса <literal>stdClass</literal>. Если
     значение было пустым, новый экземпляр также будет пустым. При
     любом другом значении оно будет содержатся в переменной-члене
     <literal>scalar</literal>.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'ciao';
echo $obj->scalar;  // выведет 'ciao'
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
   
  </sect1>

  <sect1 id="language.types.resource">
   <title>Ресурс</title>
    
    <para>
     Ресурс - это специальная переменная, содержащая
     ссылку на внешний ресурс. Ресурсы создаются и
     используются специальными функциями. Полный перечень
     этих функций и соответствующих типов ресурсов
     смотрите в <link linkend="resource">приложении</link>.
    </para>
    
    <note>
     <simpara>
      Тип ресурс был введен в PHP 4
     </simpara>
    </note>

   <sect2 id="language.types.resource.casting">
    <title>Преобразование в ресурс</title>
    
    <para>
     Поскольку тип ресурс содержит специальные указатели на
     открытые файлы, соединения с базой данных, область
     изображения и тому подобное, вы не можете преобразовать
     какое-либо значение в ресурс.
    </para>
   </sect2>

    <sect2 id="language.types.resource.self-destruct">
     <title>Освобождение ресурсов</title>
    
    <para>
     В связи с системой подсчета ссылок, введенной в движке
     Zend PHP 4 автоматически определяется, что ресурс
     больше никуда не ссылается (как в Java). Когда это
     происходит, все ресурсы, которые использовались для
     данного ресурса, освобождаются сборщиком мусора.
     По этой причине маловероятно, что когда-либо будет
     необходимо освобождать память вручную, используя
     какую-нибудь free_result функцию.
     <note>
      <simpara>
       Постоянные ссылки базы данных являются особыми, они
       <emphasis>не</emphasis> уничтожаются сборщиком мусора.
       Смотрите также раздел о <link 
       linkend="features.persistent-connections">постоянных
       соединениях</link>.
      </simpara>
     </note>
    </para>
    
   </sect2>
  </sect1>
    
  <sect1 id="language.types.null">
   <title>NULL</title>
    
   <para>
    Специальное значение &null; говорит о том, что эта переменная не имеет
    значения. &null; - это единственно возможное значение типа
    <type>NULL</type>.
   </para>
    <note>
     <simpara>
      Пустой тип был введен в PHP 4
     </simpara>
    </note>
    <para>
     Переменная считается &null; если
     <itemizedlist>
      <listitem>
       <para>
        ей была присвоена константа &null;.
       </para>
      </listitem>
      <listitem>
       <para>
        ей еще не было присвоено какое-либо значение.
       </para>
      </listitem>
      <listitem>
       <para>
        она была удалена с помощью <function>unset</function>.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    
   <sect2 id="language.types.null.syntax">
    <title>Синтаксис</title>
    <para>
     Существует только одно значение типа &null; - регистро-независимое
     ключевое слово &null;.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = NULL;       
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Смотрите также <function>is_null</function> и <function>unset</function>.
    </para>
   </sect2>
  </sect1>
 
  <sect1 id="language.pseudo-types">
   <title>Псевдо-типы, используемые в этой документации</title> 

   <sect2 id="language.types.mixed">
    <title>mixed</title>
    <para>
     <literal>mixed</literal> говорит о том, что параметр может принимать
     множество (но не обязательно все) типов.
    </para>
    <para>
     <function>gettype</function>, например, принимает все типы PHP, тогда
     как <function>str_replace</function> принимает строки и массивы.
    </para>
   </sect2>
  
   <sect2 id="language.types.number">
    <title>number</title>
    <para>
     <literal>number</literal> говорит о том, что параметр может быть либо
     <type>integer</type>, либо <type>float</type>.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title>callback</title>
    <para>
     Некоторые функции, такие как <function>call_user_func</function> 
     или <function>usort</function> принимают в качестве параметра
     определенные пользователем callback-функции. Callback-функции могут
     быть не только простыми функциями, но также методами объектов,
     включая статические методы классов.
    </para>
    <para>
     PHP-функция передается просто как строка ее имени. Вы можете передать
     любую встроенную или определенную пользователем функцию за
     исключением
     <function>array</function>, 
     <function>echo</function>, 
     <function>empty</function>, 
     <function>eval</function>, 
     <function>exit</function>, 
     <function>isset</function>, 
     <function>list</function>, 
     <function>print</function> и
     <function>unset</function>.
    </para>
    <para>
     Метод созданного объекта передается как массив, содержащий объект в
     элементе с индексом 0 и имя метода в элементе с индексом 1.
    </para>
    <para>
     Методы статических классов также могут быть переданы без создания
     экземпляра объекта передачей имени класса вместо имени объекта в
     элементе с индексом 0.
    </para>

    <para>
     <example>
      <title>
       Примеры callback-функций
      </title>
      <programlisting role="php">
<![CDATA[
<?php 

// простой пример callback
function my_callback_function() {
    echo 'hello world!';
}
call_user_func('my_callback_function'); 

// примеры callback-метода
class MyClass {
    function myCallbackMethod() {
        echo 'Hello World!';
    }
}

// вызов метода статического класса без создания объекта
call_user_func(array('MyClass', 'myCallbackMethod')); 

// вызов метода объекта
$obj = new MyClass();
call_user_func(array(&$obj, 'myCallbackMethod'));
?>
]]>
      </programlisting>
     </example>
    </para>  
   
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Манипуляции с типами</title>

   <simpara>
    PHP не требует (и не поддерживает) явного определения типа при
    объявлении переменной; тип переменной определяется по контексту, в
    котором она используется. То есть, если вы присвоите строковое
    значение переменной <parameter>$var</parameter>,
    <parameter>$var</parameter> станет строкой. Если вы затем
    присвоите <parameter>$var</parameter> целочисленное значение, она
    станет целым числом.
   </simpara>
   <para>
    Примером автоматического преобразования типа является оператор
    сложения '+'. Если любой из операндов является числом с плавающей
    точкой, то все операнды интерпретируются как числа с плавающей
    точкой, результатом будет также число с плавающей точкой. В
    противном случае операнды будут интерпретироваться как целые числа
    и результат также будет целочисленным. Обратите внимание, что это
    НЕ меняет типы самих операндов; меняется только то, как они
    вычисляются.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "0";  // $foo это строка (ASCII 48)
$foo += 2;   // $foo теперь целое число (2)
$foo = $foo + 1.3;  // $foo теперь число с плавающей точкой (3.3)
$foo = 5 + "10 Little Piggies"; // $foo это целое число (15)
$foo = 5 + "10 Small Pigs";     // $foo это целое число (15)
?>
]]>
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Если последние два примера вам непонятны, смотрите <link
    linkend="language.types.string.conversion">Преобразование строк
    в числа</link>.
   </simpara>
   <simpara>
    Если вы хотите, чтобы переменная принудительно вычислялась как
    определенный тип, смотрите раздел <link linkend="language.types.typecasting">приведение
    типов</link>. Если вы хотите изменить тип переменной, смотрите
    <function>settype</function>.
   </simpara>
   <para>
    Если вы хотите протестировать любой из примеров, приведенных в
    данном разделе, вы можете использовать функцию
    <function>var_dump</function>.
   </para>
   <note>
    <para>
     Поведение автоматического преобразования в массив в настоящий
     момент не определено.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a = "1";     // $a это строка
$a[0] = "f";  // А как же смещение строки? Что произойдет?
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Поскольку PHP (по историческим причинам) поддерживает
     индексирование в строках с использованием такого же синтаксиса,
     как и при индексировании массива, вышеприведенный пример приводит
     к проблеме: следует ли $a стать массивом, первым элементом
     которого будет "f" или "f" должна стать первым символом строки $a?
    </para>
    <para>
     Текущая версия PHP воспринимает второе присваивание как
     определение смещения строки, поэтому $a станет "f", результат же
     этого автоматического преобразования следует, однако, рассматривать
     как неопределенный. В PHP 4 для доступа к символам строки был
     введен новый синтаксис фигурных скобок, используйте этот синтаксис
     вместо вышеприведенного: 
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a    = "abc"; // $a это строка
$a{1} = "f";   // $a теперь содержит "afc"
?>
]]>
      </programlisting>
     </informalexample>
     Для дополнительной информации смотрите раздел
     <link linkend="language.types.string.substr">Доступ к символу в
     строке</link>.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Приведение типов</title>

    <para>
     Приведение типов в PHP работает так же, как и в C: имя требуемого
     типа записывается в круглых скобках перед приводимой переменной.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo это целое число
$bar = (boolean) $foo;   // $bar это булев тип
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Допускаются следующие приведения типов:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - приведение к целому числу</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - приведение к булеву типу</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - приведение к числу с плавающей точкой (float)</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - приведение к строке</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - приведение к массиву</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - приведение к объекту</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Обратите внимание, что внутри скобок допускаются пробелы и
     символы табуляции, поэтому следующее равносильно по своему
     действию:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Вместо приведения переменной к строке, вы можете заключить ее в
      двойные кавычки.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo это целое число
$str = "$foo";        // $str это строка
$fst = (string) $foo; // $fst это также строка

// Это напечатает "они одинаковы"
if ($fst === $str) {
    echo "они одинаковы";
}
?>
]]>
      </programlisting>
     </informalexample>
     </para>
    </note>
     
    <para>
     Возможно, вам не совсем ясно, что происходит при приведении
     между типами. Для дополнительной информации смотрите разделы:
    
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Преобразование
        в булев тип</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Преобразование
        в целое число</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">Преобразование
        в число с плавающей точкой</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Преобразование
        в строку</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Преобразование
        в массив</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Преобразование
        в объект</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Преобразование
        в ресурс</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
        &null;</link></simpara>
      </listitem>
      -->
      <listitem>
       <simpara>
        <link linkend="types.comparisons">Таблицы сравнения типов</link>
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
