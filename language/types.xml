<?xml version="1.0" encoding="windows-1251"?>
<!-- EN-Revision: 1.98 Maintainer: Kai Status: not yet ready -->
<!-- $Revision: 1.3 $ -->
 <chapter id="language.types">
  <title>Типы</title>

   <!--
    Замечание:                        Последнее изменение заметки: 2003-03-03
     resource - ресурс
     control structure = управляющая конструкция
     language.types.string.conversion = Конвертация строк в числа
     Arbitrary Precision Mathematics Functions=математические фукции произвольной точности
     String conversion to numbers = Конвертация строк в числа
     language.types.integer.casting = 
     и другие ссылки
     heredoc-синтаксис
     Escaped characters
     language.operators.string
   -->

  <sect1 id="language.types.intro">
  <title>Введение</title>
  
  <simpara>
   PHP поддерживает восемь простых типов.
  </simpara>
  
  <para>
   Четыре скалярных типа:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.boolean">булев</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.integer">целое</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.float">число с плавающей точкой</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.string">строка</link>
     </simpara>
    </listitem>

   </itemizedlist>

   Два смешанных типа:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.array">массив</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.object">объект</link>
     </simpara>
    </listitem>

   </itemizedlist>

   И, наконец, два специальных типа:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.resource">ресурс</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.null">NULL</link>
     </simpara>
    </listitem>

   </itemizedlist>

   В этой документации также представлено несколько
   <link linkend="language.pseudo-types">псевдо-типов</link> 
   для удобства понимания:

   <itemizedlist>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">смешанный</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.number">число</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">обратный вызов (callback)</link>
     </simpara>
    </listitem>

   </itemizedlist>
   Вы также можете найти несколько упоминаний типа двойной точности.
   Рассматривайте его как число с плавающей точкой, два имени существуют только
   по историческим причинам.
  </para>
  
  <simpara>
   Как правило, программист не устанавливает тип переменной;
   предпочтительнее, чтобы это делал PHP во время выполнения программы в
   зависимости от контекста, в котором используется переменная.
  </simpara>
  <note>
   <simpara>
    Если вы желаете проверить тип и значение определенного <link
     linkend="language.expressions">выражения</link>, используйте
    <function>var_dump</function>.
   </simpara>
   <para>
    Если же вам для отладки необходимо просто удобочитаемое представление
    типа, используйте <function>gettype</function>. Чтобы проверить на
    определенный тип, <emphasis>не</emphasis> используйте <function>gettype</function>,
    применяйте для этого <literal>is_<replaceable>type</replaceable></literal>
    функции. Вот несколько примеров:
    <informalexample>
     <programlisting role="php">
<![CDATA[
$bool = TRUE;   // логический
$str  = "foo";  // строковый
$int  = 12;     // целочисленный

echo gettype($bool); // выводит "boolean"
echo gettype($str);  // выводит "string"

// Если это целое, увеличить на четыре
if (is_int($int)) {
    $int += 4;
}

// Если $bool - это строка, вывести ее
// (ничего не выводит)
if (is_string($bool)) {
    echo "Строка: $bool";
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>
  <simpara>
   Если вы хотите принудительно изменить тип переменной, вы можете либо
   <link linkend="language.types.typecasting">привести</link>
   переменную, либо использовать функцию <function>settype</function>.
  </simpara>
  <simpara>
   Обратите внимание, что переменная, в зависимости от ее типа в данный
   момент, в определенных ситуациях может иметь разные значения.
   Более подробную информацию смотрите в разделе <link
   linkend="language.types.type-juggling">Манипуляции с типами</link>.
  </simpara>
 </sect1>
   
   <sect1 id="language.types.boolean">
    <title>Булев</title>
    
    <simpara>
     Это простейший тип. Он выражает истинность значения - это может
     быть либо &true;, либо &false;. 
    </simpara>

    <note>
     <simpara>
      Булев тип был введен в PHP 4.
     </simpara>
    </note>

    <sect2 id="language.types.boolean.syntax">
     <title>Синтаксис</title>
     <para>
      Чтобы определить булев тип, используйте ключевое слово &true; 
      или &false;. Оба регистро-независимы.
      <informalexample>
       <programlisting role="php">
<![CDATA[
$foo = True; // определить $foo как TRUE
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Обычно вы используете некий
      <link linkend="language.operators">оператор</link>,
      который возвращает логическое выражение, а затем предает его
      <link linkend="control-structures">управляющей конструкции</link>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
// == это оператор, который проверяет
// эквивалентность и возвращает булево значение
if ($action == "показать_версию") {
    echo "Версия 1.23";
}

// это не обязательно...
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// ...потому что вы можете просто написать
if ($show_separators) {
    echo "<hr>\n";
}
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>Конвертация в булев тип</title>
      <simpara>
       Для несомненной конвертации значения в булев тип используйте привидение
       типа <literal>(bool)</literal> или <literal>(boolean)</literal>.
       Однако в большинстве случаев вам нет необходимости использовать привидение типа,
       поскольку значение будет автоматически конвертировано, если оператор, функция или 
       управляющая конструкция требует булев аргумент.
      </simpara>
      <simpara>
       Смотрите также <link linkend="language.types.type-juggling">Манипуляции с типами</link>.
      </simpara>
      
      <para>
       При конвертации в логический тип, следующие значения
       рассматриваются как &false;:
  
       <itemizedlist>
        <listitem>
         <simpara>Сам <link linkend="language.types.boolean">булев</link> 
          &false;</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.integer">целое</link
         > 0 (ноль) </simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.float">число с плавающей точкой</link> 
         0.0 (ноль) </simpara>
        </listitem>
        <listitem>
         <simpara>пустая <link linkend="language.types.string"
           >строка</link> и <link linkend="language.types.string"
           >строка</link>
           "0"</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.array">массив</link> 
         с нулевыми элементами</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.object">объект</link> 
         с нулевыми переменными-членами</simpara>
        </listitem>
        <listitem>
         <simpara>специальный тип <link linkend="language.types.null"
           >NULL</link> (включая неустановленные переменные)
         </simpara>
        </listitem>
       </itemizedlist>
       
       Все остальные значения рассматриваются как &true; (включая 
       любой <link linkend="language.types.resource">источник</link>).
       <warning>
        <simpara>
         <literal>-1</literal> считается &true;, как и любое
         ненулевое (отрицательное или положительное) число!
        </simpara>
       </warning>
       <informalexample>
        <programlisting role="php">
<![CDATA[
echo gettype((bool) "");        // bool(false)
echo gettype((bool) 1);         // bool(true)
echo gettype((bool) -2);        // bool(true)
echo gettype((bool) "foo");     // bool(true)
echo gettype((bool) 2.3e5);     // bool(true)
echo gettype((bool) array(12)); // bool(true)
echo gettype((bool) array());   // bool(false)
]]>
        </programlisting>
       </informalexample>
      </para>
     </sect2>
   </sect1>

   <sect1 id="language.types.integer">
    <title>Целые</title>
    
    <simpara>
     Целое это число из множества Z = {..., -2, -1, 0, 1, 2, ...}.
    </simpara>
     
    <para>
     Смотрите также:
     <link linkend="ref.gmp">Целые произвольной длины</link> и
     <link linkend="language.types.float">Числа с плавающей точкой</link>
    </para>

    <sect2 id="language.types.integer.syntax">
     <title>Синтаксис</title>
     <simpara>
      Целые могут быть указаны в десятичной, шестнадцатеричной или
      восьмеричной системе счисления, по желанию с предшествующим знаком (- или +).
     </simpara>
     <para>
      Если вы используете восьмеричную систему счисления, вы должны
      предварить число <literal>0</literal> (нулем), для использования
      шестнадцатеричной системы нужно поставить перед числом <literal>0x</literal>.
      <example>
       <title>Целые</title>
       <programlisting role="php">
<![CDATA[
$a = 1234; # десятичное число
$a = -123; # отрицательное число
$a = 0123; # восьмеричное число (эквивалентно 83 в десятичной системе)
$a = 0x1A; # шестнадцатеричное число (эквивалентно 26 в десятичной системе)
]]>
       </programlisting>
      </example>
      Формально возможная структура целых такова:
      <informalexample>
       <programlisting>
<![CDATA[
десятичные        : [1-9][0-9]*
                  | 0

шестнадцатеричные : 0[xX][0-9a-fA-F]+

восьмеричные      : 0[0-7]+

целые             : [+-]?десятичные
                  | [+-]?шестнадцатеричные
                  | [+-]?восьмеричные
]]>
       </programlisting>
      </informalexample>
      Размер целого зависит от платформы, хотя, как правило,
      максимальное значение около двух миллиардов
      (это 32-битное знаковое). PHP не поддерживает беззнаковые целые.
     </para>
    </sect2>
   
    <sect2 id="language.types.integer.overflow">
     <title>Превышение размера целого</title>
     <para>
      Если вы определите число, превышающее пределы целого типа, оно будет
      интерпретировано как число с плавающей точкой. Также, если вы
      используете оператор, результатом работы которого будет число,
      превышающее пределы целого, вместо него будет возвращено число с
      плавающей точкой.

      <informalexample>
       <programlisting role="php">
<![CDATA[
$large_number =  2147483647;
var_dump($large_number);
// вывод: int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// вывод: float(2147483648)

// это справедливо и для шестнадцатеричных целых:
var_dump( 0x80000000 );
// вывод: float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// вывод: float(50000000000)
]]>
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        К сожалению, в PHP была ошибка, так что это не всегда верно
        работает, когда используются отрицательные числа.
        Например: когда вы умножаете <literal>-50000 *
        $million</literal>, результатом будет
        <literal>-429496728</literal>. Однако, если оба операнда
        положительны, проблем не возникает.
       </simpara>
       <simpara>
        Эта ошибка устранена в PHP 4.1.0.
       </simpara>
      </warning>
     </para>
     <para>
      в PHP не существует оператора деления целых.
      Результатом <literal>1/2</literal> будет число с плавающей точкой
      <literal>0.5</literal>. Вы можете привести значение к целому, что
      всегда округляет его в меньшую сторону, либо использовать функцию
      <function>round</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
var_dump(25/7);         // float(3.5714285714286) 
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4) 
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>
   

    <sect2 id="language.types.integer.casting">
     <title>Конвертация в целое</title>
      <simpara>
       Для несомненной конвертации значения в целое используйте привидение
       типа <literal>(int)</literal> или <literal>(integer)</literal>.
       Однако в большинстве случаев вам нет необходимости использовать привидение типа,
       поскольку значение будет автоматически конвертировано, если оператор, функция или 
       управляющая конструкция требует целый аргумент. Вы также можете конвертировать
       значение в целое при помощи функции <function>intval</function>.
      </simpara>
      <simpara>
       Смотрите также <link linkend="language.types.type-juggling">Манипуляции с типами</link>.
      </simpara>
      
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>Из <link linkend="language.types.boolean"
           >булева</link> типа</title>
       <simpara>
        &false; конвертируется в
        <literal>0</literal> (ноль), а &true; 
        - в <literal>1</literal> (единицу).
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title>Из <link linkend="language.types.float">чисел с плавающей точкой</link></title> 
       <simpara>
        При конвертации из числа с плавющей точкой в целое, число будет
        округлено <emphasis>в сторону нуля</emphasis>.
       </simpara>
       
       <para>
        Если число с плавающей точкой превышает пределы целого
        (как правило, это <literal>+/- 2.15e+9 = 2^31</literal>), 
        результат будет неопределённым, так как целое не имеет достаточной
        точности, чтобы вернуть верный результат. В этом случае не будет
        выведено ни предупреждения, ни даже замечания!
       </para>
       
       <warning><para>
        Никогда не приводите неизвестную дробь к целому, так как это
        может иногда дать неожиданные результаты.
        <informalexample>
         <programlisting role="php">
<![CDATA[
echo (int) ( (0.1+0.7) * 10 ); // выводит 7!
]]>
         </programlisting>
        </informalexample>
        
        Смотрите более подробно: <link 
        linkend="warn.float-precision">предупреждение о точности
        числел с плавающей точкой</link>.
       </para></warning>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-string">
       <title>Из строк</title>
       <simpara>
        Смотрите <link linkend="language.types.string.conversion">Конвертация
        строк в числа</link>
       </simpara>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-other">
       <title>Из других типов</title>
       <para>
        <caution>
         <simpara>
          Для других типов поведение конвертации в целое не определено.
          В настоящее время поведение такое же, как если бы значение
          сперва было <link linkend="language.types.boolean.casting"
          >конвертировано в булев тип</link>. Однако
          <emphasis>не</emphasis> полагайтесь на это поведение, так
          как он может измениться без предупреждения.
         </simpara>
        </caution>
       </para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>Числа с плавющей точкой</title>
   <para>
    Числа с плавющей точкой (они же числа двойной точности или
    действительные числа) могут быть определены при помощи любого
    из следующих синтаксисов:
    <informalexample>
     <programlisting role="php">
$a = 1.234; $a = 1.2e3; $a = 7E-10;
     </programlisting>
    </informalexample>
    Формально:
    <informalexample>
     <programlisting role="php">
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
     </programlisting>
    </informalexample>
    Размер целого зависит от платформы, хотя максимум, как правило,
    ~1.8e308 с точностью около 14 десятичных цифр (это 64-битный
    IEEE-формат).
   </para>
 
   <warning id="warn.float-precision">
    <title>Точность числа с плавающей точкой</title>
    <para>
     Довольно часто простые десятичные дроби вроде
     <literal>0.1</literal> или <literal>0.7</literal> не могут быть
     конвертированы в свои внутренние двоичные аналоги без небольшой
     потери точности. Это может привести к неожиданным результатам:
     например, <literal>floor((0.1+0.7)*10)</literal> скорее всего
     возвратит <literal>7</literal> вместо ожидаемой
     <literal>8</literal> как результат внутреннего представления
     числа, являющегося в действительности чем-то вроде <literal>7.9999999999...</literal>.
    </para>
    <para>
     Это связано с невозможностью точно выразить некоторые дроби в
     десятичной системе счисления конечным числом цифр. Например,
     <literal>1/3</literal> в десятичной форме принимает вид
     <literal>0.3333333. . .</literal>.
    </para>
    <para>
     Так что никогда не доверяйте точности последних цифр в результатах
     с числами с плавающей точкой и никогда не проверяйте их на
     равенство. Если вам дейсвительно необходима высокая точность, вам
     следует использовать <link
     linkend="ref.bc">математические функции произвольной точности</link>
     или <link linkend="ref.gmp">gmp</link>-функции.
    </para>
   </warning>

   <sect2 id="language.types.float.casting">
    <title>Конвертация в число с плавающей точкой</title>
    
    <para>
     О том когда и как строки конвертируются в числа с плавающей точкой
     читайте в разделе <link linkend="language.types.string.conversion">Конвертация
     строк в числа</link>. Для значений других типов конвертация будет
     такой же, как если бы значение сначала было конвертировано в целое,
     а затем в число с плавающей точкой. Дополнительную информацию
     смотрите в разделе <link linkend="language.types.integer.casting">Конвертация
     в целое</link>.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.string">
   <title>Строки</title>
   <para>
    Строка - это набор символов. В PHP символ это то же самое, что
    и байт, это значит, что возможно ровно 256 различных символов.
    Это также означает, что PHP не имеет встроенной поддержки
    Unicode'а. Некоторую поддержку Unicode'а обеспечивают эти
    функции <function>utf8_enncode</function> и
    <function>utf8_decode</function>.
   </para>
   <note>
    <simpara>
     Нет никаких проблем, если строка очень велика. Практически
     не существует ограничений на размер строк, налагаемых PHP,
     так что нет абсолютно никаких причин беспокоиться об их
     длине.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>Синтаксис</title>
    <para>
     Строка может быть определена тремя различными способами.
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">одинарными кавчками</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">двойными кавычками</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">heredoc-синтаксисом</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>Одинарные кавычки</title>
     <para>
      Простейший способ определить строку - это заключить ее в
      одинарные кавычки (символ <literal>'</literal>). 
     </para>
     <para>
      Чтобы использовать одинарную кавычку внутри строки,
      как и во многих других языках, ее необходимо предварить
      символом обратной косой черты (<literal>\</literal>),
      т. е. мнемонизировать ее. Если обратная наклонная черта
      должна идти перед одинарной кавычкой либо быть в конце
      строки, вам необходимо продублировать ее. Обратите
      внимание, что если вы попытаетесь мнемонизировать любой
      другой символ, обратная косая черта также будет напечатана!
      Так что, как правило, нет необходимости мнемонизировать
      саму обратную косую черту.
      <note>
       <simpara>
        В PHP 3 в данном случае будет выдано сообщение уровня
        <literal>E_NOTICE</literal>.
       </simpara>
      </note>
      <note>
       <simpara>
        В отличие от двух других синтаксисов, переменные,
        встречающиеся в строках, заключенных в одинарные
        кавычки, <emphasis>не</emphasis> обрабатываются.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo ''это простая строка';
echo 'Вы можете вставлять в строки символ новой строки
таким образом';
echo 'Однажды Арнольд сказал: "I\'ll be back"';
// вывод: ... "I'll be back"
echo 'Вы уверены, что хотите удалить C:\\*.*?';
// вывод: ... удалить C:\*.*?
echo 'Вы уверены, что хотите удалить C:\*.*?';
// вывод: ... удалить C:\*.*?
echo 'Я пытаюсь вставить в этой точке: \n символ новой строки';
// вывод: ... в этой точке: \n символ новой строки
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>Двойные кавычки</title>
     <para>
      Если строка заключена в двойные кавычки ("),
      PHP распознает большее количество мнемоник специальных символов:
     </para>
     <table>
      <title>Мнемоники символов</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>последовательность</entry>
         <entry>значение</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>новая строка (LF или 0x0A (10) в ASCII)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>возврат каретки (CR или 0x0D (13) в ASCII)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>горизонтальная табуляция (HT или 0x09 (9) в ASCII)</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>обратная наклонная черта</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>знак доллара</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>двойная кавычка</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          последовательность символов, соответсвующая
          регулярному выражению, символ в восьмеричной
          системе счисления
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          последовательность символов, соответсвующая
          регулярному выражению, символ в шестнадцатеричной
          системе счисления
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Повторяем, если вы захотите мнемнонизировать любой другой
      символ, обратная косая черта также будет напечатана!
     </para>
     <para>
      Но самым важным свойством строк в двойных кавычках является
      обработка переменных.
      Смотрите более подробно: <link linkend="language.types.string.parsing">обработка 
      строк</link>.
     </para>
    </sect3>
    
    <sect3 id="language.types.string.syntax.heredoc">
     <title>Heredoc</title>
     <simpara>
      Другой способ определения строк - это использование
      heredoc-синтаксиса ("&lt;&lt;&lt;"). После
      <literal>&lt;&lt;&lt;</literal> необходимо указать идентификатор,
      затем идет строка, а потом этот же идентификатор, закрывающий вставку. 
     </simpara>
     <simpara>
      Закрывающий идентификтор <emphasis>должен</emphasis> начинаться в
      первом столбце строки. Кроме того, идентификатор должен
      соответствовать тем же правилам именования, что и все остальные
      метки в PHP: содержать только буквенно-цифровые символы и знак
      подчеркивания, и должен начинаться с нецифры или знака подчеркивания.
     </simpara>
     
     <warning>
      <simpara>
       Важно отметить, что строка с закрывающим идентификатором не содержит
       других символов, за исключением, <emphasis>возможно</emphasis>,
       точки с запятой (<literal>;</literal>). Это означает, что идентификатор
       <emphasis>не должен вводиться с отступом</emphasis> и что не может
       быть никаких пробелов или знаков табуляции до или после точки с запятой.
      </simpara>
     </warning>

     <para>
      Heredoc-текст ведёт себя так же, как и строка в двойных кавычках,
      но без них. Это означает, что вам нет необходимости мнемонизировать
      кавычки в heredoc, но вы по-прежнему можете использовать
      вышеперечисленные коды-мнемоники. Переменные обрабатываются, но
      с применением сложных переменных внутри heredoc нужно быть также
      внимательным, как и при работе со строками.
      <example> 
       <title>Пример определения heredoc-строки</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Пример строки,
охватывающей несколько строчек
с использованием heredoc-синтаксиса.
EOD;

/* Более сложный пример с переменными. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'МоеИмя';

echo <<<EOT
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я вывожу {$foo->bar[1]}.
Это должно вывести заглавную букву 'A': \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>
  
     <note>
      <para>
       Поддержка heredoc была добавлена в PHP 4.
      </para>
     </note>
    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>Обработка переменных</title>
     <simpara>
      Если строка определяется в двойных кавычках, либо при помощи
      heredoc, переменные внутри нее обрабатываются.
     </simpara>
     <simpara>
      Существует два типа синтаксиса -
      <link linkend="language.types.string.parsing.simple">простой</link> и
      <link linkend="language.types.string.parsing.complex">сложный</link>.
      Простой синтаксис более легок и удобен, он дает возможность
      обработки переменной, значения массива или свойства объекта.
     </simpara>
     <simpara>
      Сложный синтаксис был введен в PHP 4 и может быть распознан
      по фигурным скобкам, окружающих выражение.
     </simpara>

     <sect4 id="language.types.string.parsing.simple">
      <title>Простой синтаксис</title>
      <simpara>
       Если интерпретатор встречает знак доллара (<literal>$</literal>), он
       захватывает столько символов, сколько возможно, чтобы сформировать
       правильное имя переменной. Если вы хотите точно определить конец имени,
       заключайте имя переменной в фигурные скобки.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$beer = 'Heineken';
echo "$beer's taste is great"; // работает, "'" это неверный символ для имени переменной
echo "He drank some $beers";   // не работает, 's' это верный символ для имени переменной
echo "He drank some ${beer}s"; // работает
]]>
       </programlisting>
      </informalexample>
      <simpara>
       Точно также могут быть обработаны элемент массива или свойство
       объекта. В элементах массива закрывающая квадратная скобка
       (<literal>]</literal>) обозначает конец определения элемента.
       Для свойств объекта применяются те же правила, что и для простых
       переменных, хотя с ними невозможен трюк, как с переменными.
       
       <!-- XXX isn't &true; :(, this would be the trick
       Also, the same trick with curly-braces works if you
       want to limit the greediness of parsers.
       -->
      
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$fruits = array('strawberry' => 'red', 'banana' => 'yellow');

// Заметьте, что вне кавычек эта конструкция работает по-другому
echo "A banana is $fruits[banana].";

echo "This square is $square->width meters broad.";

// Не работает. Для решения см. сложный синтаксис.
echo "This square is $square->width00 centimeters broad.";

]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       Для чего-либо более сложного вы должны использовать сложный синтаксис.
      </simpara>
     </sect4>

     <sect4 id="language.types.string.parsing.complex">
      <title>Сложный (фигурный) синтаксис</title>
      <simpara>
       Он называется сложным не потому, что труден в понимании,
       а потому что позволяет использовать сложные выражения.
     </simpara>
     <simpara>
      Фактически, вы можете включить любое значение, находящееся в
      пространстве имени в строке с этим синтаксисом. Вы просто
      записываете выражение таким же образом, как и вне строки, а
      затем заключаете его в { и }. Поскольку вы не можете заменить
      мнемоникой '{', этот синтаксис будет распознаваться только
      когда $ следует непосредственно за {. (Используйте "{\$" или
      "\{$" чтобы отобразить "{$").
      Несколько поясняющих примеров:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
$great = 'fantastic';
echo "This is { $great}"; // не будет работать, выведет: This is { fantastic}
echo "This is {$great}";  // работает, выведет: This is fantastic
echo "Этот квадрат шириной {$square->width}00 сантиметров."; 
echo "Это работает: {$arr[4][3]}";

// Это неверно по той же причине,
// что и $foo[bar] неверно вне строки.
echo "Это неправильно: {$arr[foo][3]}"; 

echo "Следует делать это так: {$arr['foo'][3]}";
echo "Вы можете даже записать {$obj->values[3]->name}";
echo "Это значение переменной по имени $name: {${$name}}";
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>Доступ к символу в строке</title>
     <para>
      Символы в строках можно использовать, определив их смещение
      относительно начала строки, начиная с нуля, в фигурных
      скобках после строки.
     </para>
     <note>
      <simpara>
       Для обеспечения обратной совместимости, вы по-прежнему имеете
       возможность использовать в тех же целях скобки массива.
       Однако, начиная с PHP 4, этот синтаксис нежелателен к
       использованию.
      </simpara>
     </note>
     <para>
      <example>
       <title>Несколько примеров строк</title>
       <programlisting role="php">
<![CDATA[
<?php
// Получение первого символа строки
$str = 'Это тест.';
$first = $str{0};

// Получение последнего символа строки
$str = 'Это все еще тест.';
$last = $str{strlen($str)-1}; 
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>Полезные функции и операторы</title>
    <para>
     Строки могут быть объединены при помощи оператора '.' (точка).
     Обратите внимание, оператор сложения '+' здесь не работает.
     Дополнительную информацию смотрите в разделе <link
     linkend="language.operators.string">Строковые операторы</link>.
    </para>
    <para>
     Для модификации строк существует множество полезных функций.
    </para>
    <simpara>
     Основные функции описаны в разделе
     <link linkend="ref.strings">строковых функций</link>, функции
     регулярных выражений для расширенного поиска и замены (в двух частях: 
     <link linkend="ref.pcre">Perl</link> и <link
     linkend="ref.regex">POSIX расширенный</link>).
    </simpara>
    <simpara>
     Также существуют <link linkend="ref.url">функции для URL-строк</link>,
     и функции для шифрования/дешифрования строк (<link
     linkend="ref.mcrypt">mcrypt</link> и <link
     linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Наконец, если вы все еще не нашли, что искали, смотрите также
     <link linkend="ref.ctype">функции для символьного типа</link>.
    </simpara>
   </sect2>

   <sect2 id="language.types.string.casting">
    <title>Конвертация в строку</title>
    
    <para>
     Вы можете конвертировать значение в строку, используя приведение
     <literal>(string)</literal>, либо функцию <function>strval</function>.
     В выражениях, где необходима строка, конвертация происходит автоматически.
     Это происходит, когда вы используете функции <function>echo</function>
     или <function>print</function>, либо когда вы сравниваете значение
     переменной со строкой.
    </para>
    
    <para>
     Логическое значение &true; конвертируется в строку <literal>"1"</literal>,
     а значение &false; представляется как <literal>""</literal> (пустая строка).
     Этим способом вы можете конвертировать значения в обе стороны из булева
     типа в строковый и наоборот.
    </para>
    <para> 
     Целое или число с плавающей точкой конвертируется в строку, представленную
     числом, состоящим из его цифр (включая показалтель степени для чисел с
     плавающей точкой).
    </para>
    <para>
     Массивы всегда конвертируются в строку <literal>"Array"</literal>,
     так что вы не можете отобразить содержимое массива, используя
     <function>echo</function> или <function>print</function>, чтобы узнать,
     что он содержит. Дополнительные советы вы можете найти ниже.
    </para>
    <para>
     Объекты всегда конвертируются в строку <literal>"Object"</literal>.
     Если вы хотите вывести значение переменной-члена объекта по причине
     отладки, прочтите следующие абзацы. Если вы хотите получить имя класса
     требуемого объекта, используйте функцию <function>get_class</function>.  
    </para>
    <para>
     Ресурсы всегда конвертируются в строки со структурой
     <literal>"Resource id #1"</literal>, где <literal>1</literal> - это
     уникальный номер ресурса, присвоенный ему PHP во время выполнения.
     Если вы хотите получить тип ресурса, используйте функцию
     <function>get_resource_type</function>.
    </para>
    <para>
     &null; всегда конвертируется в пустую строку.
    </para>
    
    <para>
     Как вы могли видеть выше, вывод массивов, объектов или ресурсов не
     предоставляет вам никакой полезной информации о самих значениях. Более
     подходящий способ вывода значений для отладки - использовать функции
     <function>print_r</function> и <function>var_dump</function>.
    </para>
    
    <para>
     Вы также можете конвертировать значения PHP в строки для постоянного
     хранения. Этот метод называется сериализацией и может быть выполнен
     при помощи функции <function>serialize</function>. Кроме того, если в
     вашей установке PHP есть поддержка <link linkend="ref.wddx">WDDX</link>,
     вы можете сериализовать значения PHP в структуры XML.
    </para>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>Конвертация строк в числа</title>

    <simpara>
     Если строка распознается как числовое значение, результирующее значение
     и тип определяется так как показано далее.
    </simpara>
    <simpara>
     Строка будет распознана как <type>float</type>, если она содержит
     любой из символов '.', 'e', или 'E'. Иначе она будет определена как
     целое.
    </simpara>
    <para>
     Значение определяется по начальной части строки. Если строка
     начинается с верного числового значения, будет использовано это
     значение. Иначе значением будет 0 (ноль). Верное числовое значение
     - это одна или более цифр (могущих содержать десятичную точку),
     по желанию предваренных знаком, с последующим необязательным
     показателем степени. Показатель степени - это 'e' или 'E' с
     последующими одной или более цифрами.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$foo = 1 + "10.5";              // $foo это float (11.5)
$foo = 1 + "-1.3e3";            // $foo это float (-1299)
$foo = 1 + "bob-1.3e3";         // $foo это integer (1)
$foo = 1 + "bob3";              // $foo это integer (1)
$foo = 1 + "10 Small Pigs";     // $foo это integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo это float (14.2)
$foo = "10.0 pigs " + 1;        // $foo это float (11)
$foo = "10.0 pigs " + 1.0;      // $foo это float (11)     
]]>
     </programlisting>
    </informalexample>
    <simpara>
     Более подробную информацию об этой конвертации смотрите в
     документации по Unix в разделе о strtod(3).
    </simpara>
    <para>
     Если вы хотите протестировать любой из примеров этого раздела,
     вы можете скопировать и вставить его и следующую строку, чтобы
     увидеть, что происходит:
     <informalexample>
      <programlisting role="php">
<![CDATA[
echo "\$foo==$foo; тип: " . gettype ($foo) . "<br />\n";
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Не ожидайте получить код символа, конвертировав его в целое (как
     вы могли бы сделать, например, в C). Для конвертации символов в
     их коды и обратно используйте функции <function>ord</function>
     и <function>chr</function>.
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>Массивы</title>

   <para>
    An array in PHP is actually an ordered map. A map is a type that
    maps <emphasis>values</emphasis> to <emphasis>keys</emphasis>. 
    This type is optimized in several ways,
    so you can use it as a real array, or a list (vector), 
    hashtable (which is an implementation of a map), 
    dictionary, collection,
    stack, queue and probably more. Because you can have another
    PHP-array as a value, you can also quite easily simulate
    trees.
   </para>
   <para>
    Explanation of those structures is beyond the scope of this manual,
    but you'll find at least one example for each of those structures.
    For more information we refer you to external literature about
    this broad topic.
   </para>
   
   <sect2 id="language.types.array.syntax">
    <title>Syntax</title>
    
    <sect3 id="language.types.array.syntax.array-func">
     <title>Specifying with <function>array</function></title>
     <para>
      An <type>array</type> can be created by the <function>array</function> 
      language-construct. It takes a certain number of comma-separated
      <literal><replaceable>key</replaceable> =&gt; <replaceable
      >value</replaceable></literal>
      pairs.
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> <replaceable
>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> is either <type>string</type
                        > or nonnegative <type>integer</type>
// <replaceable>value</replaceable> can be anything
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
array("foo" => "bar", 12 => true);
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      A <varname>key</varname> is either an <type>integer</type> 
      or a <type>string</type>. If a key is the standard representation
      of an <type>integer</type>, it will be interpreted as such (i.e.
      <literal>"8"</literal> will be interpreted as <literal>8</literal>,
      while <literal>"08"</literal> will be interpreted as
      <literal>"08"</literal>). There are no different indexed and
      associative array types in PHP, there is only one array type,
      which can both contain integer and string indices.
     </para>
     <para>
      A value can be of any PHP type.
      <informalexample>
       <programlisting role="php">
<![CDATA[
array("somearray" => array(6 => 5, 13 => 9, "a" => 43));
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      If you omit a key, the maximum of the integer-indices is taken, and
      the new key will be that maximum + 1. As integers can be negative,
      this is also true for negative indices. Having e.g. the highest index
      being <literal>-6</literal> will result in being <literal>-5</literal>
      the new key. If no integer-indices exist
      yet, the key will be <literal>0</literal> (zero). If you specify a key
      that already has a value assigned to it, that value will be overwritten.
      <informalexample>
       <programlisting role="php">
<![CDATA[
// This array is the same as ...
array(5 => 43, 32, 56, "b" => 12);

// ...this array
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Using &true; as a key will evalute to
      <type>integer</type> <literal>1</literal> as key. Using
      &false; as a key will evalute to <type>integer</type>
      <literal>0</literal> as key. Using <literal>NULL</literal> as a key
      will evaluate to an empty string. Using an emptry string as key will
      create (or overwrite) a key with an empty string and its value, it is
      not the same as using empty brackets.
     </para>
     <para>
      You cannot use arrays or objects as keys. Doing so will result in a
      warning: <literal>Illegal offset type</literal>.
     </para>
    </sect3>
    
    <sect3 id="language.types.array.syntax.modifying">
     <title>Creating/modifying with square-bracket syntax</title>
     <para>
      You can also modify an existing array, by explicitly setting
      values in it.
     </para>
     <para>
      This is done by assigning values to the array while specifying the 
      key in brackets. You can also omit the key, add an empty pair
      of brackets ("<literal>[]</literal>") to the variable-name in that case.
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> is either <type>string</type
                        > or nonnegative <type>integer</type>
// <replaceable>value</replaceable> can be anything
      </synopsis>
      If <varname>$arr</varname> doesn't exist yet, it will be created. 
      So this is also an alternative way to specify an array.
      To change a certain value, just assign a new value
      to an element specified with its key. If you want to
      remove a key/value pair, you need to <function>unset</function> it. 
      <informalexample>
       <programlisting role="php">
<![CDATA[
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // This is the same as $arr[13] = 56;
                // at this point of the script

$arr["x"] = 42; // This adds a new element to
                // the array with key "x"
                
unset($arr[5]); // This removes the element from the array

unset($arr);    // This deletes the whole array
]]> 
       </programlisting>
      </informalexample>
     </para>
    </sect3>
   </sect2><!-- end syntax -->
   
   <sect2 id="language.types.array.useful-funcs">
    <title>Useful functions</title>
    <para>
     There are quite some useful function for working
     with arrays, see the <link linkend="ref.array">array
     functions</link> section.
    </para>
    <note>
     <para>
      The <function>unset</function> function allows unsetting keys of an 
      array. Be aware that the array will NOT be reindexed. If you only
      use "usual integer indices" (starting from zero, increasing by one),
      you can achive the reindex effect by using <function>array_values</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
$a = array(1 => 'one', 2 => 'two', 3 => 'three');
unset($a[2]);
/* will produce an array that would have been defined as
   $a = array(1 => 'one', 3 => 'three');
   and NOT
   $a = array(1 => 'one', 2 =>'three');
*/

$b = array_values($a);
// Now b is array(1 => 'one', 2 =>'three')
]]>
      </programlisting>
     </informalexample>
     
     </para>    
    </note> 
    <para>
     The <link linkend="control-structures.foreach">foreach</link> 
     control structure exists specifically for arrays. It 
     provides an easy way to traverse an array.
    </para>
   </sect2>
   
   <sect2 id="language.types.array.donts">
    <title>Array do's and don'ts</title>

    <sect3 id="language.types.array.foo-bar">
     <title>Why is <literal>$foo[bar]</literal> wrong?</title>
     <para>
      You should always use quotes around an associative array index.
      For example, use $foo['bar'] and not $foo[bar]. But why is $foo[bar]
      wrong? You might have seen the following syntax in old scripts:
      <informalexample>
       <programlisting role="php">
<![CDATA[
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
]]>
       </programlisting>
      </informalexample>
      This is wrong, but it works. Then, why is it wrong? The reason is that
      this code has an undefined constant (bar) rather than a string ('bar' -
      notice the quotes), and PHP may in future define constants which,
      unfortunately for your code, have the same name.  It works, because the
      undefined constant gets converted to a string of the same name
      automatically for backward compatibility reasons. 
     </para>
     <para>
      As stated in the <link linkend="language.types.array.syntax"
      >syntax</link> section, there must be an expression between the 
      square brackets ('<literal>[</literal>' and '<literal>]</literal>').
      That means that you can write things like this:
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo $arr[foo(true)];        
]]>
       </programlisting>
      </informalexample>
      This is an example of using a function return value
      as the array index. PHP also knows about constants,
      as you may have seen the <literal>E_*</literal> ones
      before.      

      <informalexample>
       <programlisting role="php">
<![CDATA[
$error_descriptions[E_ERROR]   = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE]  = "This is just an informal notice";
]]>
       </programlisting>
      </informalexample>
      Note that <literal>E_ERROR</literal> is also a valid identifier, 
      just like <literal>bar</literal> in the first example. But the last
      example is in fact the same as writing:
      <informalexample>
       <programlisting role="php">
<![CDATA[
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
]]>
       </programlisting>
      </informalexample>
      because <literal>E_ERROR</literal> equals <literal>1</literal>, etc.
     </para>
     <para>
      Then, how is it possible that <literal>$foo[bar]</literal> works?
      It works, because <literal>bar</literal> is due to its syntax
      expected to be a constant expression. However, in this case no 
      constant with the name <literal>bar</literal> exists. PHP now
      assumes that you meant <literal>bar</literal> literally, 
      as the string <literal>"bar"</literal>, but that you forgot
      to write the quotes.
     </para>
     <sect4>
      <title>So why is it bad then?</title>
      <para>
       At some point in the future, the PHP team might want to add another
       constant or keyword, or you may introduce another constant into your
       application, and then you get in trouble. For example,
       you already cannot use the words <literal>empty</literal> and 
       <literal>default</literal> this way, since they are special 
       <link linkend="reserved">reserved keywords</link>.
      </para>
      <note>
       <para>
        When you turn <link linkend="function.error-reporting"
        >error_reporting</link> to <literal>E_ALL</literal>,
        you will see that PHP generates notices whenever an
        <literal>index</literal> is used which is not defined.
        Consider this script:
        <informalexample>
         <programlisting role="php">
<![CDATA[
<?php

// Turn on the display of all errors
error_reporting(E_ALL);

// Define the test array
$abc = array("x" => "y");

// Access element with the *bad* method
echo $abc[x];

?>
]]>
         </programlisting>
        </informalexample>
        The output is:
        <informalexample>
         <programlisting>
<![CDATA[
<br />
<b>Notice</b>:  Use of undefined constant x - assumed 'x' in <b>/path/to/script.php</b> on
line <b>10</b><br />
]]>
         </programlisting>
        </informalexample>
       </para>
      </note>
      <note>
       <simpara>
        Inside a double-quoted <type>string</type>, another syntax
        is valid. See <link linkend="language.types.string.parsing"
        >variable parsing in strings</link> for more details.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.casting">
    <title>Converting to array</title>
    
    <para>
     For any of the types: integer, float, string, boolean and resource,
     if you convert a value to an array, you get an array with one element
     (with index 0), which is the scalar value you started with.
    </para>
    
    <para>
     If you convert an object to an array, you get the properties (member
     variables) of that object as the array's elements. The keys are the
     member variable names.
    </para>
    
    <para>
     If you convert a &null; value to an array, you get an empty array.
    </para>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>Examples</title>
    <para>
     The array type in PHP is very versatile, so here will be some 
     examples to show you the full power of arrays.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
// this
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
                       4        // key will be 0
          );

// is completely equivalent with
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // key will be 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// will result in the array array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// or simply array('a', 'b', 'c')
]]>
       </programlisting>
      </informalexample>
     </para>
    
    <example>
     <title>Using array()</title>
     <programlisting role="php">
<![CDATA[
// Array as (property-)map
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );
            
// strictly numerical keys
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// this is the same as array(0 => 7, 1 => 8, ...)

$switching = array(         10, // key = 0
                    5    =>  6,
                    3    =>  7, 
                    'a'  =>  4,
                            11, // key = 6 (maximum of integer-indices was 5)
                    '8'  =>  2, // key = 8 (integer!)
                    '02' => 77, // key = '02'
                    0    => 12  // the value 10 will be overwritten by 12
                  );
                  
// empty array
$empty = array();         
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>Collection</title>
     <programlisting role="php">
<![CDATA[
$colors = array('red', 'blue', 'green', 'yellow');

foreach ($colors as $color) {
    echo "Do you like $color?\n";
}

/* output:
Do you like red?
Do you like blue?
Do you like green?
Do you like yellow?
*/
]]>
     </programlisting>
    </example>
    
    <para>
     Note that it is currently not possible to change the values of the array
     directly in such a loop. 
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &$color )
      
       See bug#3074
      -->
     A workaround is the following: 
     <example id="language.types.array.examples.changeloop">
      <title>Collection</title>
      <programlisting role="php">
<![CDATA[
foreach ($colors as $key => $color) {
    // won't work:
    //$color = strtoupper($color);
    
    // works:
    $colors[$key] = strtoupper($color);
}
print_r($colors);

/* output:
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
*/
]]>
      </programlisting>
     </example>
    </para>
    <para>
     This example creates a one-based array.
     <example>
      <title>One-based index</title>
      <programlisting role="php">
<![CDATA[
$firstquarter  = array(1 => 'January', 'February', 'March');
print_r($firstquarter);

/* output:
Array 
(
    [1] => 'January'
    [2] => 'February'
    [3] => 'March'
)
*/
]]>   
      </programlisting>
     </example>
    </para>
    <example>
     <title>Filling an array</title>
     <programlisting role="php">
<![CDATA[
// fill an array with all items from a directory
$handle = opendir('.');
while ($file = readdir($handle)) {
    $files[] = $file;
}
closedir($handle); 
]]>
     </programlisting>
    </example>
    <para>
     Arrays are ordered. You can also change the order using various
     sorting-functions. See the <link linkend="ref.array">array
     functions</link> section for more information. You can count
     the number of items in an array using the
     <function>count</function> function.
    </para>
    <example>
     <title>Sorting array</title>
     <programlisting role="php">
<![CDATA[
sort($files);
print_r($files);
]]>
     </programlisting>
    </example>
    <para>
     Because the value of an array can be everything, it can also be 
     another array. This way you can make recursive and
     multi-dimensional arrays.
    </para>
    <example>
     <title>Recursive and multi-dimensional arrays</title>
     <programlisting role="php">
<![CDATA[
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6,
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// Some examples to address values in the array above 
echo $fruits["holes"][5];    // prints "second"
echo $fruits["fruits"]["a"]; // prints "orange"
unset($fruits["holes"][0]);  // remove "first"

// Create a new multi-dimensional array
$juices["apple"]["green"] = "good"; 
]]>
     </programlisting>
    </example>
    <para>
     You should be aware, that array assignment always involves
     value copying. You need to use the reference operator to copy
     an array by reference.
     <informalexample>
      <programlisting role="php">
<![CDATA[
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 is changed,
             // $arr1 is still array(2,3)
             
$arr3 = &$arr1;
$arr3[] = 4; // now $arr1 and $arr3 are the same
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Objects</title>

   <sect2 id="language.types.object.init">
    <title>Object Initialization</title>

    <para>
     To initialize an object, you use the <literal>new</literal>
     statement to instantiate the object to a variable.

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     For a full discussion, please read the section <link
     linkend="language.oop">Classes and Objects</link>.
    </simpara>
   </sect2>
   
   <sect2 id="language.types.object.casting">
    <title>Converting to object</title>
    
    <para>
     If an object is converted to an object, it is not modified. If a value
     of any other type is converted to an object, a new instace of the
     <literal>stdClass</literal> built in class is created. If the value
     was null, the new instance will be empty. For any other value, a
     member variable named <literal>scalar</literal> will contain the
     value.
     <informalexample>
      <programlisting role="php">
$obj = (object) 'ciao';
echo $obj-&gt;scalar;  // outputs 'ciao'
      </programlisting>
     </informalexample>
    </para>
   </sect2>
   
  </sect1>

  <sect1 id="language.types.resource">
   <title>Resource</title>
    
    <para>
     A resource is a special variable, holding
     a reference to an external resource. Resources
     are created and used by special functions.
     See the <link linkend="resource">appendix</link> 
     for a listing of all these
     functions and the corresponding resource types.
    </para>
    
    <note>
     <simpara>
      The resource type was introduced in PHP 4
     </simpara>
    </note>

   <sect2 id="language.types.resource.casting">
    <title>Converting to resource</title>
    
    <para>
     As resource types hold special handlers to opened
     files, database connections, image canvas areas and
     the like, you cannot convert any value to a resource.
    </para>
   </sect2>

    <sect2 id="language.types.resource.self-destruct">
     <title>Freeing resources</title>
    
    <para>
     Due to the reference-counting system introduced
     with PHP4's Zend-engine, it is automatically detected
     when a resource is no longer referred to (just
     like Java). When this is
     the case, all resources that were in use for this 
     resource are made free by the garbage collector.
     For this reason, it is rarely ever necessary to
     free the memory manually by using some free_result
     function.
     <note>
      <simpara>
       Persistent database links are special, they 
       are <emphasis>not</emphasis> destroyed by the 
       garbage collector. See also the section about <link 
       linkend="features.persistent-connections">persistent 
       connections</link>.
      </simpara>
     </note>
    </para>
    
   </sect2>
  </sect1>
    
  <sect1 id="language.types.null">
   <title>NULL</title>
    
   <para>
    The special &null; value represents 
    that a variable has no value. &null; is the only possible value of type
    <type>NULL</type>.
   </para>
    <note>
     <simpara>
      The null type was introduced in PHP 4
     </simpara>
    </note>
    <para>
     A variable is considered to be &null; if
     <itemizedlist>
      <listitem>
       <para>
        it has been assigned the constant &null;.
       </para>
      </listitem>
      <listitem>
       <para>
        it has not been set to any value yet.
       </para>
      </listitem>
      <listitem>
       <para>
        it has been <function>unset</function>.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    
   <sect2 id="language.types.null.syntax">
    <title>Syntax</title>
    <para>
     There is only one value of type &null;, and that is 
     the case-insensitive keyword &null;.
     <informalexample>
      <programlisting role="php">
$var = NULL;       
      </programlisting>
     </informalexample>
    </para>
    <para>
     See also <function>is_null</function> and <function>unset</function>.
    </para>
   </sect2>
  </sect1>
 
  <sect1 id="language.pseudo-types">
   <title>Pseudo-types used in this documentation</title> 

   <sect2 id="language.types.mixed">
    <title>mixed</title>
    <para>
     <literal>mixed</literal> indicates that a parameter may accept multiple (but not
     necesseraly all) types.
    </para>
    <para>
     <function>gettype</function> for example will accept all PHP types,
     while <function>str_replace</function> will accept strings and arrays.
    </para>
   </sect2>
  
   <sect2 id="language.types.number">
    <title>number</title>
    <para>
     <literal>number</literal> indicates that a parameter can be either
     <type>integer</type> or <type>float</type>.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title>callback</title>
    <para>
     Some functions like <function>call_user_function</function> 
     or <function>usort</function> accept user defined 
     callback functions as a parameter. Callback functions can not only
     be simple functions but also object methods including static class
     methods. 
    </para>
    <para>
     A PHP function is simply passed by its name as a string. You can
     pass any builtin or user defined function with the exception of 
     <function>array</function>, 
     <function>echo</function>, 
     <function>empty</function>, 
     <function>eval</function>, 
     <function>exit</function>, 
     <function>isset</function>, 
     <function>list</function>, 
     <function>print</function> and 
     <function>unset</function>.
    </para>
    <para>
     A method of an instantiated object is passed as an array containing
     an object as the element with index 0 and a method name as the 
     element with index 1.
    </para>
    <para>
     Static class methods can also be passed without instantiating an
     object of that class by passing the class name instead of an 
     object as the element with index 0.
    </para>

    <para>
     <example>
      <title>
       Callback function examples
      </title>
      <programlisting role="php">
<![CDATA[
<?php 

// simple callback example
function foobar() {
    echo "hello world!";
}
call_user_function("foobar"); 

// method callback examples
class foo {
  function bar() {
    echo "hello world!";
  }
}

$foo = new foo;

call_user_function(array($foo, "bar")); // object method call

call_user_function(array("foo", "bar")); // static class method call

?>
]]>
      </programlisting>
     </example>
    </para>  
   
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Type Juggling</title>

   <simpara>
    PHP does not require (or support) explicit type definition in
    variable declaration; a variable's type is determined by the
    context in which that variable is used. That is to say, if you
    assign a string value to variable <parameter>$var</parameter>,
    <parameter>$var</parameter> becomes a string. If you then assign an
    integer value to <parameter>$var</parameter>, it becomes an
    integer.
   </simpara>
   <para>
    An example of PHP's automatic type conversion is the addition
    operator '+'. If any of the operands is a float, then all
    operands are evaluated as floats, and the result will be a
    float. Otherwise, the operands will be interpreted as integers,
    and the result will also be an integer. Note that this does NOT
    change the types of the operands themselves; the only change is in
    how the operands are evaluated.
    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo is string (ASCII 48)
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)
-->
$foo += 2;   // $foo is now an integer (2)
$foo = $foo + 1.3;  // $foo is now a float (3.3)
$foo = 5 + "10 Little Piggies"; // $foo is integer (15)
$foo = 5 + "10 Small Pigs";     // $foo is integer (15)
<!--

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    If the last two examples above seem odd, see <link
    linkend="language.types.string.conversion">String
    conversion to numbers</link>.
   </simpara>
   <simpara>
    If you wish to force a variable to be evaluated as a certain type,
    see the section on <link linkend="language.types.typecasting">Type
    casting</link>. If you wish to change the type of a variable, see
    <function>settype</function>.
   </simpara>
   <para>
    If you would like to test any of the examples in this section, you
    can use the <function>var_dump</function> function.
   </para>
   <note>
    <para>
     The behaviour of an automatic conversion to array is currently
     undefined.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a is a string
$a[0] = "f";  // What about string offsets? What happens?
      </programlisting>
     </informalexample>
    </para>
    <para>
     Since PHP (for historical reasons) supports indexing into strings
     via offsets using the same syntax as array indexing, the example
     above leads to a problem: should $a become an array with its first
     element being "f", or should "f" become the first character of the
     string $a?
    </para>
    <para>
     The current versions of PHP interpret the second assignment as
     a string offset identification, so $a becomes "f", the result
     of this automatic conversion however should be considered
     undefined. PHP 4 introduced the new curly bracket syntax to access
     characters in string, use this syntax instead of the one presented
     above: 
     <informalexample>
      <programlisting role="php">
$a    = "abc"; // $a is a string
$a{1} = "f";   // $a is now "afc"
      </programlisting>
     </informalexample>
     See the section titled <link linkend="language.types.string.substr">String
     access by character</link> for more informaton.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Type Casting</title>

    <para>
     Type casting in PHP works much as it does in C: the name of the
     desired type is written in parentheses before the variable which
     is to be cast.
     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo is an integer
$bar = (boolean) $foo;   // $bar is a boolean
      </programlisting>
     </informalexample>
    </para>
    <para>
     The casts allowed are:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - cast to integer</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - cast to boolean</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - cast to float</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - cast to string</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - cast to array</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - cast to object</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Note that tabs and spaces are allowed inside the parentheses, so
     the following are functionally equivalent:
     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Instead of casting a variable to string, you can also enclose
      the variable in double quotes.
     <informalexample>
      <programlisting role="php">
$foo = 10;            // $foo is an integer
$str = "$foo";        // $str is a string
$fst = (string) $foo; // $fst is also a string

// This prints out that "they are the same"
if ($fst === $str) {
    echo "they are the same";
}
      </programlisting>
     </informalexample>
     </para>
    </note>
     
    <para>
     It may not be obvious exactly what will happen when casting
     between certain types. For more info, see these sections:
    
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Converting to 
        boolean</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Converting to 
        integer</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">Converting to 
        float</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Converting to 
        string</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Converting to 
        array</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Converting to 
        object</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Converting to 
        resource</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
        &null;</link></simpara>
      </listitem>
      -->
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
