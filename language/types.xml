<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.98 Maintainer: Kai Status: ready -->
<!-- $Revision: 1.1 $ -->
 <chapter id="language.types">
  <title>Типы</title>

   <!--
    Замечание:                        Последнее изменение заметки: 2003-09-01
     resource перевел как источник
     control structure = управляющая конструкция
     language.types.string.conversion = Конвертация строк в числа
     Arbitrary Precision Mathematics Functions=математические фукции произвольной точности
     String conversion to numbers = Конвертация строк в числа
     language.types.integer.casting = 
     и другие ссылки - уточнить
     heredoc-синтаксис - как перевести?
     Escaped characters
   -->

  <sect1 id="language.types.intro">
  <title>Введение</title>
  
  <simpara>
   PHP поддерживает восемь простых типов.
  </simpara>
  
  <para>
   Четыре скалярных типа:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.boolean">булев</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.integer">целое</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.float">число с плавающей точкой</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.string">строка</link>
     </simpara>
    </listitem>

   </itemizedlist>

   Два смешанных типа:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.array">массив</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.object">объект</link>
     </simpara>
    </listitem>

   </itemizedlist>

   И, наконец, два специальных типа:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.resource">источник</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.null">NULL</link>
     </simpara>
    </listitem>

   </itemizedlist>

   В этой документации также представлено несколько
   <link linkend="language.pseudo-types">псевдо-типов</link> 
   для удобства понимания:

   <itemizedlist>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">смешанный</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.number">число</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">обратный вызов (callback)</link>
     </simpara>
    </listitem>

   </itemizedlist>
   Вы также можете найти несколько упоминаний типа двойной точности.
   Рассматривайте его как число с плавающей точкой, два имени существуют только
   по историческим причинам.
  </para>
  
  <simpara>
   Как правило, программист не устанавливает тип переменной;
   предпочтительнее, чтобы это делал PHP во время выполнения программы в
   зависимости от контекста, в котором используется переменная.
  </simpara>
  <note>
   <simpara>
    Если вы желаете проверить тип и значение определенного <link
     linkend="language.expressions">выражения</link>, используйте
    <function>var_dump</function>.
   </simpara>
   <para>
    Если же вам для отладки необходимо просто удобочитаемое представление
    типа, используйте <function>gettype</function>. Чтобы проверить на
    определенный тип, <emphasis>не</emphasis> используйте <function>gettype</function>,
    применяйте для этого <literal>is_<replaceable>type</replaceable></literal>
    функции. Вот несколько примеров:
    <informalexample>
     <programlisting role="php">
<![CDATA[
$bool = TRUE;   // логический
$str  = "foo";  // строковый
$int  = 12;     // целочисленный

echo gettype($bool); // выводит "boolean"
echo gettype($str);  // выводит "string"

// Если это целое, увеличить на четыре
if (is_int($int)) {
    $int += 4;
}

// Если $bool - это строка, вывести ее
// (ничего не выводит)
if (is_string($bool)) {
    echo "Строка: $bool";
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>
  <simpara>
   Если вы хотите принудительно изменить тип переменной, вы можете либо
   <link linkend="language.types.typecasting">привести</link>
   переменную, либо использовать функцию <function>settype</function>.
  </simpara>
  <simpara>
   Обратите внимание, что переменная, в зависимости от ее типа в данный
   момент, в определенных ситуациях может иметь разные значения.
   Более подробную информацию смотрите в разделе <link
   linkend="language.types.type-juggling">Манипуляции с типами</link>.
  </simpara>
 </sect1>
   
   <sect1 id="language.types.boolean">
    <title>Булев</title>
    
    <simpara>
     Это простейший тип. Он выражает истинность значения - это может
     быть либо &true;, либо &false;. 
    </simpara>

    <note>
     <simpara>
      Булев тип был введен в PHP 4.
     </simpara>
    </note>

    <sect2 id="language.types.boolean.syntax">
     <title>Синтаксис</title>
     <para>
      Чтобы определить булев тип, используйте ключевое слово &true; 
      или &false;. Оба регистро-независимы.
      <informalexample>
       <programlisting role="php">
<![CDATA[
$foo = True; // определить $foo как TRUE
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Обычно вы используете некий
      <link linkend="language.operators">оператор</link>,
      который возвращает логическое выражение, а затем предает его
      <link linkend="control-structures">управляющей конструкции</link>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
// == это оператор, который проверяет
// эквивалентность и возвращает булево значение
if ($action == "показать_версию") {
    echo "Версия 1.23";
}

// это не обязательно...
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// ...потому что вы можете просто написать
if ($show_separators) {
    echo "<hr>\n";
}
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>Конвертация в булев тип</title>
      <simpara>
       Для несомненной конвертации значения в булев тип используйте привидение
       типа <literal>(bool)</literal> или <literal>(boolean)</literal>.
       Однако в большинстве случаев вам нет необходимости использовать привидение типа,
       поскольку значение будет автоматически конвертировано, если оператор, функция или 
       управляющая конструкция требует булев аргумент.
      </simpara>
      <simpara>
       Смотрите также <link linkend="language.types.type-juggling">Манипуляции с типами</link>.
      </simpara>
      
      <para>
       При конвертации в логический тип, следующие значения
       рассматриваются как &false;:
  
       <itemizedlist>
        <listitem>
         <simpara>Сам <link linkend="language.types.boolean">булев</link> 
          &false;</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.integer">целое</link
         > 0 (ноль) </simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.float">число с плавающей точкой</link> 
         0.0 (ноль) </simpara>
        </listitem>
        <listitem>
         <simpara>пустая <link linkend="language.types.string"
           >строка</link> и <link linkend="language.types.string"
           >строка</link>
           "0"</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.array">массив</link> 
         с нулевыми элементами</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.object">объект</link> 
         с нулевыми переменными-членами</simpara>
        </listitem>
        <listitem>
         <simpara>специальный тип <link linkend="language.types.null"
           >NULL</link> (включая неустановленные переменные)
         </simpara>
        </listitem>
       </itemizedlist>
       
       Все остальные значения рассматриваются как &true; (включая 
       любой <link linkend="language.types.resource">источник</link>).
       <warning>
        <simpara>
         <literal>-1</literal> считается &true;, как и любое
         ненулевое (отрицательное или положительное) число!
        </simpara>
       </warning>
       <informalexample>
        <programlisting role="php">
<![CDATA[
echo gettype((bool) "");        // bool(false)
echo gettype((bool) 1);         // bool(true)
echo gettype((bool) -2);        // bool(true)
echo gettype((bool) "foo");     // bool(true)
echo gettype((bool) 2.3e5);     // bool(true)
echo gettype((bool) array(12)); // bool(true)
echo gettype((bool) array());   // bool(false)
]]>
        </programlisting>
       </informalexample>
      </para>
     </sect2>
   </sect1>

   <sect1 id="language.types.integer">
    <title>Целые</title>
    
    <simpara>
     Целое это число из множества Z = {..., -2, -1, 0, 1, 2, ...}.
    </simpara>
     
    <para>
     Смотрите также:
     <link linkend="ref.gmp">Целые произвольной длины</link> и
     <link linkend="language.types.float">Числа с плавающей точкой</link>
    </para>

    <sect2 id="language.types.integer.syntax">
     <title>Синтаксис</title>
     <simpara>
      Целые могут быть указаны в десятичной, шестнадцатеричной или
      восьмеричной системе счисления, по желанию с предшествующим знаком (- или +).
     </simpara>
     <para>
      Если вы используете восьмеричную систему счисления, вы должны
      предварить число <literal>0</literal> (нулем), для использования
      шестнадцатеричной системы нужно поставить перед числом <literal>0x</literal>.
      <example>
       <title>Целые</title>
       <programlisting role="php">
<![CDATA[
$a = 1234; # десятичное число
$a = -123; # отрицательное число
$a = 0123; # восьмеричное число (эквивалентно 83 в десятичной системе)
$a = 0x1A; # шестнадцатеричное число (эквивалентно 26 в десятичной системе)
]]>
       </programlisting>
      </example>
      Формально возможная структура целых такова:
      <informalexample>
       <programlisting>
<![CDATA[
десятичные        : [1-9][0-9]*
                  | 0

шестнадцатеричные : 0[xX][0-9a-fA-F]+

восьмеричные      : 0[0-7]+

целые             : [+-]?десятичные
                  | [+-]?шестнадцатеричные
                  | [+-]?восьмеричные
]]>
       </programlisting>
      </informalexample>
      Размер целого зависит от платформы, хотя, как правило,
      максимальное значение около двух миллиардов
      (это 32-битное знаковое). PHP не поддерживает беззнаковые целые.
     </para>
    </sect2>
   
    <sect2 id="language.types.integer.overflow">
     <title>Превышение размера целого</title>
     <para>
      Если вы определите число, превышающее пределы целого типа, оно будет
      интерпретировано как число с плавающей точкой. Также, если вы
      используете оператор, результатом работы которого будет число,
      превышающее пределы целого, вместо него будет возвращено число с
      плавающей точкой.

      <informalexample>
       <programlisting role="php">
<![CDATA[
$large_number =  2147483647;
var_dump($large_number);
// вывод: int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// вывод: float(2147483648)

// это справедливо и для шестнадцатеричных целых:
var_dump( 0x80000000 );
// вывод: float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// вывод: float(50000000000)
]]>
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        К сожалению, в PHP была ошибка, так что это не всегда верно
        работает, когда используются отрицательные числа.
        Например: когда вы умножаете <literal>-50000 *
        $million</literal>, результатом будет
        <literal>-429496728</literal>. Однако, если оба операнда
        положительны, проблем не возникает.
       </simpara>
       <simpara>
        Эта ошибка устранена в PHP 4.1.0.
       </simpara>
      </warning>
     </para>
     <para>
      в PHP не существует оператора деления целых.
      Результатом <literal>1/2</literal> будет число с плавающей точкой
      <literal>0.5</literal>. Вы можете привести значение к целому, что
      всегда округляет его в меньшую сторону, либо использовать функцию
      <function>round</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
var_dump(25/7);         // float(3.5714285714286) 
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4) 
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>
   

    <sect2 id="language.types.integer.casting">
     <title>Конвертация в целое</title>
      <simpara>
       Для несомненной конвертации значения в целое используйте привидение
       типа <literal>(int)</literal> или <literal>(integer)</literal>.
       Однако в большинстве случаев вам нет необходимости использовать привидение типа,
       поскольку значение будет автоматически конвертировано, если оператор, функция или 
       управляющая конструкция требует целый аргумент. Вы также можете конвертировать
       значение в целое при помощи функции <function>intval</function>.
      </simpara>
      <simpara>
       Смотрите также <link linkend="language.types.type-juggling">Манипуляции с типами</link>.
      </simpara>
      
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>Из <link linkend="language.types.boolean"
           >булева</link> типа</title>
       <simpara>
        &false; конвертируется в
        <literal>0</literal> (ноль), а &true; 
        - в <literal>1</literal> (единицу).
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title>Из <link linkend="language.types.float">чисел с плавающей точкой</link></title> 
       <simpara>
        При конвертации из числа с плавющей точкой в целое, число будет
        округлено <emphasis>в сторону нуля</emphasis>.
       </simpara>
       
       <para>
        Если число с плавающей точкой превышает пределы целого
        (как правило, это <literal>+/- 2.15e+9 = 2^31</literal>), 
        результат будет неопределённым, так как целое не имеет достаточной
        точности, чтобы вернуть верный результат. В этом случае не будет
        выведено ни предупреждения, ни даже замечания!
       </para>
       
       <warning><para>
        Никогда не приводите неизвестную дробь к целому, так как это
        может иногда дать неожиданные результаты.
        <informalexample>
         <programlisting role="php">
<![CDATA[
echo (int) ( (0.1+0.7) * 10 ); // выводит 7!
]]>
         </programlisting>
        </informalexample>
        
        Смотрите более подробно: <link 
        linkend="warn.float-precision">предупреждение о точности
        числел с плавающей точкой</link>.
       </para></warning>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-string">
       <title>Из строк</title>
       <simpara>
        Смотрите <link linkend="language.types.string.conversion">Конвертация
        строк в числа</link>
       </simpara>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-other">
       <title>Из других типов</title>
       <para>
        <caution>
         <simpara>
          Для других типов поведение конвертации в целое не определено.
          В настоящее время поведение такое же, как если бы значение
          сперва было <link linkend="language.types.boolean.casting"
          >конвертировано в булев тип</link>. Однако
          <emphasis>не</emphasis> полагайтесь на это поведение, так
          как он может измениться без предупреждения.
         </simpara>
        </caution>
       </para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>Числа с плавющей точкой</title>
   <para>
    Числа с плавющей точкой (они же числа двойной точности или
    действительные числа) могут быть определены при помощи любого
    из следующих синтаксисов:
    <informalexample>
     <programlisting role="php">
$a = 1.234; $a = 1.2e3; $a = 7E-10;
     </programlisting>
    </informalexample>
    Формально:
    <informalexample>
     <programlisting role="php">
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
     </programlisting>
    </informalexample>
    Размер целого зависит от платформы, хотя максимум, как правило,
    ~1.8e308 с точностью около 14 десятичных цифр (это 64-битный
    IEEE-формат).
   </para>
 
   <warning id="warn.float-precision">
    <title>Точность числа с плавающей точкой</title>
    <para>
     Довольно часто простые десятичные дроби вроде
     <literal>0.1</literal> или <literal>0.7</literal> не могут быть
     конвертированы в свои внутренние двоичные аналоги без небольшой
     потери точности. Это может привести к неожиданным результатам:
     например, <literal>floor((0.1+0.7)*10)</literal> скорее всего
     возвратит <literal>7</literal> вместо ожидаемой
     <literal>8</literal> как результат внутреннего представления
     числа, являющегося в действительности чем-то вроде <literal>7.9999999999...</literal>.
    </para>
    <para>
     Это связано с невозможностью точно выразить некоторые дроби в
     десятичной системе счисления конечным числом цифр. Например,
     <literal>1/3</literal> в десятичной форме принимает вид
     <literal>0.3333333. . .</literal>.
    </para>
    <para>
     Так что никогда не доверяйте точности последних цифр в результатах
     с числами с плавающей точкой и никогда не проверяйте их на
     равенство. Если вам дейсвительно необходима высокая точность, вам
     следует использовать <link
     linkend="ref.bc">математические функции произвольной точности</link>
     или <link linkend="ref.gmp">gmp</link>-функции.
    </para>
   </warning>

   <sect2 id="language.types.float.casting">
    <title>Конвертация в число с плавающей точкой</title>
    
    <para>
     О том когда и как строки конвертируются в числа с плавающей точкой
     читайте в разделе <link linkend="language.types.string.conversion">Конвертация
     строк в числа</link>. Для значений других типов конвертация будет
     такой же, как если бы значение сначала было конвертировано в целое,
     а затем в число с плавающей точкой. Дополнительную информацию
     смотрите в разделе <link linkend="language.types.integer.casting">Конвертация
     в целое</link>.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.string">
   <title>Строки</title>
   <para>
    Строка - это набор символов. В PHP символ это то же самое, что
    и байт, это значит, что возможно ровно 256 различных символов.
    Это также означает, что PHP не имеет встроенной поддержки
    Unicode'а. Некоторую поддержку Unicode'а обеспечивают эти
    функции <function>utf8_enncode</function> и
    <function>utf8_decode</function>.
   </para>
   <note>
    <simpara>
     Нет никаких проблем, если строка очень велика. Практически
     не существует ограничений на размер строк, налагаемых PHP,
     так что нет абсолютно никаких причин беспокоиться об их
     длине.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>Синтаксис</title>
    <para>
     Строка может быть определена тремя различными способами.
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">одинарными кавчками</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">двойными кавычками</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">heredoc-синтаксисом</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>Одинарные кавычки</title>
     <para>
      Простейший способ определить строку - это заключить ее в
      одинарные кавычки (символ <literal>'</literal>). 
     </para>
     <para>
      Чтобы использовать одинарную кавычку внутри строки,
      как и во многих других языках, ее необходимо предварить
      символом обратной косой черты (<literal>\</literal>),
      т. е. мнемонизировать ее. Если обратная наклонная черта
      должна идти перед одинарной кавычкой либо быть в конце
      строки, вам необходимо продублировать ее. Обратите
      внимание, что если вы попытаетесь мнемонизировать любой
      другой символ, обратная косая черта также будет напечатана!
      Так что, как правило, нет необходимости мнемонизировать
      саму обратную косую черту.
      <note>
       <simpara>
        В PHP 3 в данном случае будет выдано сообщение уровня
        <literal>E_NOTICE</literal>.
       </simpara>
      </note>
      <note>
       <simpara>
        В отличие от двух других синтаксисов, переменные,
        встречающиеся в строках, заключенных в одинарные
        кавычки, <emphasis>не</emphasis> обрабатываются.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo ''это простая строка';
echo 'Вы можете вставлять в строки символ новой строки
таким образом';
echo 'Однажды Арнольд сказал: "I\'ll be back"';
// вывод: ... "I'll be back"
echo 'Вы уверены, что хотите удалить C:\\*.*?';
// вывод: ... удалить C:\*.*?
echo 'Вы уверены, что хотите удалить C:\*.*?';
// вывод: ... удалить C:\*.*?
echo 'Я пытаюсь вставить в этой точке: \n символ новой строки';
// вывод: ... в этой точке: \n символ новой строки
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>Двойные кавычки</title>
     <para>
      Если строка заключена в двойные кавычки ("),
      PHP распознает большее количество мнемоник специальных символов:
     </para>
     <table>
      <title>Мнемоники символов</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>последовательность</entry>
         <entry>значение</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>новая строка (LF или 0x0A (10) в ASCII)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>возврат каретки (CR или 0x0D (13) в ASCII)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>горизонтальная табуляция (HT или 0x09 (9) в ASCII)</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>обратная наклонная черта</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>знак доллара</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>двойная кавычка</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          последовательность символов, соответсвующая
          регулярному выражению, символ в восьмеричной
          системе счисления
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          последовательность символов, соответсвующая
          регулярному выражению, символ в шестнадцатеричной
          системе счисления
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Повторяем, если вы захотите мнемнонизировать любой другой
      символ, обратная косая черта также будет напечатана!
     </para>
     <para>
      Но самым важным свойством строк в двойных кавычках является
      обработка переменных.
      Смотрите более подробно: <link linkend="language.types.string.parsing">обработка 
      строк</link>.
     </para>
    </sect3>
    
    <sect3 id="language.types.string.syntax.heredoc">
     <title>Heredoc</title>
     <simpara>
      Другой способ определения строк - это использование
      heredoc-синтаксиса ("&lt;&lt;&lt;"). One should provide an identifier after
      <literal>&lt;&lt;&lt;</literal>, then the string, and then the
      same identifier to close the quotation. 
     </simpara>
     <simpara>
      The closing identifier <emphasis>must</emphasis> begin in the
      first column of the line. Also, the identifier used must follow
      the same naming rules as any other label in PHP: it must contain
      only alphanumeric characters and underscores, and must start with
      a non-digit character or underscore.
     </simpara>
     
     <warning>
      <simpara>
       It is very important to note that the line with the closing
       identifier contains no other characters, except 
       <emphasis>possibly</emphasis> a semicolon (<literal>;</literal>).
       That means especially that the identifier 
       <emphasis>may not be indented</emphasis>, and there
       may not be any spaces or tabs after or before the semicolon.
      </simpara>
     </warning>

     <para>
      Heredoc text behaves just like a double-quoted string, without
      the double-quotes. This means that you do not need to escape quotes
      in your here docs, but you can still use the escape codes listed
      above. Variables are expanded, but the same care must be taken
      when expressing complex variables inside a here doc as with
      strings.
      <example> 
       <title>Heredoc string quoting example</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* More complex example, with variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>
  
     <note>
      <para>
       Heredoc support was added in PHP 4.
      </para>
     </note>
    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>Variable parsing</title>
     <simpara>
      When a string is specified in double quotes or with
      heredoc, variables are parsed within it.
     </simpara>
     <simpara>
      There are two types of syntax, a 
      <link linkend="language.types.string.parsing.simple">simple</link>
      one and a 
      <link linkend="language.types.string.parsing.complex">complex</link>
      one.
      The simple syntax is the most common and convenient, it provides a way
      to parse a variable, an array value, or an object property.
     </simpara>
     <simpara>
      The complex syntax was introduced in PHP 4, and can be recognised
      by the curly braces surrounding the expression.
     </simpara>

     <sect4 id="language.types.string.parsing.simple">
      <title>Simple syntax</title>
      <simpara>
       If a dollar sign (<literal>$</literal>) is encountered, the
       parser will greedily take as much tokens as possible to form a
       valid variable name. Enclose the variable name in curly
       braces if you want to explicitly specify the end of the name.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$beer = 'Heineken';
echo "$beer's taste is great"; // works, "'" is an invalid character for varnames
echo "He drank some $beers";   // won't work, 's' is a valid character for varnames
echo "He drank some ${beer}s"; // works
]]>
       </programlisting>
      </informalexample>
      <simpara>
       Similarly, you can also have an array index or an object
       property parsed. With array indices, the closing square bracket
       (<literal>]</literal>) marks the end of the index. For
       object properties the same rules apply as to simple variables,
       though with object properties there doesn't exist a trick like
       the one with variables.
       
       <!-- XXX isn't &true; :(, this would be the trick
       Also, the same trick with curly-braces works if you
       want to limit the greediness of parsers.
       -->
      
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$fruits = array('strawberry' => 'red', 'banana' => 'yellow');

// note that this works differently outside string-quotes
echo "A banana is $fruits[banana].";

echo "This square is $square->width meters broad.";

// Won't work. For a solution, see the complex syntax.
echo "This square is $square->width00 centimeters broad.";

]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       For anything more complex, you should use the complex syntax.
      </simpara>
     </sect4>

     <sect4 id="language.types.string.parsing.complex">
      <title>Complex (curly) syntax</title>
      <simpara>
       This isn't called complex because the syntax is complex,
       but because you can include complex expressions this way.
     </simpara>
     <simpara>
      In fact, you can include any value that is in the namespace
      in strings with this syntax. You simply write the expression
      the same way as you would outside the string, and then include
      it in { and }. Since you can't escape '{', this syntax will
      only be recognised when the $ is immediately following the {.
      (Use "{\$" or "\{$" to get a literal "{$").
      Some examples to make it clear:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
$great = 'fantastic';
echo "This is { $great}"; // won't work, outputs: This is { fantastic}
echo "This is {$great}";  // works, outputs: This is fantastic
echo "This square is {$square->width}00 centimeters broad."; 
echo "This works: {$arr[4][3]}";

// This is wrong for the same reason
// as $foo[bar] is wrong outside a string. 
echo "This is wrong: {$arr[foo][3]}"; 

echo "You should do it this way: {$arr['foo'][3]}";
echo "You can even write {$obj->values[3]->name}";
echo "This is the value of the var named $name: {${$name}}";
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>String access by character</title>
     <para>
      Characters within strings may be accessed by specifying the
      zero-based offset of the desired character after the string 
      in curly braces.
     </para>
     <note>
      <simpara>
       For backwards compatibility, you can still use array-braces
       for the same purpose. However, this syntax is deprecated as
       of PHP 4.
      </simpara>
     </note>
     <para>
      <example>
       <title>Some string examples</title>
       <programlisting role="php">
<![CDATA[
<?php
// Get the first character of a string
$str = 'This is a test.';
$first = $str{0};

// Get the last character of a string.
$str = 'This is still a test.';
$last = $str{strlen($str)-1}; 
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>Useful functions and operators</title>
    <para>
     Strings may be concatenated using the '.' (dot) operator. Note
     that the '+' (addition) operator will not work for this. Please
     see <link linkend="language.operators.string">String
     operators</link> for more information.
    </para>
    <para>
     There are a lot of useful functions for string modification.
    </para>
    <simpara>
     See the <link linkend="ref.strings">string functions section</link> 
     for general functions, the regular expression functions for
     advanced find&amp;replacing (in two tastes: 
     <link linkend="ref.pcre">Perl</link> and 
     <link linkend="ref.regex">POSIX extended</link>).
    </simpara>
    <simpara>
     There are also <link linkend="ref.url">functions for URL-strings</link>,
     and functions to encrypt/decrypt strings 
     (<link linkend="ref.mcrypt">mcrypt</link> and 
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Finally, if you still didn't find what you're looking for,
     see also the <link linkend="ref.ctype">character type functions</link>.
    </simpara>
   </sect2>

   <sect2 id="language.types.string.casting">
    <title>Converting to string</title>
    
    <para>
     You can convert a value to a string using the <literal>(string)</literal>
     cast, or the <function>strval</function> function. String conversion
     is automatically done in the scope of an expression for you where a
     string is needed. This happens when you use the <function>echo</function>
     or <function>print</function> functions, or when you compare a variable
     value to a string.
    </para>
    
    <para>
     A boolean &true; value is converted to the string <literal>"1"</literal>,
     the &false; value is represented as <literal>""</literal> (empty string).
     This way you can convert back and forth between boolean and string values.
    </para>
    <para> 
     An integer or a floating point number is converted to a string
     representing the number with its digits (includig the exponent part
     for floating point numbers).
    </para>
    <para>
     Arrays are always converted to the string <literal>"Array"</literal>,
     so you cannot dump out the contents of an array with <function>echo</function>
     or <function>print</function> to see what is inside them. See the information
     below for more tips.
    </para>
    <para>
     Objects are always converted to the string <literal>"Object"</literal>.
     If you would like to print out the member variable values of an object
     for debugging reasons, read the paragraphs below. If you would
     like to find out the class name of which an object is an instance of,
     use <function>get_class</function>.  
    </para>
    <para>
     Resources are always converted to strings with the structure
     <literal>"Resource id #1"</literal> where <literal>1</literal> is
     the unique number of the resource assigned by PHP during runtime.
     If you would like to get the type of the resource, use
     <function>get_resource_type</function>.
    </para>
    <para>
     &null; is always converted to an empty string.
    </para>
    
    <para>
     As you can see above, printing out the arrays, objects or resources does not
     provide you any useful information about the values themselfs. Look at the
     functions <function>print_r</function> and <function>var_dump</function>
     for better ways to print out values for debugging.
    </para>
    
    <para>
     You can also convert PHP values to strings to store them permanently. This
     method is called serialization, and can be done with the function
     <function>serialize</function>. You can also serialize PHP values to
     XML structures, if you have <link linkend="ref.wddx">WDDX</link> support
     in your PHP setup.
    </para>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>String conversion to numbers</title>

    <simpara>
     When a string is evaluated as a numeric value, the resulting
     value and type are determined as follows.
    </simpara>
    <simpara>
     The string will evaluate as a <type>float</type> if it contains any of the
     characters '.', 'e', or 'E'. Otherwise, it will evaluate as an
     integer.
    </simpara>
    <para>
     The value is given by the initial portion of the string. If the
     string starts with valid numeric data, this will be the value
     used. Otherwise, the value will be 0 (zero). Valid numeric data
     is an optional sign, followed by one or more digits (optionally
     containing a decimal point), followed by an optional
     exponent. The exponent is an 'e' or 'E' followed by one or more
     digits.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$foo = 1 + "10.5";              // $foo is float (11.5)
$foo = 1 + "-1.3e3";            // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";         // $foo is integer (1)
$foo = 1 + "bob3";              // $foo is integer (1)
$foo = 1 + "10 Small Pigs";     // $foo is integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
$foo = "10.0 pigs " + 1;        // $foo is float (11)
$foo = "10.0 pigs " + 1.0;      // $foo is float (11)     
]]>
     </programlisting>
    </informalexample>
    <simpara>
     For more information on this conversion, see the Unix manual page
     for strtod(3).
    </simpara>
    <para>
     If you would like to test any of the examples in this section,
     you can cut and paste the examples and insert the following line
     to see for yourself what's going on:
     <informalexample>
      <programlisting role="php">
<![CDATA[
echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Do not expect to get the code of one character by converting it
     to integer (as you would do in C for example). Use the functions
     <function>ord</function> and <function>chr</function> to convert
     between charcodes and characters.
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>Arrays</title>

   <para>
    An array in PHP is actually an ordered map. A map is a type that
    maps <emphasis>values</emphasis> to <emphasis>keys</emphasis>. 
    This type is optimized in several ways,
    so you can use it as a real array, or a list (vector), 
    hashtable (which is an implementation of a map), 
    dictionary, collection,
    stack, queue and probably more. Because you can have another
    PHP-array as a value, you can also quite easily simulate
    trees.
   </para>
   <para>
    Explanation of those structures is beyond the scope of this manual,
    but you'll find at least one example for each of those structures.
    For more information we refer you to external literature about
    this broad topic.
   </para>
   
   <sect2 id="language.types.array.syntax">
    <title>Syntax</title>
    
    <sect3 id="language.types.array.syntax.array-func">
     <title>Specifying with <function>array</function></title>
     <para>
      An <type>array</type> can be created by the <function>array</function> 
      language-construct. It takes a certain number of comma-separated
      <literal><replaceable>key</replaceable> =&gt; <replaceable
      >value</replaceable></literal>
      pairs.
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> <replaceable
>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> is either <type>string</type
                        > or nonnegative <type>integer</type>
// <replaceable>value</replaceable> can be anything
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
array("foo" => "bar", 12 => true);
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      A <varname>key</varname> is either an <type>integer</type> 
      or a <type>string</type>. If a key is the standard representation
      of an <type>integer</type>, it will be interpreted as such (i.e.
      <literal>"8"</literal> will be interpreted as <literal>8</literal>,
      while <literal>"08"</literal> will be interpreted as
      <literal>"08"</literal>). There are no different indexed and
      associative array types in PHP, there is only one array type,
      which can both contain integer and string indices.
     </para>
     <para>
      A value can be of any PHP type.
      <informalexample>
       <programlisting role="php">
<![CDATA[
array("somearray" => array(6 => 5, 13 => 9, "a" => 43));
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      If you omit a key, the maximum of the integer-indices is taken, and
      the new key will be that maximum + 1. As integers can be negative,
      this is also true for negative indices. Having e.g. the highest index
      being <literal>-6</literal> will result in being <literal>-5</literal>
      the new key. If no integer-indices exist
      yet, the key will be <literal>0</literal> (zero). If you specify a key
      that already has a value assigned to it, that value will be overwritten.
      <informalexample>
       <programlisting role="php">
<![CDATA[
// This array is the same as ...
array(5 => 43, 32, 56, "b" => 12);

// ...this array
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Using &true; as a key will evalute to
      <type>integer</type> <literal>1</literal> as key. Using
      &false; as a key will evalute to <type>integer</type>
      <literal>0</literal> as key. Using <literal>NULL</literal> as a key
      will evaluate to an empty string. Using an emptry string as key will
      create (or overwrite) a key with an empty string and its value, it is
      not the same as using empty brackets.
     </para>
     <para>
      You cannot use arrays or objects as keys. Doing so will result in a
      warning: <literal>Illegal offset type</literal>.
     </para>
    </sect3>
    
    <sect3 id="language.types.array.syntax.modifying">
     <title>Creating/modifying with square-bracket syntax</title>
     <para>
      You can also modify an existing array, by explicitly setting
      values in it.
     </para>
     <para>
      This is done by assigning values to the array while specifying the 
      key in brackets. You can also omit the key, add an empty pair
      of brackets ("<literal>[]</literal>") to the variable-name in that case.
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> is either <type>string</type
                        > or nonnegative <type>integer</type>
// <replaceable>value</replaceable> can be anything
      </synopsis>
      If <varname>$arr</varname> doesn't exist yet, it will be created. 
      So this is also an alternative way to specify an array.
      To change a certain value, just assign a new value
      to an element specified with its key. If you want to
      remove a key/value pair, you need to <function>unset</function> it. 
      <informalexample>
       <programlisting role="php">
<![CDATA[
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // This is the same as $arr[13] = 56;
                // at this point of the script

$arr["x"] = 42; // This adds a new element to
                // the array with key "x"
                
unset($arr[5]); // This removes the element from the array

unset($arr);    // This deletes the whole array
]]> 
       </programlisting>
      </informalexample>
     </para>
    </sect3>
   </sect2><!-- end syntax -->
   
   <sect2 id="language.types.array.useful-funcs">
    <title>Useful functions</title>
    <para>
     There are quite some useful function for working
     with arrays, see the <link linkend="ref.array">array
     functions</link> section.
    </para>
    <note>
     <para>
      The <function>unset</function> function allows unsetting keys of an 
      array. Be aware that the array will NOT be reindexed. If you only
      use "usual integer indices" (starting from zero, increasing by one),
      you can achive the reindex effect by using <function>array_values</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
$a = array(1 => 'one', 2 => 'two', 3 => 'three');
unset($a[2]);
/* will produce an array that would have been defined as
   $a = array(1 => 'one', 3 => 'three');
   and NOT
   $a = array(1 => 'one', 2 =>'three');
*/

$b = array_values($a);
// Now b is array(1 => 'one', 2 =>'three')
]]>
      </programlisting>
     </informalexample>
     
     </para>    
    </note> 
    <para>
     The <link linkend="control-structures.foreach">foreach</link> 
     control structure exists specifically for arrays. It 
     provides an easy way to traverse an array.
    </para>
   </sect2>
   
   <sect2 id="language.types.array.donts">
    <title>Array do's and don'ts</title>

    <sect3 id="language.types.array.foo-bar">
     <title>Why is <literal>$foo[bar]</literal> wrong?</title>
     <para>
      You should always use quotes around an associative array index.
      For example, use $foo['bar'] and not $foo[bar]. But why is $foo[bar]
      wrong? You might have seen the following syntax in old scripts:
      <informalexample>
       <programlisting role="php">
<![CDATA[
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
]]>
       </programlisting>
      </informalexample>
      This is wrong, but it works. Then, why is it wrong? The reason is that
      this code has an undefined constant (bar) rather than a string ('bar' -
      notice the quotes), and PHP may in future define constants which,
      unfortunately for your code, have the same name.  It works, because the
      undefined constant gets converted to a string of the same name
      automatically for backward compatibility reasons. 
     </para>
     <para>
      As stated in the <link linkend="language.types.array.syntax"
      >syntax</link> section, there must be an expression between the 
      square brackets ('<literal>[</literal>' and '<literal>]</literal>').
      That means that you can write things like this:
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo $arr[foo(true)];        
]]>
       </programlisting>
      </informalexample>
      This is an example of using a function return value
      as the array index. PHP also knows about constants,
      as you may have seen the <literal>E_*</literal> ones
      before.      

      <informalexample>
       <programlisting role="php">
<![CDATA[
$error_descriptions[E_ERROR]   = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE]  = "This is just an informal notice";
]]>
       </programlisting>
      </informalexample>
      Note that <literal>E_ERROR</literal> is also a valid identifier, 
      just like <literal>bar</literal> in the first example. But the last
      example is in fact the same as writing:
      <informalexample>
       <programlisting role="php">
<![CDATA[
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
]]>
       </programlisting>
      </informalexample>
      because <literal>E_ERROR</literal> equals <literal>1</literal>, etc.
     </para>
     <para>
      Then, how is it possible that <literal>$foo[bar]</literal> works?
      It works, because <literal>bar</literal> is due to its syntax
      expected to be a constant expression. However, in this case no 
      constant with the name <literal>bar</literal> exists. PHP now
      assumes that you meant <literal>bar</literal> literally, 
      as the string <literal>"bar"</literal>, but that you forgot
      to write the quotes.
     </para>
     <sect4>
      <title>So why is it bad then?</title>
      <para>
       At some point in the future, the PHP team might want to add another
       constant or keyword, or you may introduce another constant into your
       application, and then you get in trouble. For example,
       you already cannot use the words <literal>empty</literal> and 
       <literal>default</literal> this way, since they are special 
       <link linkend="reserved">reserved keywords</link>.
      </para>
      <note>
       <para>
        When you turn <link linkend="function.error-reporting"
        >error_reporting</link> to <literal>E_ALL</literal>,
        you will see that PHP generates notices whenever an
        <literal>index</literal> is used which is not defined.
        Consider this script:
        <informalexample>
         <programlisting role="php">
<![CDATA[
<?php

// Turn on the display of all errors
error_reporting(E_ALL);

// Define the test array
$abc = array("x" => "y");

// Access element with the *bad* method
echo $abc[x];

?>
]]>
         </programlisting>
        </informalexample>
        The output is:
        <informalexample>
         <programlisting>
<![CDATA[
<br />
<b>Notice</b>:  Use of undefined constant x - assumed 'x' in <b>/path/to/script.php</b> on
line <b>10</b><br />
]]>
         </programlisting>
        </informalexample>
       </para>
      </note>
      <note>
       <simpara>
        Inside a double-quoted <type>string</type>, another syntax
        is valid. See <link linkend="language.types.string.parsing"
        >variable parsing in strings</link> for more details.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.casting">
    <title>Converting to array</title>
    
    <para>
     For any of the types: integer, float, string, boolean and resource,
     if you convert a value to an array, you get an array with one element
     (with index 0), which is the scalar value you started with.
    </para>
    
    <para>
     If you convert an object to an array, you get the properties (member
     variables) of that object as the array's elements. The keys are the
     member variable names.
    </para>
    
    <para>
     If you convert a &null; value to an array, you get an empty array.
    </para>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>Examples</title>
    <para>
     The array type in PHP is very versatile, so here will be some 
     examples to show you the full power of arrays.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
// this
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
                       4        // key will be 0
          );

// is completely equivalent with
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // key will be 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// will result in the array array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// or simply array('a', 'b', 'c')
]]>
       </programlisting>
      </informalexample>
     </para>
    
    <example>
     <title>Using array()</title>
     <programlisting role="php">
<![CDATA[
// Array as (property-)map
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );
            
// strictly numerical keys
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// this is the same as array(0 => 7, 1 => 8, ...)

$switching = array(         10, // key = 0
                    5    =>  6,
                    3    =>  7, 
                    'a'  =>  4,
                            11, // key = 6 (maximum of integer-indices was 5)
                    '8'  =>  2, // key = 8 (integer!)
                    '02' => 77, // key = '02'
                    0    => 12  // the value 10 will be overwritten by 12
                  );
                  
// empty array
$empty = array();         
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>Collection</title>
     <programlisting role="php">
<![CDATA[
$colors = array('red', 'blue', 'green', 'yellow');

foreach ($colors as $color) {
    echo "Do you like $color?\n";
}

/* output:
Do you like red?
Do you like blue?
Do you like green?
Do you like yellow?
*/
]]>
     </programlisting>
    </example>
    
    <para>
     Note that it is currently not possible to change the values of the array
     directly in such a loop. 
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &$color )
      
       See bug#3074
      -->
     A workaround is the following: 
     <example id="language.types.array.examples.changeloop">
      <title>Collection</title>
      <programlisting role="php">
<![CDATA[
foreach ($colors as $key => $color) {
    // won't work:
    //$color = strtoupper($color);
    
    // works:
    $colors[$key] = strtoupper($color);
}
print_r($colors);

/* output:
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
*/
]]>
      </programlisting>
     </example>
    </para>
    <para>
     This example creates a one-based array.
     <example>
      <title>One-based index</title>
      <programlisting role="php">
<![CDATA[
$firstquarter  = array(1 => 'January', 'February', 'March');
print_r($firstquarter);

/* output:
Array 
(
    [1] => 'January'
    [2] => 'February'
    [3] => 'March'
)
*/
]]>   
      </programlisting>
     </example>
    </para>
    <example>
     <title>Filling an array</title>
     <programlisting role="php">
<![CDATA[
// fill an array with all items from a directory
$handle = opendir('.');
while ($file = readdir($handle)) {
    $files[] = $file;
}
closedir($handle); 
]]>
     </programlisting>
    </example>
    <para>
     Arrays are ordered. You can also change the order using various
     sorting-functions. See the <link linkend="ref.array">array
     functions</link> section for more information. You can count
     the number of items in an array using the
     <function>count</function> function.
    </para>
    <example>
     <title>Sorting array</title>
     <programlisting role="php">
<![CDATA[
sort($files);
print_r($files);
]]>
     </programlisting>
    </example>
    <para>
     Because the value of an array can be everything, it can also be 
     another array. This way you can make recursive and
     multi-dimensional arrays.
    </para>
    <example>
     <title>Recursive and multi-dimensional arrays</title>
     <programlisting role="php">
<![CDATA[
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6,
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// Some examples to address values in the array above 
echo $fruits["holes"][5];    // prints "second"
echo $fruits["fruits"]["a"]; // prints "orange"
unset($fruits["holes"][0]);  // remove "first"

// Create a new multi-dimensional array
$juices["apple"]["green"] = "good"; 
]]>
     </programlisting>
    </example>
    <para>
     You should be aware, that array assignment always involves
     value copying. You need to use the reference operator to copy
     an array by reference.
     <informalexample>
      <programlisting role="php">
<![CDATA[
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 is changed,
             // $arr1 is still array(2,3)
             
$arr3 = &$arr1;
$arr3[] = 4; // now $arr1 and $arr3 are the same
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Objects</title>

   <sect2 id="language.types.object.init">
    <title>Object Initialization</title>

    <para>
     To initialize an object, you use the <literal>new</literal>
     statement to instantiate the object to a variable.

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     For a full discussion, please read the section <link
     linkend="language.oop">Classes and Objects</link>.
    </simpara>
   </sect2>
   
   <sect2 id="language.types.object.casting">
    <title>Converting to object</title>
    
    <para>
     If an object is converted to an object, it is not modified. If a value
     of any other type is converted to an object, a new instace of the
     <literal>stdClass</literal> built in class is created. If the value
     was null, the new instance will be empty. For any other value, a
     member variable named <literal>scalar</literal> will contain the
     value.
     <informalexample>
      <programlisting role="php">
$obj = (object) 'ciao';
echo $obj-&gt;scalar;  // outputs 'ciao'
      </programlisting>
     </informalexample>
    </para>
   </sect2>
   
  </sect1>

  <sect1 id="language.types.resource">
   <title>Resource</title>
    
    <para>
     A resource is a special variable, holding
     a reference to an external resource. Resources
     are created and used by special functions.
     See the <link linkend="resource">appendix</link> 
     for a listing of all these
     functions and the corresponding resource types.
    </para>
    
    <note>
     <simpara>
      The resource type was introduced in PHP 4
     </simpara>
    </note>

   <sect2 id="language.types.resource.casting">
    <title>Converting to resource</title>
    
    <para>
     As resource types hold special handlers to opened
     files, database connections, image canvas areas and
     the like, you cannot convert any value to a resource.
    </para>
   </sect2>

    <sect2 id="language.types.resource.self-destruct">
     <title>Freeing resources</title>
    
    <para>
     Due to the reference-counting system introduced
     with PHP4's Zend-engine, it is automatically detected
     when a resource is no longer referred to (just
     like Java). When this is
     the case, all resources that were in use for this 
     resource are made free by the garbage collector.
     For this reason, it is rarely ever necessary to
     free the memory manually by using some free_result
     function.
     <note>
      <simpara>
       Persistent database links are special, they 
       are <emphasis>not</emphasis> destroyed by the 
       garbage collector. See also the section about <link 
       linkend="features.persistent-connections">persistent 
       connections</link>.
      </simpara>
     </note>
    </para>
    
   </sect2>
  </sect1>
    
  <sect1 id="language.types.null">
   <title>NULL</title>
    
   <para>
    The special &null; value represents 
    that a variable has no value. &null; is the only possible value of type
    <type>NULL</type>.
   </para>
    <note>
     <simpara>
      The null type was introduced in PHP 4
     </simpara>
    </note>
    <para>
     A variable is considered to be &null; if
     <itemizedlist>
      <listitem>
       <para>
        it has been assigned the constant &null;.
       </para>
      </listitem>
      <listitem>
       <para>
        it has not been set to any value yet.
       </para>
      </listitem>
      <listitem>
       <para>
        it has been <function>unset</function>.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    
   <sect2 id="language.types.null.syntax">
    <title>Syntax</title>
    <para>
     There is only one value of type &null;, and that is 
     the case-insensitive keyword &null;.
     <informalexample>
      <programlisting role="php">
$var = NULL;       
      </programlisting>
     </informalexample>
    </para>
    <para>
     See also <function>is_null</function> and <function>unset</function>.
    </para>
   </sect2>
  </sect1>
 
  <sect1 id="language.pseudo-types">
   <title>Pseudo-types used in this documentation</title> 

   <sect2 id="language.types.mixed">
    <title>mixed</title>
    <para>
     <literal>mixed</literal> indicates that a parameter may accept multiple (but not
     necesseraly all) types.
    </para>
    <para>
     <function>gettype</function> for example will accept all PHP types,
     while <function>str_replace</function> will accept strings and arrays.
    </para>
   </sect2>
  
   <sect2 id="language.types.number">
    <title>number</title>
    <para>
     <literal>number</literal> indicates that a parameter can be either
     <type>integer</type> or <type>float</type>.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title>callback</title>
    <para>
     Some functions like <function>call_user_function</function> 
     or <function>usort</function> accept user defined 
     callback functions as a parameter. Callback functions can not only
     be simple functions but also object methods including static class
     methods. 
    </para>
    <para>
     A PHP function is simply passed by its name as a string. You can
     pass any builtin or user defined function with the exception of 
     <function>array</function>, 
     <function>echo</function>, 
     <function>empty</function>, 
     <function>eval</function>, 
     <function>exit</function>, 
     <function>isset</function>, 
     <function>list</function>, 
     <function>print</function> and 
     <function>unset</function>.
    </para>
    <para>
     A method of an instantiated object is passed as an array containing
     an object as the element with index 0 and a method name as the 
     element with index 1.
    </para>
    <para>
     Static class methods can also be passed without instantiating an
     object of that class by passing the class name instead of an 
     object as the element with index 0.
    </para>

    <para>
     <example>
      <title>
       Callback function examples
      </title>
      <programlisting role="php">
<![CDATA[
<?php 

// simple callback example
function foobar() {
    echo "hello world!";
}
call_user_function("foobar"); 

// method callback examples
class foo {
  function bar() {
    echo "hello world!";
  }
}

$foo = new foo;

call_user_function(array($foo, "bar")); // object method call

call_user_function(array("foo", "bar")); // static class method call

?>
]]>
      </programlisting>
     </example>
    </para>  
   
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Type Juggling</title>

   <simpara>
    PHP does not require (or support) explicit type definition in
    variable declaration; a variable's type is determined by the
    context in which that variable is used. That is to say, if you
    assign a string value to variable <parameter>$var</parameter>,
    <parameter>$var</parameter> becomes a string. If you then assign an
    integer value to <parameter>$var</parameter>, it becomes an
    integer.
   </simpara>
   <para>
    An example of PHP's automatic type conversion is the addition
    operator '+'. If any of the operands is a float, then all
    operands are evaluated as floats, and the result will be a
    float. Otherwise, the operands will be interpreted as integers,
    and the result will also be an integer. Note that this does NOT
    change the types of the operands themselves; the only change is in
    how the operands are evaluated.
    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo is string (ASCII 48)
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)
-->
$foo += 2;   // $foo is now an integer (2)
$foo = $foo + 1.3;  // $foo is now a float (3.3)
$foo = 5 + "10 Little Piggies"; // $foo is integer (15)
$foo = 5 + "10 Small Pigs";     // $foo is integer (15)
<!--

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    If the last two examples above seem odd, see <link
    linkend="language.types.string.conversion">String
    conversion to numbers</link>.
   </simpara>
   <simpara>
    If you wish to force a variable to be evaluated as a certain type,
    see the section on <link linkend="language.types.typecasting">Type
    casting</link>. If you wish to change the type of a variable, see
    <function>settype</function>.
   </simpara>
   <para>
    If you would like to test any of the examples in this section, you
    can use the <function>var_dump</function> function.
   </para>
   <note>
    <para>
     The behaviour of an automatic conversion to array is currently
     undefined.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a is a string
$a[0] = "f";  // What about string offsets? What happens?
      </programlisting>
     </informalexample>
    </para>
    <para>
     Since PHP (for historical reasons) supports indexing into strings
     via offsets using the same syntax as array indexing, the example
     above leads to a problem: should $a become an array with its first
     element being "f", or should "f" become the first character of the
     string $a?
    </para>
    <para>
     The current versions of PHP interpret the second assignment as
     a string offset identification, so $a becomes "f", the result
     of this automatic conversion however should be considered
     undefined. PHP 4 introduced the new curly bracket syntax to access
     characters in string, use this syntax instead of the one presented
     above: 
     <informalexample>
      <programlisting role="php">
$a    = "abc"; // $a is a string
$a{1} = "f";   // $a is now "afc"
      </programlisting>
     </informalexample>
     See the section titled <link linkend="language.types.string.substr">String
     access by character</link> for more informaton.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Type Casting</title>

    <para>
     Type casting in PHP works much as it does in C: the name of the
     desired type is written in parentheses before the variable which
     is to be cast.
     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo is an integer
$bar = (boolean) $foo;   // $bar is a boolean
      </programlisting>
     </informalexample>
    </para>
    <para>
     The casts allowed are:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - cast to integer</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - cast to boolean</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - cast to float</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - cast to string</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - cast to array</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - cast to object</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Note that tabs and spaces are allowed inside the parentheses, so
     the following are functionally equivalent:
     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Instead of casting a variable to string, you can also enclose
      the variable in double quotes.
     <informalexample>
      <programlisting role="php">
$foo = 10;            // $foo is an integer
$str = "$foo";        // $str is a string
$fst = (string) $foo; // $fst is also a string

// This prints out that "they are the same"
if ($fst === $str) {
    echo "they are the same";
}
      </programlisting>
     </informalexample>
     </para>
    </note>
     
    <para>
     It may not be obvious exactly what will happen when casting
     between certain types. For more info, see these sections:
    
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Converting to 
        boolean</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Converting to 
        integer</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">Converting to 
        float</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Converting to 
        string</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Converting to 
        array</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Converting to 
        object</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Converting to 
        resource</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
        &null;</link></simpara>
      </listitem>
      -->
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
