<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.3 $ -->
<!-- EN-Revision: 1.40 Maintainer: young Status: ready -->
 <chapter id="features.http-auth">
  <title>HTTP-Аутентификация в PHP</title>

  <simpara>
   <acronym>HTTP</acronym>-Аутентификация в PHP возможна только в том случае, когда он выполняется
   как модуль веб-сервера Apache, и, соответственно, недоступна для CGI-версии.
   Ваш скрипт может использовать функцию <function>header</function> для того,
   чтобы отправить браузеру клиента сообщение "Authentication Required",
   что в свою очередь приведет к появлению диалогового окна для ввода имени 
   пользователя и пароля. После того как клиент ввел свое имя и пароль, 
   скрипт будет вызван повторно, но уже с 
   <link linkend="reserved.variables">предопределенными переменными</link> 
   <varname>PHP_AUTH_USER</varname>, <varname>PHP_AUTH_PW</varname> 
   и <varname>AUTH_TYPE</varname>, которые соответственно содержат 
   имя пользователя, пароль и тип аутентификации. Эти переменные могут быть
   найдены в массиве <link linkend="reserved.variables.server">$_SERVER</link> и 
   <varname>$HTTP_SERVER_VARS</varname>.   В настоящее время поддерживается только 
   "Basic"-аутентификация. Также вы можете ознакомится с более детальным
   описанием функции <function>header</function>. 
  </simpara>

  <note>
   <title>Замечание касательно версии PHP</title>
   <para>
    <link linkend="language.variables.superglobals">Cуперглобальные переменные</link>, 
    такие как <link linkend="reserved.variables.server">$_SERVER</link>, доступны,
    начиная с  <ulink url="&url.php.release4.1.0;">4.1.0</ulink>. 
    Массив <varname>$HTTP_SERVER_VARS</varname> доступен в PHP 3 и выше.
   </para>
  </note>

  <para>
   Пример фрагмента скрипта, который вынуждает клиента авторизироваться для
   просмотра страницы:
  </para>
  <para>
   <example>
    <title>Пример HTTP-аутентификации</title>
    <programlisting role="php">
<![CDATA[
<?php
  if (!isset($_SERVER['PHP_AUTH_USER'])) {
    header('WWW-Authenticate: Basic realm="My Realm"');
    header('HTTP/1.0 401 Unauthorized');
    echo 'Текст, отправляемый в том случае,
    если пользователь нажал кнопку Cancel';
    exit;
  } else {
    echo "<p>Hello {$_SERVER['PHP_AUTH_USER']}.</p>";
    echo "<p>Вы ввели пароль {$_SERVER['PHP_AUTH_PW']}.</p>";
  }
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <title>Замечание касательно совместимости</title>
   <para>
    Будьте особенно внимательны при указании HTTP-заголовков. Для того, чтобы 
    гарантировать максимальную совместимость с наибольшим количеством
    различных клиентов, слово "Basic" должно быть написано с большой буквы "B",
    регион (realm) должен быть взят в двойный (не одинарные!) кавычки,
    и ровно один пробел должен предшествовать коду <emphasis>401</emphasis> в заголовке
    <emphasis>HTTP/1.0 401</emphasis>.
   </para>
  </note>

  <para>
   Вместо простого отображения на экране переменных <varname>PHP_AUTH_USER</varname> 
   и <varname>PHP_AUTH_PW</varname>, вам, возможно, понадобится
   проверить их корректность. Используйте для этого запрос к базе 
   данных или поиск пользователя в dbm-файле.
  </para>

  <para>
   Вы можете пронаблюдать особенности работы браузера Internet Explorer.
   Он очень требователен к параметру передаваемых заголовков. Указание
   заголовка <emphasis>WWW-Authenticate</emphasis> перед отправкой статуса
   <literal>HTTP/1.0 401</literal> является небольшой хитростью.
  </para>

  <simpara>
   Начиная с PHP 4.3.0, для того, чтобы предотвратить написание
   кем-либо скрипта, раскрывающего пароль к странице, которая использует
   внешнюю аутентификацию, переменные <varname>PHP_AUTH</varname> 
   не устанавливаются в случае, если данная страница использует 
   внешнюю аутентификацию и установлен &safemode;.  Несмотря на это,
   переменная <varname>REMOTE_USER</varname> может использоваться для
   аутентификации пользователя, прошедшего внешнюю аутентификацию.
   Таким образом, вы всегда можете воспользоваться переменной
   <varname>$_SERVER['REMOTE_USER']</varname>.
  </simpara>

  <note>
   <title>Замечание касательно конфигурации</title>
   <para>
    PHP использует указание директивы <literal>AuthType</literal> для
    указания того, используется внешняя аутентификация или нет.
   </para>
  </note>

  <simpara>
	Следует заметить, что все вышесказанное не предотвращает похищения паролей к
	страницам, требующим авторизацию, кем-либо, кто контролирует страницы без
	авторизации, расположенные на том же сервере.
  </simpara>
  <simpara>
   И Netscape Navigator и Internet Explorer очищают кеш аутентификации
   текущего окна для заданного региона (realm) при получении от сервера.
   Это может использоваться для реализации принудительного выхода пользователя
   и повторного отображения диалогового окна для ввода имени пользователя и 
   пароля. Некоторые разработчики используют это для ограничения авторизации по
   времени или для предоставления кнопки "Выход".
  </simpara>
  <para>
   <example>
    <title>Пример HTTP-аутентификации с принудительным вводом новой пары логин/пароль</title>
    <programlisting role="php">
<![CDATA[
<?php
  function authenticate() {
    header('WWW-Authenticate: Basic realm="Test Authentication System"');
    header('HTTP/1.0 401 Unauthorized');
    echo "Вы должны ввести корректный логин и пароль для получения доступа к ресурсу \n";
    exit;
  }
 
  if (!isset($_SERVER['PHP_AUTH_USER']) ||
      ($_POST['SeenBefore'] == 1 && $_POST['OldAuth'] == $_SERVER['PHP_AUTH_USER'])) {
   authenticate();
  } 
  else {
   echo "<p>Добро пожаловать: {$_SERVER['PHP_AUTH_USER']}<br />";
   echo "Предыдущий логин: {$_REQUEST['OldAuth']}";
   echo "<form action='{$_SERVER['PHP_SELF']}' METHOD='post'>\n";
   echo "<input type='hidden' name='SeenBefore' value='1' />\n";
   echo "<input type='hidden' name='OldAuth' value='{$_SERVER['PHP_AUTH_USER']}' />\n";
   echo "<input type='submit' value='Авторизоваться повторно' />\n";
   echo "</form></p>\n";
  }
?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Это поведение не регламентируется стандартами HTTP Basic-аутентификации,
   следовательно, вы не должны зависеть от этого. Как показали тесты,
   браузер Lynx не очищает кеш авторизации при получении от сервера
   статуса 401, и, нажав последовательно "Back", а затем "Forward" возможно
   открыть такую страницу, при условии, что требуемые атрибуты авториазации не изменились.
   Однако, пользователь может нажать клавишу  '_' для очистки кеша аутентификации.
  </simpara>
  <simpara>
   Также следует заметить, что до версии PHP 4.3.3, HTTP-аутентификация
   не работала на серверах под управлением Microsoft IIS, если PHP был установлен
   как CGI-модуль, в силу некоторых ограничений IIS. Для того, чтобы
   добиться корректной работы в PHP 4.3.3+, вы должны отредактировать
   конфигурационную настройку IIS под названием "Directory Security".
   Щелкните на надписи "Edit" и установите опцию "Anonymous Access",
   все остальные поля должны остаться неотмеченными.
  </simpara>
  <simpara>
   Еще одно ограничение, если вы используете IIS посредством ISAPI: переменные
  <literal>PHP_AUTH_*</literal> не определены, но в то же время доступна
  переменная <literal>HTTP_AUTHORIZATION</literal>. Пример кода, который вы могли бы
  использовать: <literal>list($user, $pw) = explode(':',  
   base64_decode(substr($_SERVER['HTTP_AUTHORIZATION'], 6)));</literal>
  </simpara>
  <note>
   <title>Замечание касательно IIS:</title>
   <simpara>
    Для того, чтобы HTTP-аутентификация корректно работала в IIS, в конфигурации
    PHP опция <link linkend="ini.cgi.rfc2616-headers">cgi.rfc2616_headers</link> должна
    быть установлена значением <literal>0</literal> (значение по умолчанию).
   </simpara>
  </note>
  <note>
   <para>
    В случае, если используется <link linkend="ini.safe-mode">защищенный режим</link>,
    UID текущего скрипта будет добавлен в <literal>realm</literal>-часть заголовка
    <literal>WWW-Authenticate</literal>.
   </para>
  </note>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
