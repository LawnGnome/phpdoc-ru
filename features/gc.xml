<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 303065 Maintainer: shein Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision$ -->
 <chapter xml:id="features.gc" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Сборка мусора</title>

  <para>
   В этом разделе описываются достоинства нового механизма сборки мусора 
   (также называемого Garbage Collection или GC), являющегося частью PHP 5.3.
  </para>

  <sect1 xml:id="features.gc.refcounting-basics">
   <title>Основы подсчета ссылок</title>
   <para>
    Переменная PHP хранится в контейнере, называемом "zval". Контейнер zval,
    помимо типа и значения переменной, также содержит два дополнительных элемента. 
    Первый называется "is_ref" и представляет булево значение, указывающее
    является или нет переменная частью "набора ссылок". Благодаря этому элементу PHP 
    знает как отличать обычные переменные от ссылок. С тех пор, как PHP дает возможность
    использовать пользовательские ссылки, создаваемые оператором &amp;, контейнер zval
    получил внутренний механизм подсчета ссылок для оптимизации использования памяти.
    Эта вторая часть дополнительной информации, называемая "refcount" (счетчик ссылок), содержит
    количество имен переменных, которые указывают на данный контейнер zval.
    Все имена переменных хранятся в таблице имен, отдельной для каждой
    области видимости переменных. Такая область видимости существует для главного скрипта, 
    а также внутри каждой функции и метода.
   </para>
   <para>
    Контейнер zval создается, когда новая переменная создается со значением, заданным неизменяемым выражением:
    <example>
     <title>Создание нового контейнера zval</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    В данном примере создаются имя переменной <literal>a</literal> в текущей области видимости
    и новый контейнер переменной с типом <type>string</type> и значением <literal>new string</literal>.
    Значение "is_ref" по умолчанию задается равным &false;, т.к. не создано ни одной пользовательской
    ссылки. Значение же "refcount" задается равным <literal>1</literal>, т.к. только одно имя переменной 
    указывает на данный контейнер. Отметим, что если "refcount" равен <literal>1</literal>, то "is_ref"
    будет всегда равен &false;. Если у Вас установлен <link xlink:href='&url.xdebug;'>Xdebug</link>, то
    Вы можете вывести эту информацию, вызвав функцию <function>xdebug_debug_zval</function>.
   </para>
   <para>
    <example>
     <title>Вывод информации об zval</title>
     <programlisting role="php">
<![CDATA[
<?php
xdebug_debug_zval('a');
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=1, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    Добавление другого имени переменной увеличивает счетчик ссылок.
   </para>
   <para>
    <example>
     <title>Увеличение счетчика ссылок zval</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
$b = $a;
xdebug_debug_zval( 'a' );
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=2, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    Счетчик ссылок здесь равен <literal>2</literal>, т.к. на один и тот же контейнер
    ссылаются оба имени переменных <varname>a</varname> и <varname>b</varname>.
    PHP не копирует контейнер, пока в этом нет необходимости. Когда "refcount"
    становится равным нулю, контейнер уничтожается. Уменьшение "refcount" на единицу
    происходит, когда имя переменной пропадает из области видимости 
    (например в конце функции) или когда вызывается <function>unset</function> для имени переменной.
   </para>
   <para>
    <example>
     <title>Уменьшение счетчика ссылок zval</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
$c = $b = $a;
xdebug_debug_zval( 'a' );
unset( $b, $c );
xdebug_debug_zval( 'a' );
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=3, is_ref=0)='new string'
a: (refcount=1, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    Если мы сейчас вызовем <literal>unset($a);</literal>,
    то контейнер, включая тип и значение, будет удален из памяти.
   </para>

   <sect2 xml:id="features.gc.compound-types">
    <title>Структурные типы данных</title>

    <para>
     Все несколько усложняется со структурными типами данных, такими как массивы(<type>array</type>) и
     объекты(<type>object</type>). В отличии от скалярных(<type>scalar</type>) значений, массивы и объекты
     хранят свои свойства в собственных таблицах имен.
     Это значит, что следующий пример создаст сразу три zval контейнера:
    </para>
    <para>
     <example>
      <title>Создание <type>array</type> zval</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=1, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры для простого массива</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/simple-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     Результат - три контейнера: <varname>a</varname>, <varname>meaning</varname> и <varname>number</varname>.
     Для увеличения и уменьшения "refcounts" применяются все те же правила.
     Ниже мы добавляем еще один элемент массива и устанавливаем ему значение уже существующего элемента:
    </para>
    <para>
     <example>
      <title>Добавление уже существующего элемента в массив</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
$a['life'] = $a['meaning'];
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=2, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42,
   'life' => (refcount=2, is_ref=0)='life'
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры для простого массива со ссылками</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/simple-array2.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     Вышеприведенный вывод Xdebug показывает, что и старый и новый элементы массива
     сейчас указывают на контейнер, чей "refcount" равен <literal>2</literal>.
     Хотя показано два контейнера со значением <literal>'life'</literal>, на самом 
     деле это один контейнер. Функция <function>xdebug_debug_zval</function> не выводит информации об этом,
     но Вы можете проверить это также отобразив указатели памяти.
    </para>
    <para>
     Удаление элемента из массива происходит точно так же, как и удаление имени переменной
     из области видимости: уменьшается "refcount" контейнера, на который ссылается элемент массива.
     Опять же, при достижении "refcount" нуля, контейнер удаляется из памяти.
     Пример:
    </para>
    <para>
     <example>
      <title>Удаление элемента из массива</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
$a['life'] = $a['meaning'];
unset( $a['meaning'], $a['number'] );
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'life' => (refcount=1, is_ref=0)='life'
)
]]>
      </screen>
     </example>
    </para>
    <para>
     Теперь будет интереснее, если добавить массив новым элементом в самого себя.
     В следующем примере мы также используем оператор присваивания по ссылке, чтобы
     PHP не создал копию массива.
    </para>
    <para>
     <example>
      <title>Добавление массива новым элементом в самого себя.</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'one' );
$a[] =& $a;
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=2, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=2, is_ref=1)=...
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры массива с циклическими ссылками</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/loop-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>   
     Можно увидеть, что переменная с массивом (<varname>a</varname>), так же как и второй элемент
     (<varname>1</varname>) сейчас указывают на контейнер с "refcount" равным <literal>2</literal>.
     Символы "..." в выводе означают рекурсию и указывают на оригинальный массив.
    </para>
    <para>
     Как и ранее, удаление имени переменной уменьшает счетчик ссылок контейнера на единицу.
     Если мы применим unset к переменной <varname>$a</varname> после вышеприведенного примера,
     то счетчик ссылок контейнера, на который указывают <varname>$a</varname> и элемент "1",
     изменится с "2" на "1":
    </para>
    <para>
     <example>
      <title>Удаление <varname>$a</varname></title>
      <screen>
<![CDATA[
(refcount=1, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=1, is_ref=1)=...
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры после удаления массива с циклическими ссылками, демонстрирующие утечку памяти</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/leak-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
   </sect2>

   <sect2 xml:id="features.gc.cleanup-problems">
    <title>Суть проблемы</title>
    <para>
     Хотя уже нет имени переменной во всех областях видимости, ссылающейся на 
     данную структуру, она не может быть очищена, т.к. элемент массива "1" попрежнему
     ссылается на этот массив. Т.к. теперь нет никакой возможности пользователю
     удалить эти данные, то мы получили утечку памяти.
     К счастью, PHP удалит эти данные при завершении запроса, но до этого момента 
     данные будут занимать место в памяти. Такая ситуация часто бывает, когда
     реализуются алгоритмы парсинга или другие, где есть дочерние элементы, 
     ссылающиеся на родительские. Еще чаще такая ситуация случается с объектами, 
     потому что они всегда неявно используются по ссылке.
    </para>
    <para>
     Эта ситуация может не беспокоить, если случается раз или два, но если 
     существуют тысячи или даже миллионы таких утечек памяти, то они уже становятся
     проблемой. Особенно в долгоработающих скриптах, таких как демоны, где запрос 
     не заканчивается никогда, или в больших наборах модульных тестов.
     В некоторых случаях может потребоваться свыше 2 Гб памяти, которая не всегда 
     есть на тестовом сервере.
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="features.gc.collecting-cycles">
   <title>Сбор циклических ссылок</title>
   <para>
    Обычно механизмы подсчета ссылок в памяти, например используемый в PHP ранее,
    не решают проблему утечки памяти из-за циклических ссылок.
    Начиная с версии 5.3.0 в PHP реализован синхронный механизм из исследования
    "<link xlink:href='&url.gc-paper;'>Параллельный сбор циклических ссылок в системах, использующих подсчет ссылок</link>",
    в котором рассматривается этот вопрос.
   </para>
   <para>
    Полное описание работы алгоритма выходит за рамки данного раздела, поэтому 
    приведены только основы. Прежде всего мы должны задать несколько основных правил. 
    Если счетчик ссылок увеличивается, то контейнер все еще используется и не является мусором.
    Если счетчик уменьшается до нуля, то zval может быть удален.
    С учетом этих правил получается, что мусор с циклическими  может получиться только
    при уменьшении счетчика ссылок до ненулевого значения. 
    Затем, в выделенных контейнерах можно найти мусор проверив возможность уменьшения
    всех счетчиков ссылок на единицу и определив те контейнеры, у которых счетчик станет равным нулю.  
   </para>
   <para>
     <mediaobject>
      <alt>Алгоритм сборки мусора</alt>
      <imageobject>
       <imagedata fileref="en/features/figures/gc-algorithm.png" format="PNG"/>
      </imageobject>
     </mediaobject>
   </para>
   <para>
    Для избежания постоянной проверки на мусор с циклическими ссылками при каждом уменьшении счетчика ссылок,
    алгоритм добавляет все возможные корни(zval контейнеры) в "корневой буфер" (помечено
    фиолетовым). Это также гарантирует попадание любого корня в буфер только один раз.
    Механизм сборки мусора стартует только тогда, когда наполняется буфер (см. шаг A
    на рисунке выше).
   </para>
   <para>
    На шаге B алгоритм производит поиск в глубину по всем возможным корням для 
    однократного уменьшения счетчика ссылок на единицу у всех контейнеров 
    (помечено серым цветом). На шаге C алгоритм снова производит поиск в глубину
    для проверки счетчиков ссылок. Если он находит счетчик с нулевым значением, то
    контейнер помечается как "белый" (на рисунке помечено синим). Если же счетчик больше нуля, то
    происходит поиск в глубину от этого контейнера с обратным увеличением счетчиков на единицу
    и с пометкой "черный" на их контейнерах. На последнем шаге D алгоритм проходит по
    корневому буферу и удаляет из него корни контейнеров, заодно проверяя какие контейнеры 
    помечены как "белые". Эти контейнеры будут освобождены из памяти.
   </para>
   <para>
    Теперь, когда Вы имеете представление о работе алгоритма, мы посмотрим на то,
    как он интегрирован в PHP. По умолчанию, сборщик мусора всегда включен.
    Для изменения этой опции используется параметр <option>zend.enable_gc</option>
    в &php.ini;.
   </para>
   <para>
    Если сборщик мусора включен, алгоритм поиска зацикливания выполняется каждый раз, 
    когда корневой буфер наполняется 10,000 корнями (Вы можете поменять это значение,
    изменив константу <literal>GC_ROOT_BUFFER_MAX_ENTRIES</literal> в файле 
    <literal>Zend/zend_gc.c</literal> в исходном коде PHP и пересобрав PHP).
    Если сборщик мусора выключен, алгоритм никогда не будет запущен. Тем не менее,
    буфер всегда заполняется корнями.
   </para>
   <para>
    Если буфер заполнился при выключенном механизме сборки мусора, то
    другие корни не будут в него записаны. Таким образом, если они окажутся
    мусором с циклическими ссылками, то никогда не будут очищены и создадут утечку памяти.
   </para>
   <para>
    Причиной постоянной записи корней в буфер является то, что это намного 
    быстрее, чем постоянно проверять включен ли механизм сборки мусора.
    Механизм сборка мусора и сам алгоритм, однако, могут занимать значительное 
    количество времени.
   </para>
   <para>
    Помимо изменения параметра <option>zend.enable_gc</option>, механизм сборки мусора
    также можно запустить и остановить вызвав функции <function>gc_enable</function> и
    <function>gc_disable</function> соответственно. 
    Кроме того, можно запустить сборку мусора, даже если корневой буфер не заполнен.
    Для этого Вы можете вызвать функцию <function>gc_collect_cycles</function>, которая
    также возвращает число циклических ссылок собранных алгоритмом.
   </para>
   <para>
    Причиной выключения и включения механизма сборки, а также его ручного запуска,
    может стать то, что некоторые части вашего приложения могут быть требовательными
    ко времени. В этих случаях Вы можете "убить" сборщик мусора, но вы также рискуете получить
    утечку памяти. Более целесообразно будет вызвать <function>gc_collect_cycles</function>
    непосредственно перед вызовом <function>gc_disable</function> для освобождения памяти и буфера.
    Это позволит использовать больше места для хранения корней, пока механизм будет отключен.
   </para>
  </sect1>

  <sect1 xml:id="features.gc.performance-considerations">
   <title>Вопросы производительности</title>
   <para>
    В предыдущем разделе нами уже говорилось, что простой сбор корней меньше
    влияет на производительность.
    Хотя запись корней в буфер по сравнению с их не записью в PHP 5.2
    работает медленней, другие изменения в работе PHP 5.3 сделали эту потерю 
    производительности незаметной.
   </para>
   <para>
    Есть две основные области влияющие на производительность: уменьшение размера
    используемой памяти и замедление работы при сборке мусора. Рассмотрим их.
   </para>

   <sect2 xml:id="features.gc.performance-considerations.reduced-mem">
    <title>Уменьшение размера используемой памяти</title>
    <para>
     Причинами запуска механизма сборки мусора для уменьшения используемой памяти
     могут быть: заполнение корневого буфера и вызов функции <function>gc_collect_cycles</function>.
     На графике ниже приведено использование памяти скрипта, запущенного в PHP 5.2 и PHP 5.3,
     без учета памяти, используемой самим PHP при запуске.
    </para>
    <para>
     <example>
      <title>Пример использования памяти</title>
      <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public $var = '3.1415962654';
}

$baseMemory = memory_get_usage();

for ( $i = 0; $i <= 100000; $i++ )
{
    $a = new Foo;
    $a->self = $a;
    if ( $i % 500 === 0 )
    {
        echo sprintf( '%8d: ', $i ), memory_get_usage() - $baseMemory, "\n";
    }
}
?>
]]>
      </programlisting>
      <mediaobject>
       <alt>Сравнение использования памяти в PHP 5.2 и PHP 5.3</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/gc-benchmark.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     В этом теоретическом примере мы создаем объект, свойство a которого
     задается ссылкой на сам объект. Когда в следующей итерации в скрипте переопределяется 
     переменная <varname>$a</varname>, происходит типичная утечка памяти.
     В данном случае пропадают два контейнера zval (контейнер объекта и контейнер свойства объекта), 
     но определяется только один корень - удаленная переменная. Когда корневой буфер
     заполняется после 10,000 итераций, запускается механизм сборки мусора и
     освобождается память, занимаемая переменными с циклическими ссылками.
     Этот процесс хорошо виден на графике использования памяти для PHP 5.3:
     после каждых 10,000 итераций график проседает.
     Сам по себе механизм в данном примере совершает немного работы, потому что
     структура утечек слишком проста. Из графика видно, что максимальное использование памяти 
     в PHP 5.3 составило около 9 Мб, когда как в PHP 5.2 оно продолжает возрастать.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.slowdowns">
    <title>Замедление работы</title>
    <para>
     Второй областью, где сборка мусора влияет на производительность,
     является потеря времени, когда сборщик мусора освобождает память.
     Чтобы понять уровень этого влияния, мы немного изменим предыдущий скрипт,
     добавив большее число итераций и промежуточных очисток утечек памяти. 
     Измененный скрипт:
    </para>
    <para>
     <example>
      <title>Влияние на производительность</title>
      <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public $var = '3.1415962654';
}

for ( $i = 0; $i <= 1000000; $i++ )
{
    $a = new Foo;
    $a->self = $a;
}

echo memory_get_peak_usage(), "\n";
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Мы запустим скрипт два раза: с включенной опцией <option>zend.enable_gc</option>
     и без нее.
    </para>
    <para>
     <example>
      <title>Запуск скрипта</title>
      <programlisting role="shell">
<![CDATA[
time php -dzend.enable_gc=0 -dmemory_limit=-1 -n example2.php
# and
time php -dzend.enable_gc=1 -dmemory_limit=-1 -n example2.php
]]>
      </programlisting>
     </example>
    </para>
    <para>
     На тестовой машине первая команда примерно выполняется 10.7 секунд, а 
     вторая примерно 11.4 секунды. Это примерно на 7% медленнее. Однако,
     максимальное использование памяти скриптом уменьшилось на 98% с 931 Мб до 10 Мб.
     Этот тест не очень научный, но он действительно демонстрирует преимущество 
     по использованию памяти, обеспечиваемое сборщиком мусора. Также хорошо то, что
     замедление всегда примерно 7% для этого скрипта, тогда как экономия памяти
     все больше и больше при нахождении нового мусора.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.internal-stats">
    <title>Внутренняя статистика сборщика мусора</title>
    <para>
     Можно получить немного больше информации о том, как механизм сборки
     мусора выполняется в PHP. Но для этого Вам необходимо пересобрать PHP
     для включения теста производительности и кода сбора данных. Вы должны
     установить переменную окружения <literal>CFLAGS</literal> в значение
     <literal>-DGC_BENCH=1</literal> до выполнения команды <literal>./configure</literal>
     с вашими параметрами. Следующие команды должны Вам помочь:
    </para>
    <para>
     <example>
      <title>Сборка PHP для включения теста производительности GC</title>
      <programlisting role="shell">
<![CDATA[
export CFLAGS=-DGC_BENCH=1
./config.nice
make clean
make
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Когда Вы запустите вышеприведенный пример с обновленным PHP, Вы
     увидите следующую информацию по завершении работы скрипта:
    </para>
    <para>
     <example>
      <title>Статистика GC</title>
      <programlisting role="shell">
<![CDATA[
GC Statistics
-------------
Runs:               110
Collected:          2072204
Root buffer length: 0
Root buffer peak:   10000

      Possible            Remove from  Marked
        Root    Buffered     buffer     grey
      --------  --------  -----------  ------
ZVAL   7175487   1491291    1241690   3611871
ZOBJ  28506264   1527980     677581   1025731
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Наиболее полезная статистика отображена в первом блоке. Можно увидеть,
     что механизм сборки мусора был запущен 100 раз, и суммарно было освобождено 
     свыше 2 миллионов записей в памяти. Максимум корней в буфере всегда будет равен 10,000, 
     если сборка мусора была запущена хотя бы один раз.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.conclusion">
    <title>Заключение</title>
    <para>
     В целом сборщик мусора в PHP вызовет ощутимые замедления только в случае,
     когда алгоритм сборки циклических ссылок действительно срабатывает, тогда как
     в обычных (небольших) скриптах не должно быть никакого падения производительности.
    </para>
    <para>
     Однако в тех случаях, когда механизм сборки должен срабатывать
     и в обычных скриптах, снижение используемой памяти позволяет одновременно работать на сервере
     большему их количеству.
    </para>
    <para>
     Преимущества наиболее очевидны для долгоработающих скриптов, таких как
     большие наборы тестов или демоны. Новый механизм также должен снизить утечки памяти 
     для <link xlink:href="&url.php.gtk;">PHP-GTK</link> приложений, которые выполняются 
     обычно дольше, чем Web-скрипты. 
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
