<?xml version="1.0" encoding="windows-1251"?>
<!-- $Revision: 1.4 $ -->
<!-- EN-Revision: 1.31 Maintainer: young Status: ready -->
<chapter id="features.commandline">
 <title>Использование PHP в командной строке</title>
 <!-- NEW DOCUMENTATION STARTS -->
 <para>
  Начиная с версии 4.3.0, PHP поддерживает новый
  вид <literal>SAPI</literal> (интерфейс разработки серверных приложений)
  под названием <literal>CLI</literal>, что означает <emphasis>
  интерфейс командной строки</emphasis>. Как видно из названия, этот вид
  SAPI предназначен для разработки консольных (или даже десктопных) приложений на
  PHP. Имеется несколько несущественных различий между
  <literal>CLI SAPI</literal> и другими видами <literal>SAPI</literal>, которые
  будут рассмотрены в этой главе.

  Будет полезно заметить, что <literal>CLI</literal> и <literal>CGI</literal> -
  различные <literal>SAPI</literal>-интерфейсы, хотя в их поведении много общего.
 </para>
 <para>
  
  Впервые в качестве эксперимента <literal>CLI SAPI</literal> был включен в релиз
  PHP 4.2.0, и при запуске скрипта <command>./configure</command>
  необходимо было явно указывать опцию <option role="configure">--enable-cli</option>.
  Начиная с PHP 4.3.0, <literal>CLI SAPI</literal> не является
  экспериментальным, и опция сборки <option role="configure">--enable-cli</option> 
  присутствует по умолчанию. Вы можете отключить <literal>CLI SAPI</literal> при помощи 
  опции <option role="configure">--disable-cli</option>.
 </para>
 <para>
  Что касается PHP 4.3.0, имя, расположение и существование бинарных модулей
  CLI/CGI зависит от того, как именно установлен PHP. По умолчанию при выполнении
  <command>make</command> создается как CGI, так и CLI модуль, в каталогах
  <filename>sapi/cgi/php</filename> и <filename>sapi/cli/php</filename> 
  соответственно, внутри директории с исходными кодами PHP.
  Cледует заметить, что оба файла имеют одинаковое название: PHP. 
  Что произойдет при выполнении <command>make install</command>, зависит от того,
  какие опции вы указали на стадии конфигурирования. В случае, если вы отдали предпочтение
  такому модулю SAPI как apxs, либо указали опцию <option role="configure">--disable-cgi</option>,
  модуль CLI будет скопирован в <filename>{PREFIX}/bin/php</filename> при
  выполнении <command>make install</command>, в противном случае будет скопирован 
  CGI-модуль. Например, если при запуске скрипта <command>./configure</command>
  вы указали опцию  <option role="configure">--with--apxs</option>, CLI-версия будет 
  скопирована в <filename>{PREFIX}/bin/php</filename> при выполнении <command>make
  install</command>. Если вы хотите перекрыть установленный CGI-модуль,
  используйте <filename>make install-cli</filename> после выполнения 
  <filename>make install</filename>. В качестве альтернативы вы могли бы указать опцию 
  <option role="configure">--disable-cgi</option> при выполнении скрипта <command>./configure</command>.
 </para>
 <para>
  <note>
   <para>
    Поскольку обе опции, <option role="configure">--enable-cli</option> и <option role="configure">
    --enable-cgi</option>, присутствуют по умолчанию, одного присутствия
    строки <option role="configure">--enable-cli</option> при выполнении скрипта 
	<command>./configure</command> недостаточно для того, чтобы CLI-версия была установлена 
	в <filename>{PREFIX}/bin/php</filename> при выполнении <command>make install</command>.
   </para>
  </note>
 </para>
 <para>
  Дистрибутивы для Windows между версиями PHP 4.2.0 и PHP 4.2.3 
  включают в себя CLI-модуль как <filename>php-cli.exe</filename>, 
  расположенный в той же директории, что и CGI-модуль <filename>php.exe</filename>. 
  Начиная с PHP 4.3.0 дистрибутив для Windows влючает в себя CLI-модуль 
  <filename>php.exe</filename>, расположенный в отдельной директории
  <filename class="directory">cli</filename>, полное имя - <literal>cli/php.exe</literal>.
  Начиная с  PHP 5, CLI-модуль расположен в основной директории и называется
  <filename>php.exe</filename>. CGI-модуль также включен в дистрибутив 
  под названием <filename>php-cgi.exe</filename>.
 </para>
 <para>
  Начиная с PHP 5, в дистрибутив для Windows входит новый файл <filename>php-win.exe</filename>.
  Он полностью эквивалентен CLI, за исключением того, что php-win абсолютно ничего не выводит,
  что приводит к отстутствию консоли (окно DOS не появляется на экране).
  Это поведение похоже на php-gtk. При сборке из исходных кодов вам необходимо указать опцию
  <option role="configure">--enable-cli-win32</option>.
 </para>
 <para>
  <note>
   <title>Какой из вариантов SAPI установлен?</title>
   <para>
    Выполните из командной строки <command>php -v</command> для получения
    информации о том, какой из двух модулей PHP установлен:
    CGI или CLI. Также вы можете использовать для этого функцию
    <function>php_sapi_name</function> или константу <constant>
    PHP_SAPI</constant>.
   </para>
  </note>
 </para>
 <para>
  <note>
   <para>
    Соответствующая страница руководства Unix была добавлена в PHP 4.3.2.  Вы 
    можете увидеть ее, выполнив в консоли <command>man php</command>.
   </para>
  </note>
 </para>
 <para>
  Основные отличия <literal>CLI SAPI</literal> от остальных реализаций
  <literal>SAPI</literal>:
  <itemizedlist>
   <listitem>
    <para>
     В отличие от <literal>CGI SAPI</literal> заголовки не пишутся в поток вывода.
    </para>
    <para>
     Несмотря на то, что в <literal>CGI SAPI</literal> есть способ подавить HTTP-заголовки,
     в <literal>CLI SAPI</literal> нет возможности их включить.
    </para>
    <para>
     CLI по умолчанию запускается в режиме  с подавлением сообщений, тем не менее,
     ключи <option>-q</option> и <option>--no-header</option> сохранены для
     обратной совместимости, что позволяет использовать написанные ранее CGI-скрипты.
    </para>
    <para>
     Текущая директория не изменяется на рабочую директорию скрипта.
     (Ключи <option>-C</option> и <option>--no-chdir</option> сохранены для обратной совместимости)
    </para>
    <para>
     Сообщения об ошибках выдаются в текстовом режиме (без HTML-форматирования).
    </para>
   </listitem>
   <listitem>
    <para>
     Некоторые настройки &php.ini; переопределены  в <literal>CLI
     SAPI</literal>, поскольку они не имеют особого смысла при работе в командной строке:
    </para>
    <para>
     <table>
      <title>Переопределяемые директивы &php.ini;</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Директива</entry>
         <entry>Значение по умолчанию в <literal>CLI SAPI</literal></entry>
         <entry>Комментарий</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
          Бывает достаточно сложно прочитать в консоли сообщение об ошибке, когда
          оно наполнено бессмысленными <literal>HTML</literal>-тегами, поэтому значение
          по умолчанию данной опции всегда &false;.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
          Желательно, чтобы любой вывод <function>print</function>, <function>echo</function>, 
          а также аналогичных функций немедлено отправлялся в стандартный поток вывода,
          а не попадал в буфер. Хотя вы все еще можете использовать <link linkend="ref.outcontrol">буферизацию вывода</link>,
          если хотите задержать вывод или манипулировать им.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0 (без ограничений)</entry>
         <entry>
          Из-за неограниченных возможностей использования PHP 
          в командной строке максимальное время выполнения скрипта не ограничено.
          В то время, как приложения, написанные для веб, выполняются достаточно быстро,
          консольные приложения могут выполняться в течении длительного времени.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
         <para>
          Благодаря значению &true; в <literal>CLI SAPI</literal> вам всегда доступны переменные
          <emphasis>argc</emphasis> (количество аргументов при запуске приложения)
          и <emphasis>argv</emphasis> (массив текущих аргументов).
         </para>
         <para>
          Начиная с PHP 4.3.0, при использовании <literal>CLI SAPI</literal> переменные
          <varname>$argc</varname> и and <varname>$argv</varname> 
          зарегистрированы и заполнены соответствующими значениями.
          В более ранних версиях создание этих переменных, так же, как и для
          <literal>CGI</literal> или модуля веб-сервера, требует 
          значение <emphasis>on</emphasis> директивы <link linkend="ini.register-globals">register_globals</link>.
          Независимо от версии PHP или статуса опции  register_global 
          они всегда доступны как элементы массива
          <link linkend="reserved.variables.server">$_SERVER</link> или
          <varname>$HTTP_SERVER_VARS</varname>.  Например:
          <varname>$_SERVER['argv']</varname>
         </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
      Эти директивы не могут быть инициализированы другими значениями 
      из конфигурационного файла &php.ini; или любого другого (в случае, если он указан).
      Это является ограничением, поскольку указанные выше значения по умолчанию применяются
      после обработки конфигурационных файлов. Тем не менее, эти значения
      могут быть изменены во время работы скрипта (хотя это не имеет особого смысла для указанных директив,
      например, для <link linkend="ini.register-argc-argv">register_argc_argv</link>).
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Облегчена работа с консолью, благодаря следующим определенным константам:
     <table>
      <title>Специфические CLI-константы</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Константа</entry>
         <entry>Описание</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STDIN</constant></entry>
         <entry>
         Уже открытый поток <literal>stdin</literal>. Константа хранит результат
         <programlisting role="php">
<![CDATA[
<?php

$stdin = fopen('php://stdin', 'r');

?>
]]>
         </programlisting>
Если вам необходимо прочитать строку из потока <literal>stdin</literal>, вы можете сделать
это следующим образом:
           <programlisting role="php"> 
  <![CDATA[ 
  <?php 
  $line = trim(fgets(STDIN)); // читаем строку из STDIN 
  fscanf(STDIN, "%d\n", $number); // читаем число из STDIN 
  ?> 
  ]]> 
           </programlisting> 
         </entry>
        </row>
        <row>
         <entry><constant>STDOUT</constant></entry>
         <entry>
         Уже открытый поток  <literal>stdout</literal>. Константа хранит результат
         <programlisting role="php">
<![CDATA[
<?php

$stdout = fopen('php://stdout', 'w');

?>
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDERR</constant></entry>
         <entry>
         Уже открытый поток <literal>stderr</literal>.  Константа хранит результат
         <programlisting role="php">
<![CDATA[
<?php

$stderr = fopen('php://stderr', 'w');

?>
]]>
         </programlisting>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Имея все это, вы не должны самостоятельно открывать, например, поток для
     <literal>stderr</literal>, а просто используйте константу вместо дескриптора потока:
     <programlisting role="shell">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
     </programlisting>
    Также вам не надо закрывать эти потоки, PHP автоматически закрывает
    их после завершения скрипта.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>CLI SAPI</literal> <emphasis role="strong">не</emphasis> 
     изменяет текущую директорию на директорию исполняемого скрипта!
    </para>
    <para>
     Пример, демонстрирующий отличие <literal>CGI SAPI</literal>:
     <programlisting role="php">
<![CDATA[
<?php
// Простейший тестовый скрипт под названием test.php
echo getcwd(), "\n";
?>
]]>
     </programlisting>
    </para>
    <para>
     В случае, если используется <literal>CGI</literal> версия, результат работы будет следующим:
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -q another_directory/test.php
/tmp/another_directory
]]>
     </screen>
     Это наглядно демонстрирует тот факт, что PHP 
     изменяет текущую директорию на директорию исполняемого скрипта.
    </para>
    <para>
     Использование <literal>CLI SAPI</literal> дает другой результат:
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f another_directory/test.php
/tmp
]]>
     </screen>
     Это позволяет писать более гибкие консольные скрипты на PHP.
    </para>
    <note>
     <para>
      <literal>CGI SAPI</literal> позволяет получить аналогичное <literal>CLI SAPI</literal>
      поведение в случае использования ключа <option>-C</option>  при запуске из командной строки.
     </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
 <para>
  Список опций, доступный при запуске PHP из командной строки,
  может быть получен в любой момент путем запуска PHP с ключом <option>-h</option>:
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [args...]
       php [options] -r <code> [args...]
       php [options] [-- args...]
  -s               Отображает исходный код с цветной подсветкой
  -w               Отображает исходный текст без комментариев и пробелов
  -f <file>        Исполняет <file>
  -v               Выводит информацию о версии PHP
  -c <path>|<file> Ищет файл php.ini в указанной директории
  -a               Интерактивный запуск
  -d foo[=bar]     Установить конфигурационную опцию foo значением 'bar'
  -e               Генерация дополнительной информации для отладчика и профайлера
  -z <file>        Загрузить Zend-расширение <file>.
  -l               Проверить синтаксис
  -m               Показать подключенные модули
  -i               Выводит информацию о PHP
  -r <code>        Запустить PHP-код без использования <?..?>
  -h               Текущая справка

  args...          Аргументы, передаваемые скрипту. Используйте -- args в случае, если 
                   первый аргумент начинается с '-' или сам скрипт читается из потока STDIN.
]]>
  </screen>
 </para>
 <para>
  <literal>CLI SAPI</literal> имеет три различных способа получения 
  PHP-кода, который необходимо выполнить:
  <orderedlist>
   <listitem>
    <para>
     Указать PHP на исполнение конкретного файла.
    </para>
    <para>
     <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
     </screen>
     Оба способа (с или без использования ключа <literal>-f</literal>) исполняют
     указанный файл <filename>my_script.php</filename>. Вы можете выбрать любой файл - 
     ваши PHP-скрипты не обязаны заканчиваться на <literal>.php</literal>,
     а могут иметь любое имя и расширение.
    </para>
   </listitem>
   <listitem>
    <para>
     Указать PHP-код для выполнения непосредственно в командной строке.
    </para>
    <para>
     <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
     </screen>
     Особого внимания требует подстановка переменных окружения и использование кавычек.
    </para>
    <note>
     <para>
      Посмотрите внимательно на пример: в нем нет начальных и конечных тегов!
      При использовании ключа <option>-r</option> они не нужны. Использование 
      их в данном примере приведет к синтаксической ошибке.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Предоставить PHP-код для выполнения посредством стандартного потока <literal>stdin</literal>.
    </para>
    <para>
     Это позволяет динамически создавать  PHP-код и переадресовывать
     его исполняемому модулю, как показано в следующем (вымышленном) примере:
     <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
     </screen>
    </para>
   </listitem>
  </orderedlist>
  Вы не можете комбинировать эти три способа выполнения кода.
 </para>
 <para>
  Как и в любом консольном приложении, не только PHP,
  но и сам скрипт может принимать аргументы командной строки. Количество 
  передаваемых аргументов в PHP не ограничено (хотя 
  консоль имеет некоторое ограничение на количество передаваемых символов,
  но на практике вы не должны с этим столкнуться). Все аргументы, переданные 
  вашему скрипту, доступны в виде глобального массива <varname>$argv</varname>. 
  Нулевой элемент содержит имя скрипта (которое является символом <literal>-</literal> 
  в случае, если PHP-код читается из потока stdin или указан
  в командной строке при помощи ключа <option>-r</option>). 
  Вторая определяемая глобальная переменная <varname>$argc</varname> содержит количество
  элементов массива <varname>$argv</varname> (а <emphasis role="strong">не</emphasis> количество
  аргументов, передаваемых при запуске).
 </para>
 <para>
  До тех пор, пока передаваемые аргументы не начинаются с символа 
  <literal>-</literal>, ничего особенного предпринимать не надо. Но при
  указании аргумента, который начинается с символа <literal>-</literal>,
  может возникнуть проблема, так как PHP попытается обработать
  их самостоятельно. Чтобы предотвратить это, используйте <literal>--</literal> в качестве 
  разделителя списка аргументов. Все последующие за таким разделителем аргументы будут
  переданы вашему скрипту без изменений.
 </para>
 <para>
  <screen>
<![CDATA[
# Приведенный пример не выполнит указанный код, а выдаст справку об использовании PHP
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# Аргумент '-h' будет передан скрипту, справка напечатана не будет
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
  </screen>
 </para>
 <para>
  Однако, существует еще один способ использования PHP для
  написания консольных скриптов. Вы можете написать скрипт, первая строка которого
  начинается с <literal>#!/usr/bin/php</literal>. Следующие строки содержат обыкновенный
  PHP-код, обрамленный открывающими и завершающими PHP-тегами.
  Также необходимо установить права на выполнение (как правило, это <command>chmod +x test</command>), чтобы
  ваш скрипт мог запускаться, как обыкновенный консольный (или perl) скрипт:
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
var_dump($argv);
?>
]]>
  </programlisting>
  Предположив, что наш скрипт называется  <filename>test</filename> 
  и расположен в текущей директории, мы можем выполнить следующее:
  <screen>
<![CDATA[
$ chmod +x test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
  </screen>
  Как видно из примера, при передаче параметров командной строки, начинающихся с 
  символа <literal>-</literal>, никаких особых действий предпринимать не надо.
 </para>
 <para>
  Полные названия опций доступны, начиная с PHP 4.3.3.
  <table>
   <title>Опции, доступные из командной строки</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Опция</entry>
      <entry>Полное название</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-s</entry>
      <entry>--syntax-highlight</entry>
      <entry>
       <para>
        Отображает исходный код с цветной подсветкой
       </para>
       <para>
        Эта опция использует внутренний механизм разбора файла, генерирует
        подсвеченную <literal>HTML</literal>-версию и записывает ее в
        стандартный вывод. Следует заметить, что генерируется только блок
        <literal>&lt;code&gt; [...] &lt;/code&gt;</literal> с 
        <literal>HTML</literal>-тегами, без <literal>HTML</literal>-заголовков.
       </para>
       <note>
        <para>
         Эта опция не совместима с опцией <option>-r</option>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-s</entry>
      <entry>--syntax-highlighting</entry>
      <entry>
       <para>
        Алиас для <option>--syntax-highlight</option>.
       </para>
      </entry>
     </row>
     <row>
      <entry>-w</entry>
      <entry>--strip</entry>
      <entry>
       <para>
        Отображает исходный текст без комментариев и пробельных символов.
       </para>
       <note>
        <para>
         Эта опция не совместима с опцией <literal>-r</literal>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>--file</entry>
      <entry>
       <para>
        Исполняет указанный файл. Опция <literal>-f</literal> является не обязательной
        и может отсутствовать. Достаточно просто указать имя файла.
       </para>
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>--version</entry>
      <entry>
       <para>
        Выводит информацию о версии PHP, PHP SAPI и Zend, например:
        <screen>
<![CDATA[
$ php -v
PHP 4.3.0 (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.3.0, Copyright (c) 1998-2002 Zend Technologies
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>--php-ini</entry>
      <entry>
       <para>
        При помощи этой опции можно указать специфическую директорию для 
        конфигурационного файла &php.ini; либо непосредственно
        указать на сам <literal>INI</literal>-файл (название которого может
        отличаться от стандартного &php.ini;), например:
        <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
        </screen>
		В случае, если вы не используете данную опцию, конфигурационный
		файл будет взят из <link linkend="configuration.file">директории по умолчанию</link>. 
       </para>
      </entry>
     </row>
     <row>
      <entry>-n</entry>
      <entry>--no-php-ini</entry>
      <entry>
       <para>
        Указывает на необходимость игнорировать конфигурационный файл &php.ini;,
        доступен, начиная с PHP 4.3.0.
       </para>
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>--define</entry>
      <entry>
       <para>
        Эта опция позволяет устанавливать специальное значение для каждой из
        конфигурационных переменных, доступных в &php.ini;. Синтаксис выглядит следующим образом:
        <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
        </screen>
       </para>
       <para>
        Примеры (переводы строк использованы, чтобы сделать текст более читаемым):
        <screen>
<![CDATA[
# Если опущено значение, то соответствующей опции будет присвоено значение "1"
$ php -d max_execution_time
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Указание пустого значения инициализирует соответствующую  опцию значением ""
php -d max_execution_time=
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# Конфигурационная переменная будет установлена любым значением, 
# указанным после символа '='

$  php -d max_execution_time=20
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php
        -d max_execution_time=doesntmakesense
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-a</entry>
      <entry>--interactive</entry>
      <entry>
       <para>
        Запускает PHP в интерактивном режиме.
        <!-- 
        mfischer, 20020510: Couldn't come up with a decent useful description
        of the current implementation of the interactive mode.
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-e</entry>
      <entry>--profile-info</entry>
      <entry>
       <para>
        Генерирует дополнительную информацию для отладчика и профайлера.
        <!-- 
        mfischer, 20020510: Anyone who can provide more information what it
        really does (even if it's only for developers) ?
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-z</entry>
      <entry>--zend-extension</entry>
      <entry>
       <para>
        Подгружает дополнительный модуль Zend. В случае, если указано только
        имя файла, PHP ищет модуль в текущем пути к библиотекам по умолчанию
        (в Linux-системах он обычно указан в <filename>/etc/ld.so.conf</filename>).
        В случае, если указано имя файла и полный путь к нему, поиск в системных
        библиотеках не производится. Указание относительного пути к модулю приведет
        к поиску файла по указанному пути относительно текущей директории.
       </para>
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>--syntax-check</entry>
      <entry>
       <para>
        Эта опция предоставляет удобный способ для проверки заданного 
        PHP-кода на наличие синтаксических ошибок.
        В случае успешной проверки будет напечатана следующая фраза:
        "<literal>No syntax errors detected in &lt;filename&gt;</literal>",- и 
        код возврата будет равен <literal>0</literal>. А в случае неудачи - текст "<literal>Errors parsing
        &lt;filename&gt;</literal>" вместе с внутренними сообщениями разборщика и код 
        возврата <literal>255</literal>.
       </para>
       <para>
        Проверка исходного кода при помощи данной опции не находит фатальных
        ошибок (например, таких как вызов неопределенных функций). Используйте
        опцию <option>-f</option>, если вы хотите проверить код на наличие
        фатальных ошибок.
       </para>
       <note>
        <para>
         Эта опция не совместима с опцией <option>-r</option>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>--modules</entry>
      <entry>
       <para>
        При использовании этой опции PHP напечатает список встроенных 
        (а также подгруженных) модулей Zend и PHP. 
        <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>--info</entry>
      <entry>
       Использование этой опции приводит к вызову функции <function>phpinfo</function> и 
       и выводу результирующей информации. В случае, если PHP работает
       некорректно, будет весьма логично выполнить <command>php -i</command> и посмотреть,
       выводятся ли сообщения об ошибке до информационных таблиц или даже вместо них.
       Учтите, что в случае использования <acronym>CGI</acronym>-модуля весь вывод будет в 
       формате <literal>HTML</literal> и, как следствие, может выглядеть нечитабельно.
      </entry>
     </row>
     <row>
      <entry>-r</entry>
      <entry>--run</entry>
      <entry>
       <para>
        Эта опция позволяет выполнять PHP-код, указанный 
        непосредственно в командной строке. Открывающие и завершающие
        PHP-теги (<literal>&lt;?php</literal> и <literal>?&gt;</literal>)
        <emphasis role="strong">не нужны</emphasis> и, более того, приводят 
        к синтаксической ошибке.
       </para>
       <note>
        <para>
         При использовании этого ключа следует быть очень осторожным и избегать
         недоразумений, связанных с автоматической подстановкой переменных окружения.
        </para>
        <para>
         Вот пример, приводящий к синтаксической ошибке:
         <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
         </screen>
         Проблема заключается в том, что sh/bash выполняет автоматическую
         подстановку переменных в случае, если используются двойные кавычки 
         (<literal>"</literal>). Поскольку переменная <varname>$foo</varname>
          вряд ли определена, она заменяется пустой строкой, так что
          передаваемый PHP-код для выполнения выглядит следующим
          образом:
         <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
         </screen>
         Правильным решением в данном случае будет использование 
         одиночных кавычек <literal>'</literal>, поскольку автоматическая 
         подстановка переменных, заключенных в одиночные кавычки, в sh/bash не происходит.
         <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
         </screen>
         Если вы используете оболочку, отличную от sh/bash, у вас могут возникнуть
         другие вопросы. В таком случае создайте рапорт о возникшей проблеме на сайте
		 <ulink url="&url.php.bugs;">&url.php.bugs;</ulink> или 
         напишите письмо по адресу &email.php.doc;. Вы вполне можете столкнуться
         с проблемами при попытке получить доступ к переменным оболочки или
         при работе с экранирующими обратными слешами. Мы вас предупредили.
        </para>
       </note>
       <note>
        <para>
         Ключ <option>-r</option> доступен в <emphasis>CLI</emphasis>
         SAPI и не доступен в <emphasis>CGI</emphasis> SAPI.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>--help</entry>
      <entry>
       При помощи этой опции вы можете получить информацию о действующем
       списке опций командной строки и их краткое описание.
      </entry>
     </row>
     <row>
      <entry>-?</entry>
      <entry>--usage</entry>
      <entry>
       Алиас для <option>--help</option>.
      </entry>
     </row>
     <!--
     new, not in PHP 4.3.4, but are in php_cli.c 1.102 or cgi_main.c 1.243
     -b <address:port>|<port> bindpath Bind Path for external FASTCGI Server mode, only CGI, no Windows
     -B <begin_code>     process-begin Run PHP <begin_code> before processing input lines
     -R <code>           process-code  Run PHP <code> for every input line
     -F <file>           process-file  Parse and execute <file> for every input line
     -E <end_code>       process-end   Run PHP <end_code> after processing all input lines
     -H                  hide-args     Hide any passed arguments from external tools.
     -g                  global        Define global variables on command line
     -->
    </tbody>
   </tgroup>
  </table>
 </para>
 <!-- NEW DOCUMENTATION ENDS -->

 <!-- OLD DOCUMENTED STARTS
  mfischer, 20020510: I've commented out the start paragraphs of the old
  documentation as it is meant to be replaced by the new one.
 <para>
  The command line options of the PHP executable are useful
  if you would like to debug or test your PHP setup, but they
  can also be handy, if you would like to use PHP for a
  different purpose than web scripting.
 </para>
 <para>
  Note, that you can always direct the output of the PHP
  executable to an external file with the &gt; character,
  so <literal>php -q test.php &gt; test.html</literal> will
  print out the output of <filename>test.php</filename>
  without HTTP headers to the <filename>test.html</filename>
  file in the same directory.
 </para>
 <para>
  You can only use these command line options if you have
  the PHP executable. If you built the server module
  version, and you have no CGI version available on your
  machine, than you have no chance to use these options.
  For Windows users both the PHP executable and the server
  modules are in the binary package, the executable is
  named <filename>php.exe</filename>.
 </para>
 -->
 <para>
  Исполняемый PHP-файл может использоваться для запуска PHP-скриптов
  независимо от веб-сервера. В случае, если вы работаете в Unix-подобной системе,
  вам необходимо добавить ко всем скриптам специальную первую строку
  и сделать их исполняемыми, чтобы указать, какая из программ должна
  обрабатывать эти скрипты. На Windows-платформах вы можете назначить обработчик
  <filename>php.exe</filename> для файлов с расширениями <literal>.php</literal> 
  либо создать пакетный (.bat) файл для запуска скриптов посредством PHP.
  Строка, добавляемая вначале скрипта для Unix-систем, не влияет на их
  работу в ОС Windows, таким образом вы можете создавать кроссплатформенные 
  скрипты. Ниже приведен простой пример скрипта, выполняемого из 
  командной строки:
 </para>
 <para>
  <example>
   <title>Скрипт, предназначенный для запуска из командной строки (script.php)</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

Это консольный PHP-скрипт, принимающий один аргумент. 

  Использование:
  <?php echo $argv[0]; ?> <option>

  <option> Любое слово, которое вы хотели бы
  напечатать. Опции  --help, -help, -h,
  или -? покажут текущую справочную информацию.

<?php
} else {
    echo $argv[1];
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  В приведенном примере мы используем специальную первую строку
  для указания на то, что этот скрипт необходимо запускать при помощи
  PHP. Поскольку мы работаем с CLI-версией, то HTTP-заголовки выводиться
  не будут. При написании консольных приложений на PHP вам доступны две 
  переменные: <varname>$argc</varname> и <varname>$argv</varname>. 
  Первая - количество переданных аргументов плюс один (имя выполняемого скрипта).
  Вторая - массив переданных аргументов, начиная с имени скрипта с нулевым 
  индексом (<varname>$argv[0]</varname>).
 </para>
 <para>
  Также в приведенном примере мы проверяем количество переданных аргументов.
  В случае, если их более или менее одного, а также в случае, если переданный
  аргумент был <option>--help</option>, <option>-help</option>, <option>-h</option> или <option>-?</option>,
  мы выводим справочное сообщение, подставляя имя выполняемого скрипта динамически.
  В обратном случае мы просто печатаем полученный аргумент.
 </para>
 <para>
  Если вы хотите выполнить приведенный пример в Unix-системе, вам необходимо
  сделать его исполняемым и просто выполнить из консоли 
  <command>script.php echothis</command> или
  <command>script.php -h</command>. В Windows-системе вы можете создать для этого
  пакетный файл: 
 </para>
 <para>
  <example>
   <title>Пакетный файл для запуска PHP-скрипта из командной строки (script.bat)</title>
   <programlisting role="shell">
<![CDATA[
@c:\php\cli\php.exe script.php %1 %2 %3 %4
]]>
   </programlisting>
  </example>
 </para>
 <para>
  Предполагая, что скрипт называется
  <filename>script.php</filename> и полный путь к
  CLI <filename>php.exe</filename> совпадает с 
  <filename>c:\php\cli\php.exe</filename>, приведенный пакетный файл
  запустит скрипт с переданными вами параметрами:
  <command>script.bat echothis</command> либо
  <command>script.bat -h</command>.
 </para>
 <para>
  Вы также можете ознакомится с расширением <link linkend="ref.readline">Readline</link>,
  которое может быть использовано для усовершенствования консольного PHP-скрипта.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
